-----------------------------------------------------------------------------
-- 2.10.6.0 || 2.10.6.0 || 2.10.6.0 || 2.10.6.0 || 2.10.6.0 || 2.10.6.0 || --
-----------------------------------------------------------------------------

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.CONTROLE_BIOMETRIA_REP'))
  DROP TRIGGER TELESSVR.CONTROLE_BIOMETRIA_REP
GO

CREATE TRIGGER TELESSVR.CONTROLE_BIOMETRIA_REP ON TELESSVR.CONTROLE FOR UPDATE
AS

BEGIN
--VERSION_CONTROL 1.0.4.0 VERSION_CONTROL

  DECLARE @NEW_ICARD CHAR(12)
  DECLARE @NEW_VER_DIGIT CHAR(1)
  DECLARE @OLD_VER_DIGIT CHAR(1)
  DECLARE @L_OPERACAO VARCHAR(1)
  

  DECLARE CCONTROLE CURSOR
    FOR SELECT I.ICARD, I.VER_DIGIT, D.VER_DIGIT FROM INSERTED I INNER JOIN DELETED D ON I.ICARD = D.ICARD

  OPEN CCONTROLE

  FETCH NEXT FROM CCONTROLE INTO @NEW_ICARD, @NEW_VER_DIGIT, @OLD_VER_DIGIT

  WHILE @@FETCH_STATUS = 0
  BEGIN
  
  
    IF @NEW_VER_DIGIT <> @OLD_VER_DIGIT
	BEGIN
	
	  IF @NEW_VER_DIGIT = 2
	    SELECT @L_OPERACAO = 3
	  ELSE
	    SELECT @L_OPERACAO = 8	  
	  
	  UPDATE TELESSVR.REPNDIGAUTO000 SET STATUS = @L_OPERACAO WHERE IFUNC IN (
          SELECT ICARD FROM TELESSVR.CONTROLE WHERE TITULAR = @NEW_ICARD
        ) OR IFUNC = @NEW_ICARD
	
	END	


    FETCH NEXT FROM CCONTROLE INTO @NEW_ICARD, @NEW_VER_DIGIT, @OLD_VER_DIGIT
	

  END
	
  CLOSE CCONTROLE
  
  DEALLOCATE CCONTROLE
  

END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.SITENTRADA_EI'))
  DROP TRIGGER TELESSVR.SITENTRADA_EI
GO

CREATE TRIGGER [TELESSVR].[sitentrada_ei] ON [TELESSVR].[SITENTRADA] FOR UPDATE, INSERT AS
DECLARE

	@end_ip         char(15),          
	@blueb          char(2),          
	@codtt          char(2),          
	@data_alarme    datetime,
	@entradas       char(30),          
	@local_ocorr    char(30),
	@erro           int,
	@CodiPlan       numeric(3), 
	@CodiCole       numeric(3),
	@endent         numeric(2),
	@codsin         smallint, 
	@deslog         varchar(254),
	@datcol         varchar(8),
	@horcol         int,
	@seqcol         int,
	@TipoAlar       int,
	@feriado        int,
	@dia_semana     int,
	@dia            int,
	@mascara_alarme int,
	@ModeCont       smallint

BEGIN	
    
	declare cur_sitentrada_ins_new cursor for select end_ip, blueb, codtt, data_alarme, entradas, local_ocorr from inserted for read only
  
  select @seqcol = 0 ;

  open cur_sitentrada_ins_new 
  
	fetch next from cur_sitentrada_ins_new into @end_ip, @blueb, @codtt, @data_alarme, @entradas, @local_ocorr


	while ( @@fetch_status = 0 )
	begin

	  select @erro = 0, @deslog = '', @seqcol = @seqcol + 1
	
		if not exists ( select 1 from suricato.TbCodin where isnull( NumeEndeCole, '000.000.000.000' ) = @end_ip )
				if not exists ( select 1 From suricato.TbCodin where  CodiGereAces = cast(@blueb as int) and NumeTermArl = cast(@codtt as int) )
						select @erro = 1, @deslog = 'SITENTRADA: Codin não cadastrado.'

		if ( @data_alarme is null ) or (convert( char(12), @data_alarme , 14 ) = '00:00:00:000' )
			select @erro = 1, @deslog = 'SITENTRADA: Formato de data inválido: DATA_ALARME = ' + cast( @data_alarme as varchar )
        
  
		-- ERRO: CODIN NÃO CADASTRADO, OU DATA INVÁLIDA
		if @erro = 0
		begin

				/* >>> Identificação do CODIN */ 
				if @end_ip  != '000.000.000.000'
						select 
								@CodiPlan = CodiPlan, 
								@CodiCole = CodiCole,
			@ModeCont = ModeCont
							from 
								suricato.TbCodin C
				inner join suricato.TbModelCodin MC
				on C.CodiModeCole = MC.CodiModeCole
							where
								isnull ( NumeEndeCole, '000.000.000.000' ) = @end_ip 
				else
						select 
								@CodiPlan = CodiPlan, 
								@CodiCole = CodiCole
							from 
								suricato.TbCodin
							where
								CodiGereAces = cast(@blueb as int) and 
								NumeTermArl  = cast(@codtt as int)
				/* >>> Identificação do CODIN */ 
	

				select @endent = charindex( '2',@entradas )
				
				if @endent > 0 
					select @codsin = 99, @endent = @endent - 1

					
				if @codsin is null
				begin

					select @endent = charindex( '1',@local_ocorr )

					if @endent > 0 
						select @endent = @endent - 1 

					if @ModeCont is not null and @ModeCont = 12
					begin
						select @codsin = 100 + @endent
					end
					else
					begin
						select @codsin = CodiSind from suricato.TbEntraCodin where CodiPlan = @CodiPlan and CodiCole = @CodiCole and EndeEntrCole = @endent and CodiSind != 99
					end ;

				end 


				if @codsin is null
					select @erro = 1, @deslog = 'SITENTRADA: Código de sinal não cadastrado.'
		
				select 
					@datcol = convert( char(8), @data_alarme, 112 ),
					@horcol = ( datepart( hour, @data_alarme ) * 60 ) + ( datepart( minute, @data_alarme ) ),
					@seqcol = datepart( second, @data_alarme ),
					@TipoAlar = convert( smallint, substring( @entradas, convert( tinyint, @endent + 1 ), 1 ) )

				 
				/* >>> Mascaramento de Alarme */
				select
						@feriado = count( DataFeri ) 
					from
						suricato.TbDatasFeria
					where
						DataFeri = convert( datetime, convert( char(10), getdate(), 111 ), 111 ) and
						CodiFeri in ( select
															FeriDiur
														from
															suricato.TbFilia
														where
															CodiFili in ( select
																								CodiFili
																							from
																								suricato.TbPlant
																							where
																								CodiPlan = @CodiPlan )
													UNION
													select
															FeriNotu
														from
															suricato.TbFilia
														where
															CodiFili in ( select
																								CodiFili
																							from
																								suricato.TbPlant
																							where
																								CodiPlan = @CodiPlan )
												)
												
				select @dia_semana = datepart( dw, getdate() )                    
				
				select @dia = case
												when @feriado = 0 and ( @dia_semana >= 2 and @dia_semana <= 6 ) then 1
												when @feriado = 0 and @dia_semana = 7 then 2
												when @feriado = 0 and @dia_semana = 1 then 3
												when @feriado > 0 then 4
											end   
																		 
				select 
						@mascara_alarme = count(0)
					from 
						suricato.TbAlarmFMasc 
					where 
						CodiPlan = @CodiPlan and
						CodiCole = @CodiCole and
						EndeEntrCole = @endent and
						DiaSema = @dia and
						InicFaixAces <= @horcol and 
						FimFaixAces >= @horcol
						
				/* <<< Mascaramento de Alarme */
				
				
				-- Insere na tabela de Mascaramento de Alarme, ou procede com a rotina padrão de alarme           
				-- MASCARAMENTO DE ALARME
				if @mascara_alarme > 0

						insert suricato.TbAlarmMasca
							(
								DataColeAlar,
								HoraColeAlar,
								SequColeAlar,
								DataAlar,
								HoraAlar,
								CodiPlan,
								CodiCole,
								CodiSind,
								TipoAlar,
								StatAlar                       
							)
							values
							(  
								convert( char(8), getdate(), 112 ),
								( datepart( hour, getdate() ) * 60 ) + ( datepart( minute, getdate() ) ),
								datepart( second, getdate() ) * 1000 + datepart( millisecond, getdate() ) + @seqcol,            
								convert( char(8), @data_alarme, 112 ),
								( datepart( hour, @data_alarme ) * 3600 ) + ( datepart( minute, @data_alarme ) * 60 ) + ( datepart( second, @data_alarme ) ),
								@CodiPlan,
								@CodiCole,
								@codsin,
								@TipoAlar,
								0
							)

				else
				begin

						if exists( select 1 from suricato.TbAlarSTrata where DataColeAlar = @datcol and HoraColeAlar = @horcol and SequColeAlar = @seqcol )
								select @erro = 1, @deslog = 'SITENTRADA: Marcação de alarme duplicado: ' + ', Data: ' + cast( @data_alarme as varchar )

						-- ERRO: MARCAÇÃO DUPLICADA                     
						if @erro = 0
						begin

	
								insert suricato.TbAlarSTrata
									(
										DataColeAlar,
										HoraColeAlar,
										SequColeAlar,
										DataAlar,
										HoraAlar,
										CodiPlan,
										CodiCole,
										CodiSind,
										TipoAlar,
										StatAlar,
										DataRecoAlar,
										HoraRecoAlar,
										UsuaReceChav,
										DescRecoUsua,
										TipoRecoReal,
										EndeEntrCole
									)
									values
									(  
										convert( char(8), getdate(), 112 ),
										( datepart( hour, getdate() ) * 60 ) + ( datepart( minute, getdate() ) ),
										datepart( second, getdate() ) * 1000 + datepart( millisecond, getdate() ) + @seqcol,            
										convert(datetime, convert(varchar(19), @data_alarme, 120), 120),
										( datepart( hour, @data_alarme ) * 3600 ) + ( datepart( minute, @data_alarme ) * 60 ) + ( datepart( second, @data_alarme ) ),
										@CodiPlan,
										@CodiCole,
										@codsin,
										@TipoAlar,
										0 ,
										'19001231',
										0,
										null,
										'',
										null,
										@endent
									)
			
								/* >>> Reação de Alarme */
								if @TipoAlar = 1

										insert into suricato.TbComanAcess 
												( CodiComa, CodiPlan, CodiCole, DataChegComa, HoraChegComa, SequCheg, StatComa, PrioExecComa, CodiUsua, ParaComa, TipoComa, OrigComa )
											select 
												CLA.CodiComa,
												CLA.CodiPlan,
												CLA.CodiCole,
												getdate(),
												datepart( hour, getdate() ) * 60 * 60 + datepart( minute, getdate() ) * 60 + datepart( second, getdate() ),
												1,
												0,
												0,
												1,
												CLA.ParaComa,
												1,
												1
											from 
												suricato.TbTipoReaco TR
											inner join suricato.TbComaLAcess CLA on
												TR.CodiLoteAces = CLA.CodiLoteAces
											where
												CodiReac in ( select 
																					CodiReac 
																				from 
																					suricato.TbEntraCodin EC 
																				where 
																					EC.CodiPlan = @CodiPlan and
																					EC.CodiCole = @CodiCole and
																					EC.EndeEntrCole = @endent
																		)
								else

										insert into suricato.TbComanAcess 
												( CodiComa, CodiPlan, CodiCole, DataChegComa, HoraChegComa, SequCheg, StatComa, PrioExecComa, CodiUsua, ParaComa, TipoComa, OrigComa )
											select 
												CLA.CodiComa,
												CLA.CodiPlan,
												CLA.CodiCole,
												getdate(),
												datepart( hour, getdate() ) * 60 * 60 + datepart( minute, getdate() ) * 60 + datepart( second, getdate() ),
												1,
												0,
												0,
												1,
												CLA.ParaComa,
												1,
												1
											from 
												suricato.TbTipoReaco TR
											inner join suricato.TbComaLAcess CLA on
												TR.CodiLoteAces = CLA.CodiLoteAces
											where
												CodiReac in ( select 
																					CodiReacInat 
																				from 
																					suricato.TbEntraCodin EC 
																				where 
																					EC.CodiPlan = @CodiPlan and
																					EC.CodiCole = @CodiCole and
																					EC.EndeEntrCole = @endent
																		)          
								/* <<< Reação de Alarme */


						end -- ERRO: MARCAÇÃO DUPLICADA                     

				end -- MASCARAMENTO DE ALARME
				
		end -- ERRO: CODIN NÃO CADASTRADO, OU DATA INVÁLIDA               
    
        if @erro <> 0
    
            insert suricato.TbMarcaRejei 
            (
              DataLogProc,
              ICard,
              DiaMarc,
              MesMarc,
              AnoMarc,
              HoraMarc,
              TipoAces,
              DireAces,
              BLUEB,
              CodiColeAlfa,
              NumeEndeIP,
              CodiFunc,
              DescLog,
              NomeTabeTele,
              DataAlar,
              EntrAlar,
              OcorAlar,
              NomeListBene,
              StatDeveBene,
              SeguMarc,
              Veic,
              PesoRefe,
              ValoKiloRefe,
              ValoRefe,
              QuanSobr,
              NiveAces,
              FaixHoraRefe,
              QuanCred,
              SituCrac,
              QuanMens
            )
            values
            ( 
              convert( numeric(14,6),  getdate() ),
              null,
              right( '00' + convert( char(2), datepart( day, @data_alarme )  ), 2  ),
              right( '00' + convert( char(2), datepart( month, @data_alarme )  ), 2  ),
              right( '00' + convert( char(4), datepart( year, @data_alarme )  ), 2  ),
              stuff( convert( char(5),@data_alarme , 108 ), 3, 1, ''),
              null,
              null,
              @blueb,
              @codtt,
              @end_ip,
              null,
              @deslog,
              'sitentrada',
              @data_alarme,
              @entradas,
              @local_ocorr,
              null,
              null,
              null,
              null,
              null,
              null,
              null,
              null,
              null,
              null,
              null,
              null,
              null
            )
  
        fetch next from cur_sitentrada_ins_new into
            @end_ip, @blueb, @codtt, @data_alarme, @entradas, @local_ocorr

    end
  
    close cur_sitentrada_ins_new 

    deallocate cur_sitentrada_ins_new

END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.SQLATG3G5_TAB_ACESSOSEG'))
  DROP PROCEDURE TELESSVR.SQLATG3G5_TAB_ACESSOSEG
GO
 
CREATE PROCEDURE TELESSVR.sqlatG3G5_tab_acessoSeg @cRegistro1 char(85) 
AS

DECLARE @cMatric char(12), @Retorno int
DECLARE @nTamG int , @cSubnv VARCHAR(9) , @cPlanta VARCHAR(9);

BEGIN

	SET @cMatric = substring(@cRegistro1, 1, 12)
	SET @Retorno = 0

	SET @nTamG = 3 
	SELECT	@nTamG  = COLUNAS.LENGTH
		FROM 
			SYSOBJECTS AS TABELAS,
			SYSCOLUMNS AS COLUNAS
		WHERE 
			-- JOINS 
			TABELAS.ID = COLUNAS.ID
			AND TABELAS.NAME = 'CONTROLE'
			AND COLUNAS.NAME = 'GRUPO'

	IF (@nTamG = 5) begin
		SET @cSubnv =  substring(@cRegistro1, 14, 7);
		SET @cPlanta =  substring(@cRegistro1, 21,5);
	end
	ELSE begin
		SET @cSubnv = substring (substring(@cRegistro1, 14, 7), 1, 5);
		SET @cPlanta = substring (substring(@cRegistro1, 21, 5), 1, 3);
	END

	SET LOCK_TIMEOUT 1000	
	UPDATE CONTROLE
	 set SITUA = substring(@cRegistro1, 13, 1),
	     --SUBNV = substring(@cRegistro1, 14,5),
	     Subnv = @cSubnv,
	     --PLANTA = substring(@cRegistro1, 21,3),
	     PLANTA = @cPlanta,
	     ULTRS = substring(@cRegistro1, 24+2,25),
	     FX_DTA = substring(@cRegistro1, 49+2,11),
	     QTD_MENS = substring(@cRegistro1, 60+2, 2),
	     CRED_FX1 = substring(@cRegistro1, 62+2, 2),
	     CRED_FX2 = substring(@cRegistro1, 64+2, 2),
	     CRED_FX3 = substring(@cRegistro1, 66+2, 2),
	     CRED_FX4 = substring(@cRegistro1, 68+2, 2),
	     CRED_FX5 = substring(@cRegistro1, 70+2, 2),
	     CRED_FX6 = substring(@cRegistro1, 72+2, 2),
	     ULTPAS_REF = substring(@cRegistro1, 74+2, 10),
	     ULTRSEG = substring(@cRegistro1, 84+2, 2)
	WHERE ICARD = @cMatric

	SET LOCK_TIMEOUT -1		

	return @Retorno
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.SQLCONG3G5_ACE_USUARIO'))
  DROP PROCEDURE TELESSVR.SQLCONG3G5_ACE_USUARIO
GO
 
CREATE PROCEDURE telessvr.sqlconG3G5_ace_usuario @cMatricNS char(22), @cInform char(20), @cTipTerm char(1), @Usuario char(15), @cOwner char(30), @cDataOcorr char(10), @cVisita char(12) AS
DECLARE	@cReg1 as varchar(250), @cReg2 as varchar(250), @cReg3 as varchar(250), 
		@cReg4 as varchar(250), @RetFun SMALLINT,
		@cReg5 as varchar(250), @cReg6 as varchar(250), @cReg7 as varchar(250), @cReg8 as varchar(250),
		@cReg9 as varchar(250), @cReg10 as varchar(250), @cReg11 as varchar(250)
DECLARE @ret int, @cUsuLock char(15), @cFxDiaEsp char(28), @cFxCred char(4), @Result int, @cMatBusca char(12)
DECLARE	@cIniHalm char(12), @cFimHalm char(12), @cIniIntj char(12), @cFimIntj char(12), @cFimAntD char(12)
DECLARE	@cIniHalmAux char(16), @cFimHalmAux char(16), @cIniIntjAux char(16), @cFimIntjAux char(16), @cFimAntDAux char(16)
DECLARE @dDataBD DATETIME, @dDataOcor DATETIME;
DECLARE @pos int
DECLARE @cModo char(1), @cFazLock char(1), @cDesbloqRev char(1),@cVerNumS char(1)
DECLARE @cVarAux char(12)
DECLARE @nGrest int, @nGrestEquip int, @nCont int
DECLARE @nArea int, @nAreaEquip int
DECLARE	@cEmFixa char(1), @AuxGr char(3), @AuxGr2 varchar(3);
DECLARE @cEscoltado char(12), @cEscolta char(12), @cEndIP char(15), @cTemEsc char(1), @cEhEscolta char(1), @cProcurado char(12), @cSentido CHAR(1)
DECLARE @nContArea int, @cFinalSentido CHAR(1), @AuxSentido CHAR(1), @nAuxArea int

DECLARE
        @cMatric   char(12),
        @cIcard    char(12),
        @cCPF	   char(11),
        @cNumSerial	   char(10),
		@cBloqBDCC char(1),
        --@cGrupo    char(3),
        @cCodig    char(6),
        @cTpFis    char(1),
        @cSitua    char(1),
        --@cSubNv    char(5),
        --@cPlanta   char(3),
        @cDataHora char(10),
        @cUltrs    char(25),
        @cDatIni   char(6),
        @cDatFim   char(6),
        @cTitular  char(12),
        @cFx_Flg   char(1), 
        @cFx_Dta   char(11), 
        @cFx_Alm   char(3),
        @cMensagem char(32), 
        @cDta_mens char(6),
        @cQtd_mens char(2),
        @cCred_Fx1 char(2), 
        @cCred_Fx2 char(2),
        @cCred_Fx3 char(2),
        @cCred_Fx4 char(2),
        @cCred_Fx5 char(2),
        @cCred_Fx6 char(2),
        @cFx1 char(8), 
        @cFx2 char(8), 
        @cFx3 char(8), 
        @cFx4 char(8), 
        @cFx5 char(8), 
        @cFx6 char(8), 
        @cUltPasR  char(10),
        --@cGrupo1   char(3),
        @cDatIniG1 char(10),
        @cDatFimG1 char(10),
        --@cGrupo2   char(3),
        @cDatIniG2 char(10),
        @cDatFimG2 char(10),
        --@cGrupo3   char(3),
        @cDatIniG3 char(10),
        @cDatFimG3 char(10),
        --@cGpoSab   char(3),
        --@cGpoDom   char(3),
        --@cGpoFer   char(3),
        @cAnti_D   char(1),
        @cBloq     char(1),
        @cVHora    char(1),
        @cVLocal   char(1),
        @cVValid   char(1),
        @cVAfast   char(1),
        @cVCred    char(1),
        @cVisEsp   char(1),
        @cVPonto   char(1),
        @cPonto    char(1),	
        @cVDigit   char(1),
      	@cTpoIntj  char(3), 
      	@cTolIntj  char(3), 
      	@cInterj   char(1),
      	@cTpoJorn  char(3), 
      	@cSaidaMax   char(1),
      	@cTipoDoc	char(1),
		@cVnDias   char(2),
		@cDiasSuc  char(2),
		@cPne    char(1),
		@cBloqRev    char(1),
		@cvViaRep char(1)

DECLARE
@cGrupo    char(5),	-- novo
@cSubNv    char(7),	-- novo
@cGrupo1   char(5),	-- novo
@cGrupo2   char(5),	-- novo
@cGrupo3   char(5),	-- novo
@cGpoSab   char(5),	-- novo
@cGpoDom   char(5),	-- novo
@cGpoFer   char(5),	-- novo
@cAdBuf VARCHAR(2),			-- novo
@nTamG int,
@cPlanta   char(5)

/*
DECLARE
@cGrupo    varchar(5),	-- novo
@cSubNv    varchar(7),	-- novo
@cGrupo1   varchar(5),	-- novo
@cGrupo2   varchar(5),	-- novo
@cGrupo3   varchar(5),	-- novo
@cGpoSab   varchar(5),	-- novo
@cGpoDom   varchar(5),	-- novo
@cGpoFer   varchar(5),	-- novo
@cAdBuf CHAR(2),			-- novo
@nTamG int,
@cPlanta   varchar(5)
*/

DECLARE @stmt1 nvarchar(4000)
DECLARE @ParmDefinition nvarchar(500);

	SET LOCK_TIMEOUT 1000	
	SET @RetFun = 0
	SET @cReg1  = ''
	SET @cReg2  = ''
	SET @cReg3  = ''
	SET @cReg4  = ''

	SET @cReg5  = ''
	SET @cReg6  = ''
	SET @cReg7  = ''
	SET @cReg8  = ''
	SET @cUsuLock = @Usuario

	SELECT @cAdBuf = null
	SELECT @nTamG = 3 
	SELECT	@nTamG  = COLUNAS.LENGTH
	FROM 
		SYSOBJECTS AS TABELAS,
		SYSCOLUMNS AS COLUNAS
	WHERE 
		-- JOINS 
		TABELAS.ID = COLUNAS.ID
		AND TABELAS.NAME = 'DAT07'
		AND COLUNAS.NAME = 'LACES'


	SET @Result = 1	
	SET @cMatric = substring(@cMatricNS, 1, 12);
	SET @cMatBusca = '000000000000'
	SET @cTipoDoc = '0'
	SET @cBloqBDCC = '0'
	SET @cFx1 = '24002400'
	SET @cFx2 = '24002400'
	SET @cFx3 = '24002400'
	SET @cFx4 = '24002400'
	SET @cFx5 = '24002400'
	SET @cFx6 = '24002400'

	set DATEFORMAT dmy
	SET @dDataOcor = CAST((substring(@cDataOcorr,5,2)+'-'+
							 substring(@cDataOcorr,7,2)+'-'+
							 substring(@cDataOcorr,9,2)+' '+
							 substring(@cDataOcorr,1,2)+':'+
							 substring(@cDataOcorr,3,2)+':'+
							 '00') AS datetime);

	SET @cModo = substring(@cInform, 1, 1);  -- TIPO DE PESQUISA
	-- cModo = 0 :icard; 
	-- cModo = 1 :numero serial
	-- cModo = 2 :cpf
	-- cModo = 3 :bdcc


	SET @cFazLock = 	substring(@cInform, 3, 1);  -- SE CONSULTA ONLINE
	SET @cDesbloqRev = 	substring(@cInform, 4, 1);  -- SE DESBLOQUEIO REVISTA
	SET @cVerNumS = 	substring(@cInform, 5, 1);  -- SE verifica NUMSERIAL
	SET @cEhEscolta =  	substring(@cInform, 6, 1);	-- SE É INDICADOR DE ESCOLTA

	-- *******************************************************
	-- verifica se modo de busca é por CPF
	IF (@cModo ='2') begin					-- CPF
		SELECT	@cIcard   = a.ICARD,
				@cCPF	  = c.CPF,
				@cTipoDoc = c.TIPODOC
				
			FROM ContCPF c 
				INNER JOIN Controle a
					ON c.CPF = substring(@cMatric, 2, 11) and c.icard = a.icard 

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end
	
	-- *******************************************************
	-- verifica se modo de busca é por ICARD
	ELSE IF (@cModo = '0') begin  			-- ICARD
		IF (@cVerNumS = '1') BEGIN
			SELECT	@cIcard   = a.ICARD,
					@cNumSerial  = a.NUMSERIAL
				FROM Controle a 
			WHERE a.ICARD = @cMatric and
   				  a.NumSerial = substring(@cMatricNS, 13, 10) 
				
			IF (@@ROWCOUNT = 0) begin
				-- SITUACAO SURICATO: VARIOS CARTOES SM COM MESMO ICARD, E NA CONTROLE ESTAO OS VALORES DE NUM.SERIAL NA COLUNA ICARD, TODOS COM O MESMO VALOR DO TITULAR
				-- A BUSCA PRIMEIRO SERA FEITA ICARD+NUMSERIAL. SE NÃO ACHOU, QUE É ONDE SE ENCONTRA AGORA, A BUSCA SERÁ SOBRE TITULAR+ICARD. QDO ENCONTRAR, O VALOR DE
				-- CMATBUSCA SERÁ O VALOR DO CAMPO ICARD

				SELECT	@cIcard   = a.TITULAR,
						@cVarAux  = a.ICARD
					FROM Controle a 
				WHERE a.TITULAR = @cMatric and
					  a.ICARD = '00'+substring(@cMatricNS, 13, 10) 

				IF (@@ROWCOUNT = 0) begin
					set @cIcard = '000000000000'	-- 12 zeros
					SET @RetFun = -2
					SET @Result = 0	
				end
				ELSE begin
					SET	@cMatBusca = @cIcard;
				end
			end
			ELSE begin
				SET	@cMatBusca = @cIcard;
			end
		end	

		ELSE begin
			SET @cMatBusca = @cMatric;
		end
	end
				
	-- *******************************************************
	-- verifica se modo de busca é por NUMERO SERIAL
	ELSE IF (@cModo = '1') begin  			-- NUMERO SERIAL
		SELECT	@cIcard   = a.ICARD,
				@cNumSerial  = a.NUMSERIAL
				
			FROM Controle a 
				WHERE a.NumSerial = substring(@cMatric, 3, 10) 
	
		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end

	-- *******************************************************
	-- verifica se modo de busca é por BDCC
	ELSE IF (@cModo = '3') begin  		
		SELECT	@cIcard   = a.ICARD,
				@cBloqBDCC  = c.Bloqueado
				
			FROM bdcc_cracha c 
			INNER JOIN Controle a
				ON c.Cracha = @cMatric and 
				   c.Cracha = a.ICARD  

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end

	-- *******************************************************
	-- verifica se encontrou o usuario, entao coleta informacoes do usuario
	IF (@Result = 1) begin			
		
		-- COLETA faixa horaria do usuario de acordo com o tipo de terminal 
				
		IF (@cTipTerm = '3') begin		  -- TERMINAL TIPO PONTO
			-- colocar 'X' no final de cReg1,cReg2,cReg3 e cReg4 pois o SQL trunca   valores
			-- com campos que contem branco (se o campo for o ultimo a ser concatenado)
			SELECT @cIcard    = a.ICARD,
					   @cReg1 = b.FX_DOM_P + b.FX_SEG_P + b.FX_TER_P + 'X', 
					   @cReg2 = b.FX_QUA_P + b.FX_QUI_P + b.FX_SEX_P + 'X', 
					   @cReg3 = b.FX_SAB_P + b.FX_REF + 'X',
					   --@cReg4 = a.FX_1 + a.FX_2 + a.FX_3 + a.FX_4 + a.FX_5 + a.FX_6 + 'X'
					   @cFx1 = a.FX_1, @cFx2 = a.FX_2, @cFx3 = a.FX_3, @cFx4 = a.FX_4, @cFx5 = a.FX_5, @cFx6 = a.FX_6
					   
			FROM  Controle a
				INNER JOIN  FxHoraria b  
					ON a.ICard = @cMatBusca and b.ICard = a.ICard
		end  			
		
		ELSE begin						-- TERMINAL QUE NAO É PONTO (ACESSO)
			SELECT @cIcard    = a.ICARD,
				   @cReg1 = b.FX_DOM_A + b.FX_SEG_A + b.FX_TER_A + 'X', 
				   @cReg2 = b.FX_QUA_A + b.FX_QUI_A + b.FX_SEX_A + 'X', 
				   @cReg3 = b.FX_SAB_A + b.FX_REF + 'X',
				   --@cReg4 = a.FX_1 + a.FX_2 + a.FX_3 + a.FX_4 + a.FX_5 + a.FX_6 + 'X' 
				   @cFx1 = a.FX_1, @cFx2 = a.FX_2, @cFx3 = a.FX_3, @cFx4 = a.FX_4, @cFx5 = a.FX_5, @cFx6 = a.FX_6
			FROM  Controle a
				INNER JOIN  FxHoraria b  
					ON a.ICard = @cMatBusca and b.ICard = a.ICard
		end

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
		end

		-- *******************************************************
		-- COLETA outros dados do usuario
		ELSE begin
			SELECT	@cIcard   = a.ICARD,
					@cGrupo   = a.GRUPO,
					@cCodig   = a.CODIG,
					@cTpFis   = a.TPFIS, 
					@cSitua   = a.SITUA,
					@cSubNv   = a.SUBNV,
					@cPlanta  = a.PLANTA,
					@cDataHora = a.DATAHORA,
					@cUltrs    = a.ULTRS,
					@cDatIni   = a.DATINI,
					@cDatFim   = a.DATFIM,
					@cTitular  = a.TITULAR,
					@cFx_Flg   = a.FX_FLG,
					@cFx_Dta   = a.FX_DTA,
					@cFx_Alm   = a.TEMPO_ALM,
					@cMensagem = a.MENSAGEM,
					@cDta_mens = a.DTA_MENS, 
					@cQtd_mens = a.QTD_MENS,
					@cCred_Fx1 = a.CRED_FX1,
					@cCred_Fx2 = a.CRED_FX2,
					@cCred_Fx3 = a.CRED_FX3,
					@cCred_Fx4 = a.CRED_FX4,
					@cCred_Fx5 = a.CRED_FX5,
					@cCred_Fx6 = a.CRED_FX6,
					@cUltPasR  = a.ULTPAS_REF,
					@cGrupo1   = a.GRUPO1,
					@cDatIniG1 = a.DATINIG1,
					@cDatFimG1 = a.DATFIMG1,
					@cGrupo2   = a.GRUPO2,
					@cDatIniG2 = a.DATINIG2,
					@cDatFimG2 = a.DATFIMG2,
					@cGrupo3   = a.GRUPO3,
					@cDatIniG3 = a.DATINIG3,
					@cDatFimG3 = a.DATFIMG3,
					@cGpoSab   = a.GRUPO_SAB,
					@cGpoDom   = a.GRUPO_DOM,
					@cGpoFer   = a.GRUPO_FER,
					@cAnti_D   = a.ANTI_DUPLA,
					@cBloq     = a.BLOQ_FALTA,
					@cVHora    = a.VER_HORA,
					@cVLocal   = a.VER_LOCAL,
					@cVValid   = a.VER_VALID,
					@cVAfast   = a.VER_AFAST,
					@cVCred    = a.VER_CRED,
					@cVisEsp   = a.VIS_ESP,
					@cVDigit   = a.VER_DIGIT,

					@cTpoIntj = a.TEMPO_RET,				
					@cTolIntj = a.TOLER_RET,
					@cInterj  = a.VER_RET,

					@cTpoJorn  = a.TEMPO_JORNADA, 
					@cSaidaMax = a.VER_SAIDAMAX,
					@cVnDias   = a.VER_NDIAS,
					@cPne      = a.PNE,
					@cBloqRev  = a.BLOQREV,
					@cvViaRep  = a.VER_VIAREP

				FROM Controle a
					WHERE  a.icard = @cMatBusca

			IF (@@ROWCOUNT = 0) begin
				set @cIcard = '000000000000'	-- 12 zeros
				SET @RetFun = -2
			end

			-- *******************************************************
			-- locka usuario se necessario
			ELSE begin
				IF (@cSitua = '4') or (@cFazLock = '0') begin 	-- se Provisorio, não 'bloqueia'. Sera 'bloqueado' o Titular
					set @ret = 0
				end
				ELSE begin
					SET @stmt1 = 'execute @p1 = ' + @cOwner + '.request_lock @cMat, @cUsu'
					SET @ParmDefinition = N'@cMat nvarchar(30), @cUsu CHAR(15), @p1 int OUTPUT ';		
					EXEC sp_executesql @stmt1, 
									@ParmDefinition, 
									@cMat = @cMatric, 
									@cUsu = @Usuario,
									@p1 = @ret OUTPUT		
				end		
	
				-- *******************************************************
				-- verifica se dados são nulos para preencher com valores default
				IF (@ret = 0) begin
					SET @cFxDiaEsp = SPACE(28);
					SET @cFxCred   = SPACE(4);
					-- Armazena dados da matricula em Registro
					-- colocar 'X' no final de cReg1, cReg2 e cReg3 pois o SQL trunca            -- valores com campos que contem branco (se o campo for o ultimo a ser       -- concatenado)
					if (@cCodig is Null) 
						SET @cCodig = SPACE(6);
					if (@cTpFis is Null) 
						SET @cTpFis = SPACE(1);
					if (@cSubNv is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cSubNv = '00'+SPACE(3);	-- 3 espacos
						ELSE
							SET @cSubNv = '00'+SPACE(5);	-- 5 espacos
					END
						
					if (@cPlanta is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cPlanta = '000';		--3
						ELSE
							SET @cPlanta = '00000';		-- 5 
					END

					if (@cDataHora is Null) 
						SET @cDataHora = '3112202359';
					if (@cUltrs is Null) 
						SET @cUltrs = '0101902359'+SPACE(10);
					if (@cFx_Flg is Null)  
						SET @cFx_Flg = '0';		-- 1 
					if (@cFx_Dta is Null)  
						SET @cFx_Dta = SPACE(11);
					if (@cFx_Alm is Null)  
						SET @cFx_Alm = SPACE(3);
					if (@cDatIni is Null) 
						SET @cDatIni = SPACE(6);
					if (@cDatFim is Null) 
						SET @cDatFim = SPACE(6);
					if (@cTitular is Null) 
						SET @cTitular = SPACE(12);
					if (@cMensagem is Null)  
						SET @cMensagem = SPACE(32);
					if (@cDta_mens is Null)  
						SET @cDta_mens = SPACE(6);
					if (@cQtd_mens is Null)  
						SET @cQtd_mens = SPACE(2);
					if (@cCred_Fx1 is Null)  
						SET @cCred_Fx1 = '00';		-- 2
					if (@cCred_Fx2 is Null)  
						SET @cCred_Fx2 = '00';		-- 2
					if (@cCred_Fx3 is Null)  
						SET @cCred_Fx3 = '00';		-- 2
					if (@cCred_Fx4 is Null)  
						SET @cCred_Fx4 = '00';		-- 2
					if (@cCred_Fx5 is Null)  
						SET @cCred_Fx5 = '00';		-- 2
					if (@cCred_Fx6 is Null)  
						SET @cCred_Fx6 = '00';		-- 2
					if (@cUltPasR is Null)  
						SET @cUltPasR = SPACE(10);

					if (@cGrupo1 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo1 = '000';	-- 3 
						ELSE
							SET @cGrupo1 = '00000'	-- 5 
					END
					if (@cDatIniG1 is Null) 
						SET @cDatIniG1 = SPACE(10);
					if (@cDatFimG1 is Null) 
						SET @cDatFimG1 = SPACE(10);

					if (@cGrupo2 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo2 = '000';	-- 3 
						ELSE
							SET @cGrupo2 = '00000'	-- 5 
					END
					if (@cDatIniG2 is Null) 
						SET @cDatIniG2 = SPACE(10);
					if (@cDatFimG2 is Null) 
						SET @cDatFimG2 = SPACE(10);
					
					if (@cGrupo3 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo3 = '000';	-- 3 
						ELSE
							SET @cGrupo3 = '00000'	-- 5 
					END
					if (@cDatIniG3 is Null) 
						SET @cDatIniG3 = SPACE(10);
					if (@cDatFimG3 is Null) 
						SET @cDatFimG3 = SPACE(10);

					if (@cGpoSab is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoSab = '000';	-- 3 
						ELSE
							SET @cGpoSab = '00000'	-- 5 
					END

					if (@cGpoDom is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoDom = '000';	-- 3 
						ELSE
							SET @cGpoDom = '00000'	-- 5 
					END

					if (@cGpoFer is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoFer = '000';	-- 3 
						ELSE
							SET @cGpoFer = '00000'	-- 5 
					END

					if (@cVisEsp is Null) 
						SET @cVisEsp = '0';		-- 1
					if (@cVDigit is Null) 
						SET @cVDigit = '2';		-- 1
					if (@cTpoIntj is Null) 
						SET @cTpoIntj = '000';		-- 3
					if (@cTolIntj is Null)
						SET @cTolIntj = '000';		-- 3
					if (@cInterj is Null)
						SET @cInterj = '0';		-- 1 
					if (@cTpoJorn is Null)
						SET @cTpoJorn = '000';		-- 3
					if (@cSaidaMax is Null)
						SET @cSaidaMax = '0';		-- 1 
					if (@cTipoDoc is Null)
						SET @cTipoDoc = '2';		-- 1 

					if (@cVnDias is Null) 
						SET @cVnDias = '00';		-- 2

					if (@cPne is Null)
						SET @cPne = '0';		-- 1 
					if (@cBloqRev is Null)
						SET @cBloqRev = '0';		-- 1 
					if (@cvViaRep is Null)
						SET @cvViaRep = '0';		-- 1 

					if (@cFx1 is Null)
						SET @cFx1 = '24002400';		-- 8 
					if (@cFx2 is Null)
						SET @cFx2 = '24002400';		-- 8 
					if (@cFx3 is Null)
						SET @cFx3 = '24002400';		-- 8 
					if (@cFx4 is Null)
						SET @cFx4 = '24002400';		-- 8 
					if (@cFx5 is Null)
						SET @cFx5 = '24002400';		-- 8 
					if (@cFx6 is Null)
						SET @cFx6 = '24002400';		-- 8 

					IF (@nTamG = 3) 
						SELECT @cAdBuf = SPACE(2);		-- 2 espços
					ELSE
						SELECT @cAdBuf = null


					SET @cReg4 = @cFx1 + @cFx2 + @cFx3 + @cFx4 + @cFx5 + @cFx6 + 'X'
					
					SET @cReg5 = @cIcard + @cGrupo + 
								 @cCodig + @cTpFis + @cSitua + @cSubNv + 
								 @cPlanta + 
								 'X'
					
					/*
					SET @cReg5 = @cIcard + @cGrupo + COALESCE(@cAdBuf, '') + 
								 @cCodig + @cTpFis + @cSitua + @cSubNv + COALESCE(@cAdBuf, '') + 
								 @cPlanta + COALESCE(@cAdBuf, '') + 'X'
					*/					

					SET @cReg6 = substring(@cDataHora,1,10) + @cUltrs + @cFx_Flg + @cFx_Dta + @cFx_Alm + 
								 @cFxDiaEsp + @cDatIni + @cDatFim + @cMensagem + @cDta_mens + @cQtd_mens  + 
								 @cCred_Fx1 + @cFxCred +
								 @cCred_Fx2 + @cFxCred +
								 @cCred_Fx3 + @cFxCred +
								 @cCred_Fx4 + @cFxCred +
								 @cCred_Fx5 + @cFxCred +
								 @cCred_Fx6 + @cFxCred +
								 @cUltPasR + @cTitular  + 'X'
								 
					SET @cReg7 = @cGrupo1 + @cDatIniG1 + @cDatFimG1 +
								 @cGrupo2 + @cDatIniG2 + @cDatFimG2 +
								 @cGrupo3 + @cDatIniG3 + @cDatFimG3 +
								 @cGpoSab + 
								 @cGpoDom + 
								 @cGpoFer + 
								 @cAnti_D + @cBloq + @cVHora + @cVLocal +
								 @cVValid + @cVAfast + @cVCred + @cVisEsp + 'X'


					/*
					SET @cReg7 = @cGrupo1 + COALESCE(@cAdBuf, '') + @cDatIniG1 + @cDatFimG1 +
								 @cGrupo2 + COALESCE(@cAdBuf, '') + @cDatIniG2 + @cDatFimG2 +
								 @cGrupo3 + COALESCE(@cAdBuf, '') + @cDatIniG3 + @cDatFimG3 +
								 @cGpoSab + COALESCE(@cAdBuf, '') + 
								 @cGpoDom + COALESCE(@cAdBuf, '') + 
								 @cGpoFer + COALESCE(@cAdBuf, '') + 
								 @cAnti_D + @cBloq + @cVHora + @cVLocal +
								 @cVValid + @cVAfast + @cVCred + @cVisEsp + 'X'
					*/					


					IF (@cDesbloqRev = '1')  
						SET @cBloqRev = '0'
					

					--SET @cReg8 = @cIcard + '0' + '0' + @cVDigit + 
					SET @cReg8 = @cIcard + @cvViaRep + '0' + @cVDigit + 
								 @cTpoIntj + @cTolIntj + @cInterj + 
								 @cTpoJorn + @cSaidaMax + 
								 @cTipoDoc + '00' + @cVnDias + 
								 --@cPne + @cBloqRev + 'X'
								 @cPne + @cBloqRev
				end
				-- matricula ja lockada
				ELSE
					SET @RetFun = -3
			end
		end
	END

	SET DATEFORMAT dmy
	SELECT @cIniHalmAux = CONVERT(char(8), a.Ini_Halm, 3)+ CONVERT(char(8), a.Ini_Halm, 8),
		   @cFimHalmAux = CONVERT(char(8), a.Fim_Halm, 3)+ CONVERT(char(8), a.Fim_Halm, 8),
		   @cIniIntjAux = CONVERT(char(8), a.Ini_Intj, 3)+ CONVERT(char(8), a.Ini_Intj, 8),
		   @cFimIntjAux = CONVERT(char(8), a.Fim_Intj, 3)+ CONVERT(char(8), a.Fim_Intj, 8),
		   @cFimAntDAux = CONVERT(char(8), a.Fim_AntiD, 3)+ CONVERT(char(8), a.Fim_AntiD, 8) ,
		   @cDiasSuc = a.Dias_Suc   
		   
	FROM DATAHORA a 
	WHERE a.ICARD = @cMatBusca
	
	IF (@@ROWCOUNT = 0) begin
  		SET @cIniHalm = '010106000000'	-- 01/01/06
		SET @cFimHalm = '010106000000'	-- 01/01/06
		SET @cIniIntj = '010106000000'	-- 01/01/06
		SET @cFimIntj = '010106000000'	-- 01/01/06
		SET @cFimAntD = '010106000000'	-- 01/01/06
		SET @cDiasSuc = '00';
	end
	ELSE begin
		SET @cIniHalm = substring (@cIniHalmAux,1,2)+substring (@cIniHalmAux, 4,2)+substring (@cIniHalmAux, 7,2)+
						substring (@cIniHalmAux,9,2)+substring (@cIniHalmAux,12,2)+substring (@cIniHalmAux,15,2)
		SET @cFimHalm = substring (@cFimHalmAux,1,2)+substring (@cFimHalmAux, 4,2)+substring (@cFimHalmAux, 7,2)+
						substring (@cFimHalmAux,9,2)+substring (@cFimHalmAux,12,2)+substring (@cFimHalmAux,15,2)
		SET @cIniIntj = substring (@cIniIntjAux,1,2)+substring (@cIniIntjAux, 4,2)+substring (@cIniIntjAux, 7,2)+
						substring (@cIniIntjAux,9,2)+substring (@cIniIntjAux,12,2)+substring (@cIniIntjAux,15,2)
		SET @cFimIntj = substring (@cFimIntjAux,1,2)+substring (@cFimIntjAux, 4,2)+substring (@cFimIntjAux, 7,2)+
						substring (@cFimIntjAux,9,2)+substring (@cFimIntjAux,12,2)+substring (@cFimIntjAux,15,2)
		SET @cFimAntD = substring (@cFimAntDAux,1,2)+substring (@cFimAntDAux, 4,2)+substring (@cFimAntDAux, 7,2)+
						substring (@cFimAntDAux,9,2)+substring (@cFimAntDAux,12,2)+substring (@cFimAntDAux,15,2)
	END
	
	SET @cReg9 = @cIcard + @cIniHalm + @cFimHalm + @cIniIntj + @cFimIntj + @cFimAntD + @cDiasSuc + 'X';

	--SET @cReg10 = @cBloqBDCC + 'X';
	SET @cReg10 = @cBloqBDCC;

	-- *******************************************************
	-- atualiza tab.CONTROLE se o usuario foi liberado pelo equipamento para revista
	IF (@RetFun = 0 AND 
		@Result = 1 AND 
		@cDesbloqRev = '1') begin
			IF (@cFazLock = '0') begin				-- marcacao offline
				SET @pos = CHARINDEX(' ', @cUltrs);  	-- VERIFICA SE data armazenada em BD tem valor em branco

				IF (@pos <= 10) and (@pos > 0) 
					SET @dDataBD = @dDataOcor;		-- assume temporariamente a mesma data de ocorrencia para que haja tualização
				ELSE begin
					set DATEFORMAT dmy
					SET @dDataBD = CAST((substring(@cUltrs,1,2)+'-'+substring(@cUltrs,3,2)+'-'+substring(@cUltrs,5,2)+' '+
							 			 substring(@cUltrs,7,2)+':'+substring(@cUltrs,9,2)+':'+'00') AS datetime);					
				end
				
				IF (@dDataOcor >= @dDataBD) 			-- atualiza BD porque a marcacao offline é mais recente que está em BD
					UPDATE CONTROLE SET BLOQREV = '0' WHERE ICARD = @cMatBusca;
			end
			ELSE
				UPDATE CONTROLE SET BLOQREV = '0' 
					WHERE ICARD = @cMatBusca
	end		

	-- *******************************************************
	-- verifica grupo do Estacionamento
	SET @nGrest = 0;
	SET @nGrestEquip = 0;
	SET @cEmFixa = '0';
	
	SELECT @nGrest = convert(int, GREST)  			-- VERIFICA SE O EQUIPAMENTO PERTENCE A ALGUM ESTACIONAMENTO
		FROM ESTAC001 
		WHERE END_IP = @Usuario;
	
	IF (@@ROWCOUNT = 0) begin
		SET @nGrest = 0;
		SET @nGrestEquip = 0;
	end			
	ELSE begin
		SET @nGrestEquip = @nGrest;
		
		SELECT @cEmFixa = EMFIXA   					-- VERIFICA SE A MATRICULA POSSUI VAGA FIXA NESTE ESTACIONAMENTO
			FROM ESTAC003 
			WHERE ICARD = @cMatBusca AND GREST = @nGrest;
			
		IF (@@ROWCOUNT = 0)			
			SET @nGrest = 0;
	END;

	SET @AuxGr2 = convert(char, @nGrest);
	SET @AuxGr = REPLICATE('0',3-LEN(@AuxGr2) ) + @AuxGr2;
	SET @cReg8 = @cReg8 + @AuxGr;								-- grupo de estacionamento do qual o usuario tem vaga fixa
	SET @cReg8 = @cReg8 + @cEmFixa + 'X';						-- indicador se estacionou em vaga fixa

	SET @AuxGr2 = convert(char, @nGrestEquip);
	SET @AuxGr = REPLICATE('0',3-LEN(@AuxGr2) ) + @AuxGr2;			-- grupo de estacionamento ao qual o equipamento faz parte
	SET @cReg10 = @cReg10 + @AuxGr + 'X'		-- posic 1 a 3	

	-- *******************************************************
	-- verifica Area de ESCOLTA
	SET @cTemEsc = '0'

	IF (@cEhEscolta = '0')		-- não é a escolta
	BEGIN
		SET @cProcurado = @cMatBusca
		SET @nContArea = 0
		SET @cFinalSentido = '0'
		
		SET @cEscoltado = @cMatBusca
		SET @cEscolta = '000000000000'
		SET @cTemEsc = '0'
		SET @cSentido = '0'	
		
		DECLARE escolt_cur CURSOR FOR
			SELECT AREA, SENTIDO FROM ESCOLT002 
				WHERE END_IP = @Usuario
				ORDER by AREA;

		OPEN escolt_cur
		FETCH next from escolt_cur into @nAuxArea, @AuxSentido
		WHILE (@@fetch_status != -1)
		BEGIN
			SET @nContArea = @nContArea + 1
		
			-- localiza a AREA e MATRICULA NA TABELA DE PESSOAS A SEREM ESCOLTADAS
			IF EXISTS (
				SELECT ICARD_ESCOLTADO, AREA 
					FROM ESCOLT001 
					WHERE ICARD_ESCOLTADO = @cProcurado AND
						  AREA = @nAuxArea)

			BEGIN
				SET @cFinalSentido = 
				CASE 
					WHEN @cFinalSentido = '0' 
						THEN ( @AuxSentido)
					WHEN @cFinalSentido = '1' AND (@AuxSentido = '2' OR  @AuxSentido = '3') 
						THEN '3'
					WHEN @cFinalSentido = '2' AND (@AuxSentido = '1' OR  @AuxSentido = '3')
						THEN '3'
						ELSE @cFinalSentido
				END
					
				SET @cTemEsc = '1'
				SET @cSentido = @cFinalSentido
			END
			
			FETCH next from escolt_cur into @nAuxArea, @AuxSentido
		END
		
		CLOSE escolt_cur
		DEAllocate escolt_cur
	END

	-- É A ESCOLTA
	ELSE BEGIN
	
		SET @nContArea = 0
		SET @cEscoltado = @cVisita
		SET @cEscolta = '000000000000'
		SET @cTemEsc = '0'
		SET @cSentido = '0'
	
		DECLARE escolt_cur CURSOR FOR
			SELECT AREA FROM ESCOLT002 
				WHERE END_IP = @Usuario
				ORDER by AREA;
	
		OPEN escolt_cur
		FETCH next from escolt_cur into @nAuxArea
		WHILE (@@fetch_status != -1)
		BEGIN
			SET @nContArea = @nContArea + 1
		
			-- VERIFICA SE A MATRICULA É AUTORIZADA A SER  ESCOLTA 

			IF EXISTS (
				SELECT ICARD_ESCOLTADO, AREA 
					FROM ESCOLT001 
					WHERE ICARD_ESCOLTADO = @cVisita AND
					   	  ICARD_GUARDA = @cMatBusca AND 
					      AREA = @nAuxArea)
			BEGIN
				SET @cEscoltado = @cVisita;
				SET @cEscolta = @cMatBusca;
				SET @cTemEsc = '0'	
				--SET @@fetch_status  = -1
				BREAK
			END
			ELSE
				FETCH next from escolt_cur into @nAuxArea
		END
		CLOSE escolt_cur
		DEAllocate escolt_cur
	END
	
	SET @cReg11 = @cEscoltado + @cEscolta + @cTemEsc + @cSentido + 'X';

	SET LOCK_TIMEOUT -1		
	
	SELECT @RetFun, 
		@cReg1, 
		@cReg2, 
		@cReg3, 
		@cReg4, 
		@cReg5, 
		@cReg6, 
		@cReg7, 
		@cReg8, 
		@cReg9,
		@cReg10,
		@cReg11,
		@nTamG
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.SQLCONSG3G5_TERM_FER_TCP'))
  DROP PROCEDURE TELESSVR.SQLCONSG3G5_TERM_FER_TCP
GO

CREATE PROCEDURE TELESSVR.sqlconsG3G5_term_fer_tcp @cEndIP CHAR(15), @cData varchar(6) AS

DECLARE @cTipo AS CHAR(1), --@cLocal AS CHAR(3), 
		@cLocal AS CHAR(5), --@cPlanta AS CHAR(3), 
		@cPlanta AS CHAR(5), 
		@ctipobio AS CHAR(1), 
		@cRastr AS CHAR(1), @cBuf AS VARCHAR(50), @cIniHA AS CHAR(1), @cFimHA AS CHAR(1), 
		@cValidR AS CHAR(1), @cValidSMax AS CHAR(1), @cTolAntes AS CHAR(2), @cTolApos AS CHAR(2),
		@cLeitSm AS CHAR(1), @cPosVPlaca AS CHAR(1), @cPosMensBloq  AS CHAR(1), @cValDiasSuc AS CHAR(1),
		@cParidRep AS CHAR(1), @cQtdMult AS CHAR(2),
		@cLMinimo AS CHAR(4), @cLMaximo AS CHAR(4), @cQtdAtual AS CHAR(4)
		
/*
OBS: SE USAR VARCHAR PARA ESTAS VARIAVEIS, DEVERÁ USAR O RECURSO DE COALESCE(ADBUF) para compor o resultado em cBuf.
SE USAR CHAR(5) como esta sendo usado, o select mesmo com local e planta com 3 digitos armazenara 2espacos em branco no final da variavel CHAR, portanto 
nao será necessario utilizar COALESCE 
DECLARE @cLocal AS VARCHAR(5), 
		@cPlanta AS VARCHAR(5)
*/
		
DECLARE @ret int, @DataAux varchar(10), @Descr varchar(31) 
DECLARE @nTamG int, @cAdBuf char(2)  --@cAdBuf varchar(2)			-- novo


--	SET LOCK_TIMEOUT 1000
	SET @ret = 0
	SET @cBuf = ' '
	set @DataAux = substring (@cData,1,2)+ '-'+ substring (@cData, 3,2)+ '-'+ substring (@cData, 5,2)
	SET DATEFORMAT DMY

	SET @cLocal = NULL;
	SET @cPlanta = NULL;
	SET @nTamG = 3 

	SELECT	@nTamG  = COLUNAS.LENGTH
		FROM 
			SYSOBJECTS AS TABELAS,
			SYSCOLUMNS AS COLUNAS
		WHERE 
			-- JOINS 
			TABELAS.ID = COLUNAS.ID
			AND TABELAS.NAME = 'DAT07'
			AND COLUNAS.NAME = 'LACES'

	IF (@nTamG = 3) 
		SET @cAdBuf = SPACE(2);		-- 2 espços
	ELSE
		SET @cAdBuf = null;


	SELECT @cTipo = TIP_TERM,
	       @cLocal = LACES,
	       @ctipobio = BIO_TIPO,
	       @cPlanta = PLANTA,
	       @cRastr = RASTREADOR,
	       @cIniHA = POS_INIHALM,
	       @cFimHA = POS_FIMHALM,
	       @cValidR = VALID_RET,
	       @cValidSMax = VALID_SAIDAMAX,
	       @cTolAntes = TOLER_ANTES,
	       @cTolApos = TOLER_APOS,
	       @cLeitSm = TIP_LEIT,
	       @cPosVPlaca = POSVALPLACA, 
	       @cPosMensBloq = POSMENSBLOQ,
	       @cValDiasSuc = VALID_NDIAS,
	       @cParidRep = PARIDREP,
	       @cQtdMult = QTDMULT,
		   @cLMinimo = REPLICATE('0', 4 - LEN(CAST (LMINIMO as varCHAR(4)))) + RTrim(LTRIM(STR(LMINIMO,4))),		-- insere 0's à esquerda para string final tamanho 4
		   @cLMaximo = REPLICATE('0', 4 - LEN(CAST (LMAXIMO as varCHAR(4)))) + RTrim(LTRIM(STR(LMAXIMO,4))),			-- insere 0's à esquerda para string final tamanho 4
		   @cQtdAtual = REPLICATE('0', 4 - LEN(CAST (QTDATUAL as varCHAR(4)))) + RTrim(LTRIM(STR(QTDATUAL,4)))			-- insere 0's à esquerda para string final tamanho 4
		       
	FROM DAT07 (NOLOCK)
		  WHERE END_IP = @cEndIP and blueb = '00' and codin = '00'

	IF (@@ROWCOUNT <> 0)
	BEGIN
		if (@cTipo is Null) 
			SET @cTipo = '1'
		
		if (@cLocal is Null) begin
			if (@nTamG = 3)	
				SET @cLocal = '000';
			else
				SET @cLocal = '00000';
		end
		
		if (@ctipobio is Null) 
			SET @ctipobio = '0'

		if (@cPlanta is Null) BEGIN
			if (@nTamG = 3)	
				SET @cPlanta = '000'
			else
				SET @cPlanta = '00000'
		end
		
		if (@cRastr is Null) 
			SET @cRastr = '0'
		if (@cIniHA is Null) 
			SET @cIniHA = '0'
		if (@cFimHA is Null) 
			SET @cFimHA = '0'
		if (@cValidR is Null) 
			SET @cValidR = '0'
		if (@cValidSMax is Null) 
			SET @cValidSMax = '0'
		if (@cLeitSm is Null) 
			SET @cLeitSm = '0'
		if (@cTolAntes is Null) 
			SET @cTolAntes = '00'
		if (@cTolApos is Null) 
			SET @cTolApos = '00'
		if (@cPosVPlaca is Null) 
			SET @cPosVPlaca = '0'
		if (@cPosMensBloq is Null) 
			SET @cPosMensBloq = '0'
		if (@cValDiasSuc is Null) 
			SET @cValDiasSuc = '0'
		if (@cParidRep is Null) 
			SET @cParidRep = '0'
		if (@cQtdMult is Null) 
			SET @cQtdMult = '00'
		if (@cLMinimo is Null) 
			SET @cLMinimo = '0000'
		if (@cLMaximo is Null) 
			SET @cLMaximo = '0000'
		if (@cQtdAtual is Null) 
			SET @cQtdAtual = '0000'

		SET @cBuf = @cTipo + @cLocal + 
					@ctipobio + @cPlanta + 
					@cRastr + @cIniHA + @cFimHA + @cValidR + @cValidSMax + @cTolAntes + @cTolApos + @cLeitSm + 
					@cPosVPlaca + @cPosMensBloq + @cValDiasSuc + @cParidRep + @cQtdMult +
					@cLMinimo + @cLMaximo + @cQtdAtual
		
		/*
		SET @cBuf = @cTipo + @cLocal + COALESCE(@cAdBuf, '') + 
					@ctipobio + @cPlanta + COALESCE(@cAdBuf, '') + 
					@cRastr + @cIniHA + @cFimHA + @cValidR + @cValidSMax + @cTolAntes + @cTolApos + @cLeitSm + 
					@cPosVPlaca + @cPosMensBloq + @cValDiasSuc + @cParidRep + @cQtdMult +
					@cLMinimo + @cLMaximo + @cQtdAtual
		
		*/
		SET @ret = 1

		IF (@cData != '000000')
		BEGIN
			-- verifica se data e´de Feriado
			IF EXISTS (SELECT DESC_FER FROM FERIADO (NOLOCK)
			   WHERE ((DATA_FER = @DataAux) and
					  (CONVERT(int, PLANTA_FER) = CONVERT(int, @cPlanta) or PLANTA_FER is null or CONVERT(int, PLANTA_FER) = 0)))
			BEGIN
				SET @ret = 2
			END
		END
	END

--	SET LOCK_TIMEOUT -1		

	SELECT @ret, @cBuf, @nTamG
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.CONTDIG_SAGEM_TBTEMPL'))
  DROP TRIGGER TELESSVR.CONTDIG_SAGEM_TBTEMPL
GO
 
CREATE TRIGGER TELESSVR.CONTDIG_SAGEM_TBTEMPL ON TELESSVR.CONTDIG_SAGEM FOR INSERT, UPDATE
AS

BEGIN
--VERSION_CONTROL 1.0.4.0 VERSION_CONTROL
  
  DECLARE @L_ICARD CHAR(12)
  DECLARE @L_TITULAR VARCHAR(MAX)
  DECLARE @L_ALTERNATIVO VARCHAR(MAX)
  DECLARE @L_STATUS CHAR(1)
  DECLARE @L_IDPESSOA NUMERIC(9,0)  
  
  IF UPPER( CURRENT_USER ) = 'SURICATO'
    RETURN;
  

  DECLARE cCONTDIG_SAGEM_TBTEMPL CURSOR
    FOR SELECT 
            ICARD, 
            TEMPL_TIT1 + TEMPL_TIT2 + TEMPL_TIT3 + TEMPL_TIT4,
            TEMPL_ALT1 + TEMPL_ALT2 + TEMPL_ALT3 + TEMPL_ALT4,
			STATUS
          FROM INSERTED

  OPEN CCONTDIG_SAGEM_TBTEMPL

  FETCH NEXT FROM CCONTDIG_SAGEM_TBTEMPL INTO @L_ICARD, @L_TITULAR, @L_ALTERNATIVO, @L_STATUS

  WHILE @@FETCH_STATUS = 0
  BEGIN

    SELECT @L_IDPESSOA = SURICATO.GETIDPESSOA( @L_ICARD )
    
    IF @L_IDPESSOA > 0
    BEGIN
    
      IF EXISTS ( SELECT 1 FROM SURICATO.TBTEMPL WHERE IDPESSOA = @L_IDPESSOA AND TIPOBIOM = '6')
      BEGIN
        UPDATE SURICATO.TBTEMPL SET TEMPTITU = @L_TITULAR, TEMPALTE = @L_ALTERNATIVO WHERE IDPESSOA = @L_IDPESSOA AND TIPOBIOM = '6'
      END
      ELSE
      BEGIN
        INSERT INTO SURICATO.TBTEMPL( IDPESSOA, TEMPTITU, QUALTEMPTITU, TEMPALTE, QUALTEMPALTE, TIPOBIOM, STATUS ) SELECT @L_IDPESSOA, @L_TITULAR, 0, @L_ALTERNATIVO, 0, '6', 1
      END
    
    END 

    FETCH NEXT FROM CCONTDIG_SAGEM_TBTEMPL INTO @L_ICARD, @L_TITULAR, @L_ALTERNATIVO, @L_STATUS

  END
  
  CLOSE CCONTDIG_SAGEM_TBTEMPL
 
  DEALLOCATE CCONTDIG_SAGEM_TBTEMPL	
	
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.CONTDIG_TSI1_TBTEMPL'))
  DROP TRIGGER TELESSVR.CONTDIG_TSI1_TBTEMPL
GO
 
CREATE TRIGGER TELESSVR.CONTDIG_TSI1_TBTEMPL ON TELESSVR.CONTDIG_TSI1 FOR INSERT, UPDATE
AS

BEGIN
--VERSION_CONTROL 1.0.4.0 VERSION_CONTROL
  
  DECLARE @L_ICARD CHAR(12)
  DECLARE @L_TITULAR VARCHAR(MAX)
  DECLARE @L_ALTERNATIVO VARCHAR(MAX)
  DECLARE @L_STATUS CHAR(1)
  DECLARE @L_IDPESSOA NUMERIC(9,0)  
  
  IF UPPER( CURRENT_USER ) = 'SURICATO'
    RETURN;  


  DECLARE CCONTDIG_TSI1_TBTEMPL CURSOR
    FOR SELECT 
            ICARD, 
            TEMPL_TIT1 + TEMPL_TIT2 + TEMPL_TIT3 + TEMPL_TIT4 + TEMPL_TIT5,
            TEMPL_ALT1 + TEMPL_ALT2 + TEMPL_ALT3 + TEMPL_ALT4 + TEMPL_ALT5,
			STATUS
          FROM INSERTED

  OPEN CCONTDIG_TSI1_TBTEMPL

  FETCH NEXT FROM CCONTDIG_TSI1_TBTEMPL INTO @L_ICARD, @L_TITULAR, @L_ALTERNATIVO, @L_STATUS

  WHILE @@FETCH_STATUS = 0
  BEGIN

    SELECT @L_IDPESSOA = SURICATO.GETIDPESSOA( @L_ICARD )
    
    IF @L_IDPESSOA > 0
    BEGIN
    
      IF EXISTS ( SELECT 1 FROM SURICATO.TBTEMPL WHERE IDPESSOA = @L_IDPESSOA AND TIPOBIOM = '8' )
      BEGIN
        UPDATE SURICATO.TBTEMPL SET TEMPTITU = @L_TITULAR, TEMPALTE = @L_ALTERNATIVO WHERE IDPESSOA = @L_IDPESSOA AND TIPOBIOM = '8'
      END
      ELSE
      BEGIN
        INSERT INTO SURICATO.TBTEMPL( IDPESSOA, TEMPTITU, QUALTEMPTITU, TEMPALTE, QUALTEMPALTE, TIPOBIOM, STATUS ) SELECT @L_IDPESSOA, @L_TITULAR, 0, @L_ALTERNATIVO, 0, '8', 1
      END
    
    END

    FETCH NEXT FROM CCONTDIG_TSI1_TBTEMPL INTO @L_ICARD, @L_TITULAR, @L_ALTERNATIVO, @L_STATUS

  END
	
  CLOSE CCONTDIG_TSI1_TBTEMPL
  
  DEALLOCATE CCONTDIG_TSI1_TBTEMPL
  
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.PALMV001_TBTEMPL'))
  DROP TRIGGER TELESSVR.PALMV001_TBTEMPL
GO
 
CREATE TRIGGER TELESSVR.PALMV001_TBTEMPL ON TELESSVR.PALMV001 FOR INSERT, UPDATE
AS

BEGIN
--VERSION_CONTROL 1.0.4.0 VERSION_CONTROL

  DECLARE @L_ICARD CHAR(12)
  DECLARE @L_TITULAR VARBINARY(MAX)
  DECLARE @L_ALTERNATIVO VARBINARY(MAX)
  DECLARE @L_STATUS CHAR(1)
  DECLARE @L_IDPESSOA NUMERIC(9,0)

  IF UPPER( CURRENT_USER ) = 'SURICATO'
    RETURN;

  DECLARE CPALM_TBTEMPL CURSOR
    FOR SELECT 
            ICARD, 
			TEMPL_PAD, 
			TEMPL_ALT, 
			ST
          FROM INSERTED

  OPEN CPALM_TBTEMPL

  FETCH NEXT FROM CPALM_TBTEMPL INTO @L_ICARD, @L_TITULAR, @L_ALTERNATIVO, @L_STATUS

  WHILE @@FETCH_STATUS = 0
  BEGIN
  
    SELECT @L_IDPESSOA = SURICATO.GETIDPESSOA( @L_ICARD )
    
    IF @L_IDPESSOA > 0
    BEGIN
    
      IF EXISTS ( SELECT 1 FROM SURICATO.TBTEMPL WHERE IDPESSOA = @L_IDPESSOA AND TIPOBIOM = 'A' )
      BEGIN
        UPDATE SURICATO.TBTEMPL SET TEMPTITU1 = @L_TITULAR, TEMPALTE1 = @L_ALTERNATIVO WHERE IDPESSOA = @L_IDPESSOA AND TIPOBIOM = 'A'
      END
      ELSE
      BEGIN
        INSERT INTO SURICATO.TBTEMPL( IDPESSOA, TEMPTITU1, QUALTEMPTITU, TEMPALTE1, QUALTEMPALTE, TIPOBIOM, STATUS ) SELECT @L_IDPESSOA, @L_TITULAR, 0,@L_ALTERNATIVO, 0, 'A', 1
      END
      
    END

    FETCH NEXT FROM CPALM_TBTEMPL INTO @L_ICARD, @L_TITULAR, @L_ALTERNATIVO, @L_STATUS

  END
	
  CLOSE CPALM_TBTEMPL
	
  DEALLOCATE CPALM_TBTEMPL
  
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.SQLRNIVEL_BIOMET'))
  DROP PROCEDURE TELESSVR.SQLRNIVEL_BIOMET
GO

CREATE PROCEDURE TELESSVR.SQLRNIVEL_BIOMET @cEndIp CHAR(15), @cBlueb CHAR(2), @cCodin CHAR(2) AS

DECLARE @cBioTipo AS CHAR(1)

DECLARE @Retfun SMALLINT, @Pad int, @Alt int, @cNivel char(2)

	set @cBioTipo = '0'
	set @cNivel = '2'

	IF EXISTS (SELECT * FROM DAT07 WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
	begin
	   	SELECT @cBioTipo = BIO_TIPO 
		FROM DAT07
		WHERE END_IP = @cEndIp and 
			  BLUEB = @cBlueb and 
			  CODIN = @cCodin

		IF ((@cBioTipo = '4') or (@cBioTipo = '5')) begin
			IF EXISTS (SELECT *	FROM GEOMOK001 
						WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
				SELECT @cNivel = NIVEL
					FROM GEOMOK001
					WHERE END_IP = @cEndIp and 
						  BLUEB = @cBlueb and 
						  CODIN = @cCodin
			ELSE
				SET @cNivel = '4'
			end
		ELSE begin 
			IF ((@cBioTipo = '6') or (@cBioTipo = '7') or (@cBioTipo = '9')) begin
				IF EXISTS (SELECT *	FROM GEOMOK001 
							WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
					SELECT @cNivel = NIVELSAG
						FROM GEOMOK001
						WHERE END_IP = @cEndIp and 
							  BLUEB = @cBlueb and 
							  CODIN = @cCodin
				ELSE
					SET @cNivel = '5'
			end
			ELSE begin
				IF (@cBioTipo = '8') begin
					IF EXISTS (SELECT *	FROM GEOMOK001 
								WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
						SELECT @cNivel = NIVEL
							FROM GEOMOK001
							WHERE END_IP = @cEndIp and 
								  BLUEB = @cBlueb and 
								  CODIN = @cCodin
					ELSE
						SET @cNivel = '3'
				end
			end
		end
	end
	
	SET @Retfun = convert(int, @cNivel)
		
	SELECT @cBioTipo, @Retfun
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

-----------------------------------------------------------------------------
-- 2.10.7.0 || 2.10.7.0 || 2.10.7.0 || 2.10.7.0 || 2.10.7.0 || 2.10.7.0 || --
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Create date:		19/08/2019 - 17:42
-- Changed:			21/08/2019 - 09:38
-- Sequence:		0027
-- Redmine: 		@3585
-----------------------------------------------------------------------------

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'CONTDIG_OUTROS')
	BEGIN
		CREATE TABLE TELESSVR.CONTDIG_OUTROS (
			ICARD           CHAR(12) NOT NULL,
			BIO_TIPO        CHAR(1) NOT NULL CONSTRAINT digoutros_TPDIG CHECK (BIO_TIPO IN ('9','C','D','E')),
			DIGITAL_PAD     VARCHAR(MAX),
			DIGITAL_ALT     VARCHAR(MAX),
			DIGITAL_COA     VARCHAR(MAX),
			STATUS          CHAR(1) DEFAULT '0',
			STATUS_REP      CHAR(1) DEFAULT '0'
		)
		CREATE UNIQUE INDEX CONTDIG_OUTROS_IND1 ON TELESSVR.CONTDIG_OUTROS (ICARD, BIO_TIPO)
		CREATE INDEX CONTDIG_OUTROS_IND2 ON TELESSVR.CONTDIG_OUTROS (STATUS_REP)
		CREATE INDEX CONTDIG_OUTROS_IND3 ON TELESSVR.CONTDIG_OUTROS (STATUS)
	END
GO

/*
{ 
  "database"    : "MSSQL",
  "owner"       : "TELESSVR",
  "type"        : "TRIGGER",
  "name"        : "CONTDIG_OUTROS_TBTEMPL",
  "description" : "TRIGGER DE ATUALIZAÇÃO E INCLUSÃO NA CONTDIG_OUTROS",
  "version"     : "1.0.4.0",
  "log"         : {
                   "1.0.4.0" : { "author" : "Alex Siqueira", "created" : "04/06/2019", "issue" : "Melhoria @3585", "description" : "Suporte ao Sensor Biométrico VIRDI"}
                  }
}
*/

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID('TELESSVR.CONTDIG_OUTROS_TBTEMPL'))
  DROP TRIGGER TELESSVR.CONTDIG_OUTROS_TBTEMPL
GO


CREATE TRIGGER TELESSVR.CONTDIG_OUTROS_TBTEMPL ON TELESSVR.CONTDIG_OUTROS FOR INSERT, UPDATE
AS

BEGIN
--VERSION_CONTROL 1.0.4.0 VERSION_CONTROL

  DECLARE @L_ICARD CHAR(12)
  DECLARE @L_TITULAR VARCHAR(MAX)
  DECLARE @L_ALTERNATIVO VARCHAR(MAX)
  DECLARE @L_IDPESSOA NUMERIC(9,0)
  DECLARE @L_BIO_TIPO CHAR(1)


  IF UPPER( CURRENT_USER ) = 'SURICATO'
    RETURN;


  DECLARE CCONTDIG_OUTROS_TBTEMPL CURSOR
    FOR SELECT 
            ICARD, 
			DIGITAL_PAD, 
			DIGITAL_ALT, 
			BIO_TIPO
          FROM INSERTED

  OPEN CCONTDIG_OUTROS_TBTEMPL

  FETCH NEXT FROM CCONTDIG_OUTROS_TBTEMPL INTO @L_ICARD, @L_TITULAR, @L_ALTERNATIVO, @L_BIO_TIPO

  WHILE @@FETCH_STATUS = 0
  BEGIN
  
    SELECT @L_IDPESSOA = SURICATO.GETIDPESSOA( @L_ICARD )
    
    IF @L_IDPESSOA > 0
    BEGIN
    
      IF EXISTS ( SELECT 1 FROM SURICATO.TBTEMPL WHERE IDPESSOA = @L_IDPESSOA AND TIPOBIOM = @L_BIO_TIPO )
      BEGIN
        UPDATE SURICATO.TBTEMPL SET TEMPTITU = @L_TITULAR, TEMPALTE = @L_ALTERNATIVO WHERE IDPESSOA = @L_IDPESSOA AND TIPOBIOM = @L_BIO_TIPO
      END
      ELSE
      BEGIN
        INSERT INTO SURICATO.TBTEMPL( IDPESSOA, TEMPTITU, QUALTEMPTITU, TEMPALTE, QUALTEMPALTE, TIPOBIOM, STATUS ) SELECT @L_IDPESSOA, @L_TITULAR, 0,@L_ALTERNATIVO, 0, @L_BIO_TIPO, 1
      END
      
    END

    FETCH NEXT FROM CCONTDIG_OUTROS_TBTEMPL INTO @L_ICARD, @L_TITULAR, @L_ALTERNATIVO, @L_BIO_TIPO

  END
	
  CLOSE CCONTDIG_OUTROS_TBTEMPL
	
  DEALLOCATE CCONTDIG_OUTROS_TBTEMPL  

END
GO

-----------------------------------------------------------------------------
-- CONEX REP V.07.01.01 || CONEX REP V.07.01.01 || CONEX REP V.07.01.01 || --
-----------------------------------------------------------------------------

IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'REPDIGLOAD001' AND UPPER(COLUMN_NAME) = 'NERRO')
	ALTER TABLE TELESSVR.REPDIGLOAD001 ADD NERRO CHAR(1) DEFAULT '0';
GO

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'REPAUTOBIOF')
	BEGIN
		CREATE TABLE TELESSVR.REPAUTOBIOF	
		(
			END_IP CHAR(15)	NOT NULL ,
			INICIO_GERBIO	CHAR(8)     default '00:00:00' NOT NULL ,
			FINAL_GERBIO 	CHAR(8)     default '00:00:00' NOT NULL ,			
			INICIO_GERFUN	CHAR(8)     default '00:00:00' NOT NULL ,
			FINAL_GERFUN 	CHAR(8)     default '00:00:00' NOT NULL 		
		)
		CREATE UNIQUE INDEX REPAUTOBIOF_IND1 ON TELESSVR.REPAUTOBIOF (END_IP)
	END
GO

IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'REPNDIGAUTO000' AND UPPER(COLUMN_NAME) = 'BIO_TIPO')
	ALTER TABLE TELESSVR.REPNDIGAUTO000 ADD BIO_TIPO CHAR(1) DEFAULT '0' NOT NULL;
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'REPNDIGAUTO000_IND1')
    DROP INDEX TELESSVR.REPNDIGAUTO000.REPNDIGAUTO000_IND1
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'REPNDIGAUTO000_IND1A')
    CREATE UNIQUE INDEX REPNDIGAUTO000_IND1A ON TELESSVR.REPNDIGAUTO000 (IFUNC, GRUPO, BIO_TIPO);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'REPNDIGAUTO000_IND3A')
    CREATE UNIQUE INDEX REPNDIGAUTO000_IND3A ON TELESSVR.REPNDIGAUTO000 (IFUNC, BIO_TIPO, GRUPO);
GO

IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'TMP_TD' AND UPPER(COLUMN_NAME) = 'BIO_TIPO')
	ALTER TABLE TELESSVR.TMP_TD ADD BIO_TIPO CHAR(1) DEFAULT '0';
GO

IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'TMP_NREPDIGGRP' AND UPPER(COLUMN_NAME) = 'BIO_TIPO')
	ALTER TABLE TELESSVR.TMP_NREPDIGGRP ADD BIO_TIPO CHAR(1) DEFAULT '0';
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'TMP_NREPDIGGRP')
    DROP INDEX TELESSVR.TMP_NREPDIGGRP.TMP_NREPDIGGRP_IND1;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'TMP_NREPDIGGRP_IND1')
    CREATE INDEX TMP_NREPDIGGRP_IND1 ON TELESSVR.TMP_NREPDIGGRP (IFUNC, STATUS, BIO_TIPO, GRUPO);
GO

IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'TMP_NREPDIGOUTROS' AND UPPER(COLUMN_NAME) = 'BIO_TIPO')
	ALTER TABLE TELESSVR.TMP_NREPDIGOUTROS ADD BIO_TIPO CHAR(1) DEFAULT '0'
GO

IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'TMP_NREPDIGATV' AND UPPER(COLUMN_NAME) = 'BIO_TIPO')
	ALTER TABLE TELESSVR.TMP_NREPDIGATV ADD BIO_TIPO CHAR(1) DEFAULT '0';
GO

IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'TMP_REPVRD001' AND UPPER(COLUMN_NAME) = 'BIO_TIPO')
	ALTER TABLE TELESSVR.TMP_REPVRD001 ADD BIO_TIPO CHAR(1) DEFAULT '0';
GO

IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'TMP_REPVRD002' AND UPPER(COLUMN_NAME) = 'BIO_TIPO')
	ALTER TABLE TELESSVR.TMP_REPVRD002 ADD BIO_TIPO CHAR(1) DEFAULT '0';
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG004_IND1')
    DROP INDEX TELESSVR.RDIG004.RDIG004_IND1;
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG004_IND2')
    DROP INDEX TELESSVR.RDIG004.RDIG004_IND2;
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG004_IND4')
    DROP INDEX TELESSVR.RDIG004.RDIG004_IND4;
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG004_IND5')
    DROP INDEX TELESSVR.RDIG004.RDIG004_IND5;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG004_IND1')
    CREATE UNIQUE INDEX RDIG004_IND1 ON TELESSVR.RDIG004 (IFUNC,BIO_TIPO,END_IP);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG004_IND2')
    CREATE UNIQUE INDEX RDIG004_IND2 ON TELESSVR.RDIG004 (END_IP, IFUNC, STATUS);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG004_IND4')
    CREATE INDEX RDIG004_IND4 ON TELESSVR.RDIG004 (END_IP, STATUS, BIO_TIPO);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG004_IND5')
    CREATE INDEX RDIG004_IND5 ON TELESSVR.RDIG004 (IFUNC, STATUS, BIO_TIPO);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG104_IND1')
    DROP INDEX TELESSVR.RDIG104.RDIG104_IND1;
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG104_IND2')
    DROP INDEX TELESSVR.RDIG104.RDIG104_IND2;
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG104_IND4')
    DROP INDEX TELESSVR.RDIG104.RDIG104_IND4;
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG104_IND5')
    DROP INDEX TELESSVR.RDIG104.RDIG104_IND5;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG104_IND1')
    CREATE UNIQUE INDEX RDIG104_IND1 ON TELESSVR.RDIG104 (IFUNC,BIO_TIPO,END_IP);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG104_IND2')
    CREATE UNIQUE INDEX RDIG104_IND2 ON TELESSVR.RDIG104 (END_IP, IFUNC, STATUS);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG104_IND4')
    CREATE INDEX RDIG104_IND4 ON TELESSVR.RDIG104 (END_IP, STATUS, BIO_TIPO);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'RDIG104_IND5')
    CREATE INDEX RDIG104_IND5 ON TELESSVR.RDIG104 (IFUNC, STATUS, BIO_TIPO);
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('Auxtrg_repDig2'))
	DROP PROCEDURE TELESSVR.Auxtrg_repDig2;
GO

CREATE PROCEDURE TELESSVR.Auxtrg_repDig2 @cFunc char(12), @cStatus char(1), @cBioTipo char(1)
AS

DECLARE @cAux CHAR(1), @cVelhoStat CHAR(1), @cNovoStatus CHAR(1), @dDataAux DATETIME, @cGrupo char(5)

BEGIN

	-- VERIFICA SE EXISTE DIGITAL PARA A MATRICULA
	IF (@cStatus = '1') or (@cStatus = '3') begin 		-- FUNCIONÁRIO FOI INSERIDO NA TAB.REPEMPR002
		SET @cNovoStatus = '3'
		SET @cVelhoStat  = '8'
	end
	ELSE begin								-- FUNCIONÁRIO FOI EXCLUIDO DA TAB.REPEMPR002 
		SET @cNovoStatus = '8'
		SET @cVelhoStat  = '3'
	end

	DECLARE cur_DigRep000 CURSOR FOR (select GRUPO from REPGRPF WHERE IFUNC = @cFunc)
	OPEN cur_DigRep000
	FETCH NEXT FROM cur_DigRep000 INTO @cGrupo

	WHILE @@fetch_status != -1
	BEGIN          
		-- procura em REPNDIGAUTO000 se o Funcionario x Grupo que está excluindo já está em tabela 
		-- Se estiver presente , nada faz

		SET @cAux = null
		SET @cAux = 
			(SELECT STATUS FROM REPNDIGAUTO000 
				WHERE REPNDIGAUTO000.IFUNC = @cFunc and 
					  REPNDIGAUTO000.BIO_TIPO = @cBioTipo and 
					  CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@cGrupo AS INT) )

		IF (@cAux is null) BEGIN
			-- este (funcionario x grupo) nao sofreu nenhuma inclusao ou exclusao, então insere na tabela REPNDIGAUTO000 
			-- A data/hora (DATA_INS) ´será atualizada com a dta corrente		
			INSERT INTO REPNDIGAUTO000 (IFUNC, STATUS, GRUPO, BIO_TIPO) 
						VALUES 		(@cFunc, @cNovoStatus, @cGrupo, @cBioTipo)
		END
		ELSE BEGIN
			-- verifica se está na tabela para ainda ser processado para INCLUSAO OU EXCLUSAO OU SE JÁ SOFREU O PROCESSAMENTO
			IF (@cAux = @cVelhoStat OR @cAux = '0') BEGIN
				-- como está para ser incluido (ou excluido), altera para status de exclusao (ou inclusao), atualizando a data
				UPDATE REPNDIGAUTO000 SET STATUS = @cNovoStatus , DATA_INS = getdate() 
					WHERE REPNDIGAUTO000.IFUNC = @cFunc and 
						REPNDIGAUTO000.BIO_TIPO = @cBioTipo and 
						CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@cGrupo AS INT)
			END
		END
		FETCH NEXT FROM cur_DigRep000 INTO @cGrupo
	END
	
	CLOSE cur_DigRep000
	DEALLOCATE cur_DigRep000
END
GO

-- ESTA TRIGGER é executada antes de DELETE DA TAB. REPEMPR002
-- INSERIRÁ NA TAB.REPNAUTO000, A MATRICULA COM OS GRUPOS AOS QUAIS PERTENCEM, COM STATUS DE EXCLUSÃO('8')
-- INSERIRÁ NA TAB.REPNDIGAUTO000, A MATRICULA COM OS GRUPOS AOS QUAIS PERTENCEM, COM STATUS DE EXCLUSÃO('8')
IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('TRGREPFUN_D'))
	DROP TRIGGER TELESSVR.TRGREPFUN_D;
GO

CREATE TRIGGER TELESSVR.TRGREPFUN_D ON TELESSVR.REPEMPR002 FOR DELETE
AS
DECLARE @VelhoFunc CHAR(12)
          
	SET @VelhoFunc = (SELECT IFUNC FROM DELETED)   
	
	-- ESTA TRIGGER INSERIRA´EM TAB.REPNAUTO000, OS GRUPOS QUE A MATRICULA FAZ PARTE, PARA QUE DOS EQUIPTOS DESTE GRUPO SEJA RETIRADA A MATRICULA
	exec TELESSVR.Auxtrg_repFunc @VelhoFunc, '8';

	-- ESTA TRIGGER INSERIRA´EM TAB.REPNDIGAUTO000, OS GRUPOS QUE A MATRICULA FAZ PARTE, PARA QUE DOS EQUIPTOS DESTE GRUPO SEJA RETIRADA A MATRICULA
	exec TELESSVR.Auxtrg_repDig2 @VelhoFunc, '8', '0';
	
GO

-- ESTA TRIGGER é executada quando (INSERT) DA TAB. REPEMPR002
-- INSERIRÁ NA TAB.REPNAUTO000, A MATRICULA COM OS GRUPOS AOS QUAIS PERTENCEM, COM STATUS DE INCLUSÃO('3') 
-- INSERIRÁ NA TAB.REPNDIGAUTO000, A MATRICULA COM OS GRUPOS AOS QUAIS PERTENCEM, COM STATUS DE INCLUSÃO('3') 

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'TRGREPFUN_I')
	DROP TRIGGER TELESSVR.TRGREPFUN_I;
GO

CREATE TRIGGER TELESSVR.TRGREPFUN_I ON TELESSVR.REPEMPR002 FOR INSERT
AS
DECLARE @NovoFunc CHAR(12)
          
	SET @NovoFunc = (SELECT IFUNC FROM INSERTED)   
	

	-- ESTA TRIGGER INSERIRA´EM TAB.REPNAUTO000, OS GRUPOS QUE A MATRICULA FAZ PARTE, PARA QUE NOS EQUIPTOS DESTE GRUPO SEJA INCLUIDA A MATRICULA
	exec TELESSVR.Auxtrg_repFunc @NovoFunc, '3';


	-- ESTA TRIGGER INSERIRA´EM TAB.REPNDIGAUTO000, OS GRUPOS QUE A MATRICULA FAZ PARTE, PARA QUE NOS EQUIPTOS DESTE GRUPO SEJA INCLUIDA A DIGITAL DA MATRICULA
	exec TELESSVR.Auxtrg_repDig2 @NovoFunc, '3', '0';
	
GO

-- ESTA TRIGGER SERÁ EXECUTADO QUANDO DELETE NA TABELA REPGRPF 
-- (EX: EXCLUSĂO DE GRUPO PARA O FUNCIONARIO)

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'TRGREPGRP_D')
	DROP TRIGGER TELESSVR.TRGREPGRP_D;
GO

CREATE TRIGGER TELESSVR.TRGREPGRP_D ON TELESSVR.REPGRPF FOR DELETE
AS
DECLARE @VelhoFunc CHAR(12)
DECLARE @VelhoGrupo CHAR(5)
DECLARE @cAux VARCHAR(1)

	-- PARA CARGA AUTOMATICA DE FUNCIONARIOS          
	DECLARE cur_auto003 CURSOR FOR (select IFUNC, GRUPO from DELETED)
	OPEN cur_auto003
	FETCH NEXT FROM cur_auto003 INTO @VelhoFunc, @VelhoGrupo
          
	WHILE @@fetch_status != -1
	BEGIN          
		-- procura em REPNAUTO000 se o Funcionario x GrupoVelho que está excluindo já está em tabela 
		-- Se estiver presente , nada faz

		SET @cAux = null
		SET @cAux = 
			(SELECT STATUS FROM REPNAUTO000 
				WHERE REPNAUTO000.IFUNC = @VelhoFunc and 
					  CAST(REPNAUTO000.GRUPO AS INT) = CAST(@VelhoGrupo AS INT) )

		IF (@cAux is null) BEGIN
			-- este (funcionario x grupo) nao sofreu nenhuma inclusao ou exclusao, entăo insere na tabela REPNAUTO000 como Exclusao. 
			-- A data/hora (DATA_INS) ´será atualizada com a dta corrente		
			INSERT INTO REPNAUTO000 (IFUNC, STATUS, GRUPO) 
						VALUES 		(@VelhoFunc, '8', @VelhoGrupo)
		END
		ELSE BEGIN
			-- verifica se (funcionario x grupo) está na tabela para ainda ser processado para inclusao ou já incluido
			IF (@cAux = '3' OR @cAux = '0') BEGIN
				-- como está para ser incluido, altera para status de exclusao, atualizando a data
				UPDATE REPNAUTO000 SET STATUS = '8' , DATA_INS = getdate() 
					WHERE REPNAUTO000.IFUNC = @VelhoFunc and 
						  CAST(REPNAUTO000.GRUPO AS INT) = CAST(@VelhoGrupo AS INT)
			END
		END
		FETCH NEXT FROM cur_auto003 INTO @VelhoFunc, @VelhoGrupo
	END
	CLOSE cur_auto003


	-- PARA CARGA AUTOMATICA DE DIGITAIS 
	OPEN cur_auto003
	FETCH NEXT FROM cur_auto003 INTO @VelhoFunc, @VelhoGrupo
          
	WHILE @@fetch_status != -1
	BEGIN          
		-- procura em REPNDIGAUTO000 se o Funcionario x GrupoVelho que está excluindo já está em tabela 
		-- Se estiver presente , nada faz

		SET @cAux = null
		SET @cAux = 
			(SELECT STATUS FROM REPNDIGAUTO000 
				WHERE REPNDIGAUTO000.IFUNC = @VelhoFunc and 
					REPNDIGAUTO000.BIO_TIPO = '0' and 
					CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@VelhoGrupo AS INT) )

		IF (@cAux is null) BEGIN
			-- este (funcionario x grupo) nao sofreu nenhuma inclusao ou exclusao, entăo insere na tabela REPNDIGAUTO000 como Exclusao. 
			-- A data/hora (DATA_INS) ´será atualizada com a dta corrente		
			INSERT INTO REPNDIGAUTO000 (IFUNC, STATUS, GRUPO, BIO_TIPO) 
						VALUES 		(@VelhoFunc, '8', @VelhoGrupo, '0')
		END
		ELSE BEGIN
			-- verifica se (funcionario x grupo) está na tabela para ainda ser processado para inclusao ou já incluido
			IF (@cAux = '3' OR @cAux = '0') BEGIN
				-- como está para ser incluido, altera para status de exclusao, atualizando a data
				UPDATE REPNDIGAUTO000 SET STATUS = '8' , DATA_INS = getdate() 
					WHERE REPNDIGAUTO000.IFUNC = @VelhoFunc and 
						REPNDIGAUTO000.BIO_TIPO = '0' and
						CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@VelhoGrupo AS INT)
			END
		END
		FETCH NEXT FROM cur_auto003 INTO @VelhoFunc, @VelhoGrupo
	END
	
	CLOSE cur_auto003
	DEALLOCATE cur_auto003

GO

-- ESTA TRIGGER SERÁ EXECUTADO QUANDO INSERT NA TABELA REPGRPF 
-- (EX: INCLUSAO DE NOVO GRUPO PARA O FUNCIONARIO)

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'TRGREPGRP_I')
	DROP TRIGGER TELESSVR.TRGREPGRP_I;
GO

CREATE TRIGGER TELESSVR.TRGREPGRP_I ON TELESSVR.REPGRPF FOR INSERT
AS
DECLARE @NovoFunc CHAR(12)
DECLARE @NovoGrupo CHAR(5)
DECLARE @cAux VARCHAR(1)
          
	SET @NovoFunc = (SELECT IFUNC FROM INSERTED)   
	SET @NovoGrupo = (SELECT GRUPO FROM INSERTED)   


	-- PARA CARGA FUNCIONARIOS --------------------------------------------------------------
	-- procura em REPNAUTO000 se o Funcionario x Grupo que está INSERINDO já está em tabela 
	-- Se estiver presente , nada faz
	SET @cAux = null
	SET @cAux = (SELECT STATUS FROM REPNAUTO000 
						WHERE REPNAUTO000.IFUNC = @NovoFunc and 
						CAST(REPNAUTO000.GRUPO AS INT) = CAST(@NovoGrupo AS INT) )

	IF (@cAux is null) BEGIN

		-- este (funcionario x grupo) nao sofreu nenhuma inclusao ou exclusao, entăo insere na tabela REPNAUTO000 como Inclusao. 
		-- A data/hora (DATA_INS) ´será atualizada com a dta corrente
		INSERT INTO REPNAUTO000 (IFUNC, STATUS, GRUPO) VALUES 
									(@NovoFunc, '3', @NovoGrupo)
	END
	ELSE BEGIN
		IF (@cAux = '8' OR @cAux = '0') BEGIN
			-- como está para ser excluido, altera para status de inclusao, atualizando a data
			UPDATE REPNAUTO000 SET STATUS = '3' , DATA_INS = getdate() 
					WHERE REPNAUTO000.IFUNC = @NovoFunc and 
					CAST(REPNAUTO000.GRUPO AS INT) = CAST(@NovoGrupo AS INT)
		END
	END


	-- PARA CARGA DIGITAIS --------------------------------------------------------------
	-- procura em REPNDIGAUTO000 se o Funcionario x Grupo que está INSERINDO já está em tabela 
	-- Se estiver presente , nada faz
	SET @cAux = null
	SET @cAux = (SELECT STATUS FROM REPNDIGAUTO000 
						WHERE REPNDIGAUTO000.IFUNC = @NovoFunc and 
							REPNDIGAUTO000.BIO_TIPO = '0' and 
							CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@NovoGrupo AS INT) )

	IF (@cAux is null) BEGIN

		-- este (funcionario x grupo) nao sofreu nenhuma inclusao ou exclusao, entăo insere na tabela REPNDIGAUTO000 como Inclusao. 
		-- A data/hora (DATA_INS) ´será atualizada com a dta corrente
		INSERT INTO REPNDIGAUTO000 (IFUNC, STATUS, GRUPO, BIO_TIPO) VALUES 
									(@NovoFunc, '3', @NovoGrupo, '0')
	END
	ELSE BEGIN
		IF (@cAux = '8' OR @cAux = '0') BEGIN
			-- como está para ser excluido, altera para status de inclusao, atualizando a data
			UPDATE REPNDIGAUTO000 SET STATUS = '3' , DATA_INS = getdate() 
					WHERE REPNDIGAUTO000.IFUNC = @NovoFunc and 
						REPNDIGAUTO000.BIO_TIPO = '0' and 
						CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@NovoGrupo AS INT)
		END
	END

GO

-- ESTA TRIGGER SERÁ EXECUTADO QUANDO UPDATE NA TABELA REPGRPF 
-- (EX: ALTERAÇĂO DO VALOR DO GRUPO PARA O FUNCIONARIO)

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'TRGREPGRP_U')
	DROP TRIGGER TELESSVR.TRGREPGRP_U;
GO

CREATE TRIGGER TELESSVR.TRGREPGRP_U ON TELESSVR.REPGRPF FOR UPDATE 
AS
DECLARE @Func CHAR(12)
DECLARE @VelhoGrupo CHAR(5)
DECLARE @NovoGrupo CHAR(5)
DECLARE @cAux VARCHAR(1)
DECLARE @cDataAux datetime
DECLARE @nCont int;
          
    --SET nCont = 0;
	DECLARE cur_auto004 CURSOR FOR (select A.IFUNC, A.GRUPO, B.GRUPO from DELETED A, INSERTED B)
	OPEN cur_auto004
	FETCH NEXT FROM cur_auto004 INTO @Func, @VelhoGrupo, @NovoGrupo
          
	WHILE @@fetch_status != -1
	BEGIN          
         
		IF UPDATE (GRUPO) BEGIN          

			-- ***************************************************************************************************************************************
			-- PARA CARGA DE FUNCIONARIOS
			-- *********************** analise grupo 'velho'  ***********************
			-- procura em REPNAUTO000 se o Funcionario x GrupoVelho que foi modificado já está em tabela para ser Excluido (status '8').
			-- Se estiver presente , nada faz
			
			SET @cAux = null
			SET @cAux = 
				(SELECT STATUS FROM REPNAUTO000 
					WHERE REPNAUTO000.IFUNC = @Func and 
						  CAST(REPNAUTO000.GRUPO AS INT) = CAST(@VelhoGrupo AS INT) and
						  REPNAUTO000.STATUS = '8'
						  )

			IF (@cAux is null) BEGIN
				-- nao encontrou Funcionario para ser excluido do grupo, verifica qual o status se estiver em tabela 
			
				SET @cAux = (SELECT STATUS FROM REPNAUTO000 
									WHERE REPNAUTO000.IFUNC = @Func and 
									CAST(REPNAUTO000.GRUPO AS INT) = CAST(@VelhoGrupo AS INT) )

				IF (@cAux is null) BEGIN
					-- esta matricula nao sofreu nenhuma inclusao ou exclusao, entăo insere na tabela REPNAUTO000 como Exclusao. 
					-- A data/hora (DATA_INS) ´será atualizada com a dta corrente
					INSERT INTO REPNAUTO000 (IFUNC, STATUS, GRUPO) VALUES 
												(@Func, '8', @VelhoGrupo)
				END
				ELSE BEGIN
					-- verifica se está na tabela para ainda ser processado para inclusao ou já incluido
					IF (@cAux = '3' OR @cAux = '0') BEGIN

						-- como está para ser incluido, altera para status de exclusao, atualizando a data
						UPDATE REPNAUTO000 SET STATUS = '8' , DATA_INS = getdate() 
								WHERE REPNAUTO000.IFUNC = @Func and 
								CAST(REPNAUTO000.GRUPO AS INT) = CAST(@VelhoGrupo AS INT)
					END
				END
			END		
		

			-- ***********************  analisa grupo 'novo'  ***********************
			-- procura em REPNAUTO000 se o Funcionario x GrupoNovo  já está em tabela para ser Incluido (status '3').
			-- Se estiver presente , nada faz

			SET @cAux = null
			SET @cAux = 
				(SELECT STATUS FROM REPNAUTO000 
					WHERE REPNAUTO000.IFUNC = @Func and 
						  CAST(REPNAUTO000.GRUPO AS INT) = CAST(@NovoGrupo AS INT) and
						  REPNAUTO000.STATUS = '3'
						  )

			IF (@cAux is null) BEGIN
				-- nao encontrou Funcionario para ser incluido no grupo, verifica qual o status se estiver em tabela 
			
				SET @cAux = (SELECT STATUS FROM REPNAUTO000 
									WHERE REPNAUTO000.IFUNC = @Func and 
									CAST(REPNAUTO000.GRUPO AS INT) = CAST(@NovoGrupo AS INT) )

				IF (@cAux is null) BEGIN

					-- este (funcionario x grupo) nao sofreu nenhuma inclusao ou exclusao, entăo insere na tabela REPNAUTO000 como Inclusao. 
					-- A data/hora (DATA_INS) ´será atualizada com a dta corrente
					INSERT INTO REPNAUTO000 (IFUNC, STATUS, GRUPO, DATA_INS) VALUES 
												(@Func, '3', @NovoGrupo, DATEADD(ss,1,getdate()) )

				END
				ELSE BEGIN
					-- verifica se está na tabela para ainda ser processado para exclusao ou já excluido
					IF (@cAux = '8' OR @cAux = '0') BEGIN
					
						-- como está para ser excluido, altera para status de inclusao, atualizando a data com 1 segundo a mais, pois primeiro exclui e depois insere no grpo novo
						--UPDATE REPNAUTO000 SET STATUS = '3' , DATA_INS = getdate() 
						UPDATE REPNAUTO000 SET STATUS = '3' , DATA_INS = DATEADD(ss,1,getdate() )
								WHERE REPNAUTO000.IFUNC = @Func and 
								CAST(REPNAUTO000.GRUPO AS INT) = CAST(@NovoGrupo AS INT)
					END
				END
			END		
			
			
			-- ***************************************************************************************************************************************
			-- PARA CARGA DE DIGITAIS AUTOMATICO
			-- *********************** analise grupo 'velho'  ***********************
			-- procura em REPNDIGAUTO000 se o Funcionario x GrupoVelho que foi modificado já está em tabela para ser Excluido (status '8').
			-- Se estiver presente , nada faz
			
			SET @cAux = null
			SET @cAux = 
				(SELECT STATUS FROM REPNDIGAUTO000 
					WHERE REPNDIGAUTO000.IFUNC = @Func and 
						REPNDIGAUTO000.BIO_TIPO = '0' and 
						CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@VelhoGrupo AS INT) and
						REPNDIGAUTO000.STATUS = '8'
						  )

			IF (@cAux is null) BEGIN
				-- nao encontrou Funcionario para ser excluido do grupo, verifica qual o status se estiver em tabela 
			
				SET @cAux = (SELECT STATUS FROM REPNDIGAUTO000 
								WHERE REPNDIGAUTO000.IFUNC = @Func and 
									REPNDIGAUTO000.BIO_TIPO = '0' and 									
									CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@VelhoGrupo AS INT) )

				IF (@cAux is null) BEGIN
					-- esta matricula nao sofreu nenhuma inclusao ou exclusao, entăo insere na tabela REPNDIGAUTO000 como Exclusao. 
					-- A data/hora (DATA_INS) ´será atualizada com a dta corrente
					INSERT INTO REPNDIGAUTO000 (IFUNC, STATUS, GRUPO, BIO_TIPO) VALUES 
												(@Func, '8', @VelhoGrupo, '0')
				END
				ELSE BEGIN
					-- verifica se está na tabela para ainda ser processado para inclusao ou já incluido
					IF (@cAux = '3' OR @cAux = '0') BEGIN

						-- como está para ser incluido, altera para status de exclusao, atualizando a data
						UPDATE REPNDIGAUTO000 SET STATUS = '8' , DATA_INS = getdate() 
							WHERE REPNDIGAUTO000.IFUNC = @Func and 
								REPNDIGAUTO000.BIO_TIPO = '0' and 
								CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@VelhoGrupo AS INT)
					END
				END
			END		
		

			-- ***********************  analisa grupo 'novo'  ***********************
			-- procura em REPNAUTO000 se o Funcionario x GrupoNovo  já está em tabela para ser Incluido (status '3').
			-- Se estiver presente , nada faz

			SET @cAux = null
			SET @cAux = 
				(SELECT STATUS FROM REPNDIGAUTO000 
					WHERE REPNDIGAUTO000.IFUNC = @Func and 
						REPNDIGAUTO000.BIO_TIPO = '0' and 
						CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@NovoGrupo AS INT) and
						REPNDIGAUTO000.STATUS = '3'
				)

			IF (@cAux is null) BEGIN
				-- nao encontrou Funcionario para ser incluido no grupo, verifica qual o status se estiver em tabela 
			
				SET @cAux = (SELECT STATUS FROM REPNDIGAUTO000 
								WHERE REPNDIGAUTO000.IFUNC = @Func and 
									REPNDIGAUTO000.BIO_TIPO = '0' and 						
									CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@NovoGrupo AS INT) )

				IF (@cAux is null) BEGIN

					-- este (funcionario x grupo) nao sofreu nenhuma inclusao ou exclusao, entăo insere na tabela REPNDIGAUTO000 como Inclusao. 
					-- A data/hora (DATA_INS) ´será atualizada com a dta corrente
					INSERT INTO REPNDIGAUTO000 (IFUNC, STATUS, GRUPO, BIO_TIPO, DATA_INS) VALUES 
												(@Func, '3', @NovoGrupo, '0', DATEADD(ss,1,getdate()) )

				END
				ELSE BEGIN
					-- verifica se está na tabela para ainda ser processado para exclusao ou já excluido
					IF (@cAux = '8' OR @cAux = '0') BEGIN
					
						-- como está para ser excluido, altera para status de inclusao, atualizando a data com 1 segundo a mais, pois primeiro exclui e depois insere no grpo novo
						UPDATE REPNDIGAUTO000 SET STATUS = '3' , DATA_INS = DATEADD(ss,1,getdate() )
							WHERE REPNDIGAUTO000.IFUNC = @Func and 
								REPNDIGAUTO000.BIO_TIPO = '0' and 
								CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@NovoGrupo AS INT)
					END
				END
			END					
		END
		
		FETCH NEXT FROM cur_auto004 INTO @Func, @VelhoGrupo, @NovoGrupo
	END
	
	CLOSE cur_auto004
	DEALLOCATE cur_auto004

GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'ANTEPREP2_RSAGEM')
	DROP PROCEDURE TELESSVR.ANTEPREP2_RSAGEM;
GO

CREATE PROCEDURE TELESSVR.ANTEPREP2_RSAGEM 
AS

DECLARE @cIcard char(12), @cStatusRep char(1)

BEGIN
	DECLARE cur_digalts CURSOR for 
		(SELECT top(10) ICARD, STATUS_REP FROM CONTDIG_SAGEM 
			WHERE STATUS_REP = '1' or STATUS_REP = '3' or STATUS_REP = '8')

	OPEN cur_digalts
	FETCH next from cur_digalts into @cIcard, @cStatusRep
	WHILE @@fetch_status != -1
	BEGIN

		-- INSERIRA´EM TAB.REPNDIGAUTO000, OS GRUPOS QUE A MATRICULA FAZ PARTE, PARA QUE DOS EQUIPTOS DESTE GRUPO SEJA RETIRADA ou INSERIDA A MATRICULA
		exec TELESSVR.Auxtrg_repDig2 @cIcard, @cStatusRep, '6'

		UPDATE CONTDIG_SAGEM SET STATUS_REP = '0' 
				where ICARD = @cIcard;

		FETCH next from cur_digalts into @cIcard, @cStatusRep

	END
	
	CLOSE cur_digalts
	DEALLOCATE cur_digalts
END

GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'AntePrep2_RTsi1')
	DROP PROCEDURE TELESSVR.AntePrep2_RTsi1;
GO

CREATE PROCEDURE TELESSVR.AntePrep2_RTsi1 
AS

DECLARE @cIcard char(12), @cStatusRep char(1)

BEGIN
	DECLARE cur_digaltsup CURSOR for 
		(SELECT top(10) ICARD, STATUS_REP FROM CONTDIG_TSI1 
			WHERE STATUS_REP = '1' or STATUS_REP = '3' or STATUS_REP = '8')

	OPEN cur_digaltsup
	FETCH next from cur_digaltsup into @cIcard, @cStatusRep
	WHILE @@fetch_status != -1
	BEGIN

		-- INSERIRA´EM TAB.REPNDIGAUTO000, OS GRUPOS QUE A MATRICULA FAZ PARTE, PARA QUE DOS EQUIPTOS DESTE GRUPO SEJA RETIRADA ou INSERIDA A MATRICULA
		exec TELESSVR.Auxtrg_repDig2 @cIcard, @cStatusRep, '8'

		UPDATE CONTDIG_TSI1 SET STATUS_REP = '0' 
				where ICARD = @cIcard;

		FETCH next from cur_digaltsup into @cIcard, @cStatusRep

	END
	
	CLOSE cur_digaltsup
	DEALLOCATE cur_digaltsup
END

GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'AntePrep_ROutrosBios')
	DROP PROCEDURE TELESSVR.AntePrep_ROutrosBios;
GO

CREATE PROCEDURE TELESSVR.AntePrep_ROutrosBios 
AS

DECLARE @cIcard char(12), @cStatusRep char(1), @cBioTipo char(1)

BEGIN
	DECLARE cur_digaltvrd CURSOR for 
		(SELECT top(10) ICARD, STATUS_REP, BIO_TIPO FROM CONTDIG_OUTROS 
			WHERE STATUS_REP = '1' or STATUS_REP = '3' or STATUS_REP = '8')

	OPEN cur_digaltvrd
	FETCH next from cur_digaltvrd into @cIcard, @cStatusRep, @cBioTipo 
	WHILE @@fetch_status != -1
	BEGIN

		IF (@cStatusRep = '1' or @cStatusRep = '3' or @cStatusRep = '8') 
		BEGIN
			-- INSERIRA´EM TAB.REPNDIGAUTO000, OS GRUPOS QUE A MATRICULA FAZ PARTE, PARA QUE DOS EQUIPTOS DESTE GRUPO SEJA RETIRADA ou INSERIDA A MATRICULA
			exec TELESSVR.Auxtrg_repDig2 @cIcard, @cStatusRep, @cBioTipo

			UPDATE CONTDIG_OUTROS SET STATUS_REP = '0' 
				WHERE ICARD = @cIcard and 
					BIO_TIPO = @cBioTipo
		END
		FETCH next from cur_digaltvrd into @cIcard, @cStatusRep, @cBioTipo

	END
	
	CLOSE cur_digaltvrd
	DEALLOCATE cur_digaltvrd
END

GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'Prep_RepDigit2')
	DROP PROCEDURE TELESSVR.Prep_RepDigit2;
GO

CREATE PROCEDURE TELESSVR.Prep_RepDigit2 AS

DECLARE @nCont SMALLINT
DECLARE @nTemLocal SMALLINT
          
DECLARE @c_status CHAR(1)
DECLARE @c_ifunc CHAR(12)
DECLARE @c_endip CHAR(15)
DECLARE @c_grupo CHAR(5)
DECLARE @c_biotipo CHAR(1)

DECLARE @xc_status CHAR(1)
DECLARE @xc_ifunc CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @ret CHAR(1)
DECLARE @xc_biotipo CHAR(1)

DECLARE @cAux CHAR(1)
DECLARE @cTipo CHAR(1)

SET DATEFORMAT YMD


	set @ret = 0

	SET LOCK_TIMEOUT 5000
	
	-- *************** PREPARACAO DE INCLUSAO/EXCLUSAO  FUNCIONARIOS NOS EQUIPAMENTOS (MONTAGEM DAS TABELAS AUXILIARES)
	BEGIN
	
		DELETE TMP_TD;
		DELETE TMP_NREPGRPATV;
		
		DELETE TMP_REPSAG001
		DELETE TMP_REPSAG002
	
		DELETE TMP_REPSUP001
		DELETE TMP_REPSUP002
		
		DELETE TMP_REPVRD001
		DELETE TMP_REPVRD002
		
		-- tabela temporaria TMP_TD compostas de todas as linhas de REPNDIGAUTO000 com solicitação de processamento de Inclusao ('3') e Exclusão ('8')
		INSERT INTO TMP_TD select top(5) IFUNC, STATUS, GRUPO, BIO_TIPO from REPNDIGAUTO000 WHERE STATUS = '3' or STATUS = '8' ORDER BY DATA_INS, IFUNC
		
		-- cursor para matriculas X GRUPOS a carregar/excluir
		DECLARE cur_autod000 CURSOR FOR (select IFUNC, STATUS, GRUPO, BIO_TIPO from TMP_TD)

		OPEN cur_autod000
		FETCH NEXT FROM cur_autod000 INTO @c_ifunc, @c_status, @c_grupo, @c_biotipo
		
		WHILE @@fetch_status != -1
		BEGIN   
			SET @nTemLocal = 0
			DELETE FROM TMP_NREPDIGGRP
			
			-- VERIFICA SE VALOR DE REPNDIGAUTO000.BIO_TIPO tem valor '0'.
			-- SE VALOR '0', indica que a preparacao das tabelas é para todos tipo de biometria
			-- SE VALOR é específico para TIPO DE LEITOR BIO, só vai ENTRAR EM tab. TMP_NREPDIGGRP os equipamentos dessa biometria

			IF (@c_biotipo = '0') BEGIN
				-- inclui em TMP_NREPDIGGRP TODOS OS REPS Q FAZEM PARTE DO GRUPO EM QUESTAO (NOVO OU VELHO) DO FUNCIONARIO 
				insert into TMP_NREPDIGGRP (IFUNC, GRUPO, END_IP, STATUS, BIO_TIPO)		
					select distinct @c_ifunc,  @c_grupo, VIEWGRPREP.end_ip, @c_status, VIEWGRPREP.BIO_TIPO
						from VIEWGRPREP
						where
							CAST(VIEWGRPREP.grupo AS INT) = CAST(@c_grupo AS INT) and
							--(VIEWGRPREP.bio_tipo = '6' or VIEWGRPREP.bio_tipo = '7'  or VIEWGRPREP.bio_tipo = '8' or VIEWGRPREP.bio_tipo = '9');
							--(VIEWGRPREP.bio_tipo != '0') ;
							((VIEWGRPREP.bio_tipo != '0') AND (VIEWGRPREP.bio_tipo != 'A'));
			END
			ELSE BEGIN
				insert into TMP_NREPDIGGRP (IFUNC, GRUPO, END_IP, STATUS, BIO_TIPO)		
					select distinct @c_ifunc,  @c_grupo, VIEWGRPREP.end_ip, @c_status, @c_biotipo
						from VIEWGRPREP
						where
							CAST(VIEWGRPREP.grupo AS INT) = CAST(@c_grupo AS INT) and
							VIEWGRPREP.bio_tipo = @c_biotipo
				
			END			
			
			
			IF (@@ROWCOUNT != 0) BEGIN
				SET @nTemLocal = 1
			END
		
		
			IF (@nTemLocal = 1) BEGIN
				DELETE FROM TMP_NREPDIGOUTROS;

				IF (@c_biotipo = '0') BEGIN
					-- inclui em TMP_NREPDIGOUTROS TODOS OS REPS Q FAZEM PARTE De outros GRUPOs DO FUNCIONARIO
					INSERT into TMP_NREPDIGOUTROS (IFUNC, GRUPO,  END_IP, BIO_TIPO, STATUS)		
						select distinct @c_ifunc, VIEWGRPREP.Grupo, VIEWGRPREP.end_ip, VIEWGRPREP.bio_tipo, @c_status
							from VIEWGRPREP, REPGRPF
							where
								(CAST(VIEWGRPREP.grupo AS INT) != CAST(@c_grupo AS INT)) and
								(CAST(VIEWGRPREP.grupo AS INT) in (select CAST(Grupo AS INT) from REPGRPF where IFUNC = @c_ifunc)) and 
								(CAST(VIEWGRPREP.grupo AS INT) not in (SELECT CAST(Grupo AS INT) FROM TMP_NREPDIGATV where IFUNC = @c_ifunc) ) and 
								--(VIEWGRPREP.bio_tipo = '6' or VIEWGRPREP.bio_tipo = '7'  or VIEWGRPREP.bio_tipo = '8' or VIEWGRPREP.bio_tipo = '9');
								--(VIEWGRPREP.bio_tipo != '0');
								((VIEWGRPREP.bio_tipo != '0') AND (VIEWGRPREP.bio_tipo != 'A'));
				END
				ELSE BEGIN
					INSERT into TMP_NREPDIGOUTROS (IFUNC, GRUPO,  END_IP, BIO_TIPO, STATUS)		
						select distinct @c_ifunc, VIEWGRPREP.Grupo, VIEWGRPREP.end_ip, @c_biotipo, @c_status
							from VIEWGRPREP, REPGRPF
							where
								(CAST(VIEWGRPREP.grupo AS INT) != CAST(@c_grupo AS INT)) and
								(CAST(VIEWGRPREP.grupo AS INT) in (select CAST(Grupo AS INT) from REPGRPF where IFUNC = @c_ifunc)) and 
								(CAST(VIEWGRPREP.grupo AS INT) not in (SELECT CAST(Grupo AS INT) FROM TMP_NREPDIGATV where IFUNC = @c_ifunc) ) and 
								(VIEWGRPREP.bio_tipo = @c_biotipo);
				END			

				set @nCont = @@ROWCOUNT
				
				-- Insere em tabela resultante OS REGISTROS de TMP_NREPDIGGRP que não tem em TMP_NREPDIGOUTROS
				IF (@c_status = '3') BEGIN		-- INCLUINDO
					set @cTipo = '3'

					DECLARE Rtmp_digeqptos cursor for (SELECT END_IP, BIO_TIPO from TMP_NREPDIGGRP  
						WHERE IFUNC = @c_ifunc and 
							STATUS = @cTipo and  
							CAST(Grupo AS INT) = CAST(@c_grupo AS INT) )
							
					OPEN Rtmp_digeqptos
					FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					WHILE @@fetch_status != -1
					BEGIN
						SET @nCont = 0;
						SET @nCont = (SELECT count(*) FROM TMP_NREPDIGOUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
						IF (@nCont = 0)					
						BEGIN
							-- trata equipamento SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') 
							begin
								SET @cAux = (SELECT STATUS FROM TMP_REPSAG001 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
								IF (@cAux  is null) 
									INSERT into TMP_REPSAG001 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo);
								ELSE
									IF (@cAux = '0') 
										UPDATE TMP_REPSAG001 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip;
							end
							ELSE 
								-- trata equipamento SUPREMA
								IF (@xc_biotipo = '8') begin
									SET @cAux = (SELECT STATUS FROM TMP_REPSUP001 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
									IF (@cAux  is null) 
										INSERT into TMP_REPSUP001 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo);
									ELSE
										IF (@cAux = '0') 
											UPDATE TMP_REPSUP001 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip;
								end											
							ELSE 
								-- trata equipamento VIRDI /e outros
								IF (@xc_biotipo != 'A') 		-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
								begin
									-- trata equipamento VIRDI / OUTROS
									SET @cAux = (SELECT STATUS FROM TMP_REPVRD001 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
									IF (@cAux  is null) 
										INSERT into TMP_REPVRD001 (IFUNC, END_IP, BIO_TIPO, STATUS)	VALUES  (@c_ifunc, @xc_endip, @xc_biotipo, @cTipo);
									ELSE
										IF (@cAux = '0') 
											UPDATE TMP_REPVRD001 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip and BIO_TIPO = @xc_biotipo;
								end
						END									
							
						-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE EXCLUSAO, PARA EXCLUIR
						BEGIN
							-- SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') begin
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPSAG002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '8') 
									DELETE FROM TMP_REPSAG002 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							end
							-- SUPREMA
							ELSE IF (@xc_biotipo = '8') begin
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPSUP002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '8') 
									DELETE FROM TMP_REPSUP002 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							end
							-- VIRDI / OUTROS
							ELSE 
								IF (@xc_biotipo != 'A') begin	-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
									SET @cAux = null
									SET @cAux = (SELECT STATUS from TMP_REPVRD002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
									IF (@cAux = '8') 
										DELETE FROM TMP_REPVRD002 where IFUNC = @c_ifunc and END_IP = @xc_endip;
								end
						END
								
						FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					END 
					
					CLOSE Rtmp_digeqptos
					DEALLOCATE Rtmp_digeqptos
				END
				
				ELSE IF (@c_status = '8') BEGIN		-- EXCLUINDO
					set @cTipo = '8'

					DECLARE Rtmp_digeqptos cursor for (SELECT END_IP, BIO_TIPO from TMP_NREPDIGGRP  
						WHERE IFUNC = @c_ifunc and 
							STATUS = @cTipo and  
							CAST(Grupo AS INT) = CAST(@c_grupo AS INT) )
					OPEN Rtmp_digeqptos
					FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					WHILE @@fetch_status != -1
					BEGIN

						SET @nCont = 0;
						SET @nCont = (SELECT count(*) FROM TMP_NREPDIGOUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
						IF (@nCont = 0)	BEGIN			
							-- trata equipamento SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') begin
								SET @cAux = (SELECT STATUS from TMP_REPSAG002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux is null)  
									INSERT into TMP_REPSAG002 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo );

								ELSE
									IF (@cAux = '0') 
										UPDATE TMP_REPSAG002 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip
							END
							ELSE 
								-- trata equipamento SUPREMA
								IF (@xc_biotipo = '8') begin
									SET @cAux = (SELECT STATUS FROM TMP_REPSUP002 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
									IF (@cAux  is null) 
										INSERT into TMP_REPSUP002 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo);
									ELSE
										IF (@cAux = '0') 
											UPDATE TMP_REPSUP002 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip;
								end											
								ELSE 
									-- trata equipamento VIRDI / OUTROS
									IF (@xc_biotipo != 'A') 		-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
									begin
										SET @cAux = (SELECT STATUS FROM TMP_REPVRD002 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
										IF (@cAux  is null) 
											INSERT into TMP_REPVRD002 (IFUNC, END_IP, BIO_TIPO, STATUS)	VALUES  (@c_ifunc, @xc_endip, @xc_biotipo, @cTipo);
										ELSE
											IF (@cAux = '0') 
												UPDATE TMP_REPVRD002 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip and BIO_TIPO = @xc_biotipo;
									end											
						END
							
						-- verifica se funcionario x ip ja está em tabela de inclusao, para incluir
						BEGIN
							-- SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') BEGIN
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPSAG001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '3') 
									DELETE FROM TMP_REPSAG001 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							END
							-- SUPREMA
							ELSE IF (@xc_biotipo = '8') BEGIN
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPSUP001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '3') 
									DELETE FROM TMP_REPSUP001 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							END
							-- VIRDI / OUTROS
							ELSE  IF (@xc_biotipo != 'A') BEGIN					-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPVRD001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '3') 
									DELETE FROM TMP_REPVRD001 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							END
						END
							
						FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					END 
					CLOSE Rtmp_digeqptos
					DEALLOCATE Rtmp_digeqptos
				END
			END

			-- atualiza estado para tratado em REPNDIGAUTO000, SE NÃO encontrou equipamento pertencente ao grupo e cai fora para tratar proximo funcionario
			UPDATE REPNDIGAUTO000 SET STATUS = '0' 			
				WHERE IFUNC = @c_ifunc and 
					BIO_TIPO = @c_biotipo and 
					CAST(Grupo AS INT) = CAST(@c_grupo AS INT)
			
			INSERT INTO TMP_NREPDIGATV (IFUNC, GRUPO, BIO_TIPO) VALUES (@c_ifunc, @c_grupo, @c_biotipo)

			FETCH NEXT FROM cur_autod000 INTO @c_ifunc, @c_status, @c_grupo, @c_biotipo
		END
		
		CLOSE cur_autod000
		DEALLOCATE cur_autod000
	END
			

	-- trata SAGEM
	-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSAG001 - INCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPSAG001 WHERE STATUS = '3')
	
	IF (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG002 (CARGA LISTA) se eqpto  não existir
		insert into RDIG002 (END_IP, STATUS, BIO_TIPO)
			select distinct end_ip, '0', '6' 
			from TMP_REPSAG001
			where TMP_REPSAG001.end_ip not in ( select end_ip from RDIG002 ) and 
					TMP_REPSAG001.STATUS = '3'	
		
		-- insere ifunc-rep em tab. RDIG001, se não existir em tab.
		DECLARE cur_tmpautoSAG001 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSAG001 where STATUS = '3' or STATUS = '1')
		OPEN cur_tmpautoSAG001
		FETCH NEXT FROM cur_tmpautoSAG001 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG001 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG001 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '6');
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			DELETE FROM RDIG101 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	-- DELETA DA TABELA DE EXCLUSAO

			FETCH NEXT FROM cur_tmpautoSAG001 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSAG001
		DEALLOCATE cur_tmpautoSAG001
	END

	
		-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSAG002 - EXCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPSAG002 WHERE STATUS = '8')
	if (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG102 (EXCLUSAO) o codin não existir
		INSERT INTO RDIG102 (END_IP, STATUS, BIO_TIPO) 
			select distinct end_ip, '0', '6'
			from TMP_REPSAG002
			where TMP_REPSAG002.end_ip not in ( select end_ip from RDIG102 ) and 
					TMP_REPSAG002.STATUS = '8'	
	
		-- insere ifunc-rep em tab. RDIG101, se não existir em tab.
		DECLARE cur_tmpautoSAG002 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSAG002 where STATUS = '8')
		OPEN cur_tmpautoSAG002
		FETCH NEXT FROM cur_tmpautoSAG002 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG101 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG101 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '6');
			end

			-- deleta o ifunc da tabela de INclusao para o rep especifico do grupo
			DELETE FROM RDIG001 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoSAG002 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSAG002
		DEALLOCATE cur_tmpautoSAG002
	end



	-- trata SUPREMA
	-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSUP001 - INCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPSUP001 WHERE STATUS = '3')
	
	IF (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG002 (CARGA LISTA) se eqpto  não existir
		insert into RDIG002 (END_IP, STATUS, BIO_TIPO)
			select distinct end_ip, '0', '8' 
			from TMP_REPSUP001
			where TMP_REPSUP001.end_ip not in ( select end_ip from RDIG002 ) and 
					TMP_REPSUP001.STATUS = '3'	
		
		-- insere ifunc-rep em tab. RDIG003, se não existir em tab.
		DECLARE cur_tmpautoSUP001 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSUP001 where STATUS = '3' or STATUS = '1')
		OPEN cur_tmpautoSUP001
		FETCH NEXT FROM cur_tmpautoSUP001 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG003 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG003 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '8');
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			DELETE FROM RDIG103 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoSUP001 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSUP001
		DEALLOCATE cur_tmpautoSUP001
	END

	
		-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSUP002 - EXCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPSUP002 WHERE STATUS = '8')
	
	if (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG102 (EXCLUSAO) o codin não existir
		INSERT INTO RDIG102 (END_IP, STATUS, BIO_TIPO) 
			select distinct end_ip, '0', '8'
			from TMP_REPSUP002
			where TMP_REPSUP002.end_ip not in ( select end_ip from RDIG102 ) and 
					TMP_REPSUP002.STATUS = '8'	
	
		-- insere ifunc-rep em tab. RDIG103, se não existir em tab.
		DECLARE cur_tmpautoSUP002 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSUP002 where STATUS = '8')
		OPEN cur_tmpautoSUP002
		FETCH NEXT FROM cur_tmpautoSUP002 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG103 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG103 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '8');
			end

			-- deleta o ifunc da tabela de INclusao para o rep especifico do grupo
			DELETE FROM RDIG003 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoSUP002 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSUP002
		DEALLOCATE cur_tmpautoSUP002
	END
	
	
	-- trata VIRDI / OUTRAS LEITORAS
	-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPVRD001 - INCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPVRD001 WHERE STATUS = '3')
	
	IF (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG002 (CARGA LISTA) se eqpto  não existir
		insert into RDIG002 (END_IP, STATUS, BIO_TIPO)
			--select distinct end_ip, '0', '9' 
			select distinct end_ip, '0', bio_tipo  
			from TMP_REPVRD001
			where TMP_REPVRD001.end_ip not in ( select end_ip from RDIG002 ) and 
					TMP_REPVRD001.STATUS = '3'	
		
		-- insere ifunc-rep em tab. RDIG004, se não existir em tab.
		DECLARE cur_tmpautoVRD001 CURSOR FOR (SELECT IFUNC, END_IP, STATUS, BIO_TIPO from TMP_REPVRD001 where STATUS = '3' or STATUS = '1')
		OPEN cur_tmpautoVRD001
		FETCH NEXT FROM cur_tmpautoVRD001 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		while @@fetch_status != -1
		begin
			UPDATE RDIG004 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG004 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', @xc_biotipo );
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			DELETE FROM RDIG104 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoVRD001 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		end
		CLOSE cur_tmpautoVRD001
		DEALLOCATE cur_tmpautoVRD001
	END

	
		-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPVRD002 - EXCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPVRD002 WHERE STATUS = '8')
	
	if (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG102 (EXCLUSAO) o codin não existir
		INSERT INTO RDIG102 (END_IP, STATUS, BIO_TIPO) 
			--select distinct end_ip, '0', '9'
			select distinct end_ip, '0', bio_tipo 
			from TMP_REPVRD002
			where TMP_REPVRD002.end_ip not in ( select end_ip from RDIG102 ) and 
					TMP_REPVRD002.STATUS = '8'	
	
		-- insere ifunc-rep em tab. RDIG104, se não existir em tab.
		DECLARE cur_tmpautoVRD002 CURSOR FOR (SELECT IFUNC, END_IP, STATUS, BIO_TIPO from TMP_REPVRD002 where STATUS = '8')
		OPEN cur_tmpautoVRD002
		FETCH NEXT FROM cur_tmpautoVRD002 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		while @@fetch_status != -1
		begin
			UPDATE RDIG104 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG104 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								--values (@xc_ifunc, @xc_endip, '1', '9');
								values (@xc_ifunc, @xc_endip, '1', @xc_biotipo );
			end

			-- deleta o ifunc da tabela de INclusao para o rep especifico do grupo
			DELETE FROM RDIG004 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoVRD002 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		end
		CLOSE cur_tmpautoVRD002
		DEALLOCATE cur_tmpautoVRD002
	end	

	SET LOCK_TIMEOUT -1

GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'trata2_RepSagem')
	DROP PROCEDURE TELESSVR.trata2_RepSagem;
GO

CREATE PROCEDURE TELESSVR.trata2_RepSagem 
AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)

DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000


	-- ********************   ARRUMAR SITUAÇÕES PARA SAGEM    -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA (status '4')
	DECLARE Rcur_troubleIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG001 
			WHERE STATUS = '4'
		)
	OPEN Rcur_troubleIns1
	FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE Rcur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from RDIG001 
				WHERE (IFUNC = @z_mat and STATUS = '4')
			)
		OPEN Rcur_troubleIns2
		FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			DELETE RDIG001 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')	-- vai excluir registro porque nao adianta reenviar 

			UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip
		END


		CLOSE Rcur_troubleIns2
		deallocate Rcur_troubleIns2

		FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	END
	
	CLOSE Rcur_troubleIns1
	deallocate Rcur_troubleIns1


	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS SAGEM (DA TAB.CONTDIG_SAGEM CADASTRO)
	-- delete registro de RDIG001 se nao houver cadastro de BIO SAGEM desta matricula
	DECLARE Rcur_autoIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG001 
			WHERE STATUS = '3'
		)
	OPEN Rcur_autoIns1
	FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		-- VERIFICA SE HÁ CADASTRO DO BIO SAGEM DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_SAGEM WHERE ICARD = @z_mat;
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO SAGEM desta matricula
			DECLARE Rcur_autoIns2 CURSOR FOR 
				(SELECT END_IP from RDIG001 
					WHERE (IFUNC = @z_mat and STATUS = '3')
				)
			OPEN Rcur_autoIns2
			FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				DELETE RDIG001 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '3')

				UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip
			END


			CLOSE Rcur_autoIns2
			deallocate Rcur_autoIns2
		END

		FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat
	END
	
	CLOSE Rcur_autoIns1
	deallocate Rcur_autoIns1



	-- ******************** ALTERA STATUS DE TODOS OS CODINS PARA CARGA DE DIGITAIS, SE ESSES NÃO ESTIVEREM COM CARGA DE DIGITAIS OU ESTIVEREM PENDENTES
	-- nao altera status se o equipamento responde 'NAO IMPLEMENTADO'
	DECLARE Rcur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG001 
			--WHERE ( status != '0' and status != '2' and			-- biometrias pendentes na carga
			WHERE ( status != '0' and status != '2' and status != '4' and			-- biometrias pendentes na carga
					(BIO_TIPO = '6' OR BIO_TIPO = '7')
				  )
		)
	OPEN Rcur_endip
	FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status
	
	WHILE @@fetch_status != -1
	begin
		UPDATE RDIG002 set status = '1'						-- FORCA RECARGA DAS BIOMETRIAS PENDENTES, ATIVANDO DIG002
			WHERE (END_IP = @z_endip and 
					(STATUS = '0' or STATUS = '3' or STATUS = '4') and 		-- status '0':carregado, '3':pendente, '4':rep nao aceita carga digital
					BIO_TIPO = @z_biotipo)
		FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status
	end

	CLOSE Rcur_endip
	deallocate Rcur_endip




	-- ********************   TRATA EQUIPAMENTOS SAGEM QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos SAGEM q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos SAGEM que tiveram carga de aplicativo ('5') de devem voltar ao estado de repouso. OBS: nao está fazenda a recarga de biometria automaticamente.
	
	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from RDIG002 
			WHERE ((BIO_TIPO = '6' or BIO_TIPO = '7')
					and
				   (status = '5' or status = '6' OR		-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())) 
				  )
		)
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status
	
	WHILE @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE RDIG001 set STATUS = '1'			-- status = 1 (A carregar)
				WHERE (end_ip = @z_endip and status = '2' and BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')
					
			UPDATE RDIG002 set status = '1'  		-- FORÇA A RECARGA PARA AQUELS QUE DERAM PROBLEMA
				where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)
		end

		else if (@z_status = '5' or @z_status = '6') begin
			UPDATE RDIG002 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)		-- NAO FAZ RECARGA DE BIOMETRIAS SAGEM APOS CARGA DE APLICATIVO
		end;
		
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_dig02
	DEALLOCATE Rcur_dig02
	

	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUAÇÃO
	-- para BIOMETRIAS  SAGEM DE DIG001 que ficaram em estado carregando '2', e o equipamento está em estado de repouso	, forca o equipamento a carrega-lo novamente
	
	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.STATUS from RDIG002 A 
			INNER JOIN RDIG001 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				(A.BIO_TIPO = '6') or (A.BIO_TIPO = '7')) 
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG001 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and (BIO_TIPO = '6' or BIO_TIPO = '7');
		UPDATE RDIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip and (BIO_TIPO = '6' or BIO_TIPO = '7');
		
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status;
	END
	CLOSE Rcur_dig02
	deallocate Rcur_dig02
	

	


	-- ********************   ARRUMAR SITUAÇÕES PARA SAGEM    -  EXCLUSAO
	
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins Sagem para exclusao de biometria, se esses não estiverem com exclusao de biometria ou estiverem pendentes

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO  from RDIG101 
			--WHERE ( STATUS != '0' and STATUS != '2' and 
			WHERE ( STATUS != '0' and STATUS != '2' and STATUS != '4' and 
					(BIO_TIPO = '6' or BIO_TIPO = '7')
				  )
		)
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG102 set status = '1'
			WHERE (END_IP = @z_endip) and 
				--(STATUS = '0' or STATUS = '3') and 
				(STATUS = '0' or STATUS = '3' or STATUS = '4') and 
				(BIO_TIPO = '6' or BIO_TIPO = '7')

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1



	
	
	-- ********************   TRATA EQUIPAMENTOS SAGEM QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG102 
			WHERE ( (BIO_TIPO = '6' or BIO_TIPO = '7')
					and   
					(status = '5' or status = '6' or 													-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin

			UPDATE RDIG101 set status = '1'
				WHERE (END_IP = @z_endip and STATUS = '2' and BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')

			UPDATE RDIG102 set status = '1' 
					where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)
		end
		
		else if (@z_status = '5' OR @z_status = '6') begin
			UPDATE RDIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1



	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUAÇÃO
	-- para digitais de RDIG101 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.status from RDIG102 A 
			INNER JOIN RDIG101 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				(A.BIO_TIPO = '6' or A.BIO_TIPO = '7'))
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG101 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and (BIO_TIPO = '6' or BIO_TIPO = '7');
		UPDATE RDIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip AND (BIO_TIPO = '6' or BIO_TIPO = '7');

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status;
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1

	SET LOCK_TIMEOUT -1

GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'trata2_Reptsi1')
	DROP PROCEDURE TELESSVR.trata2_Reptsi1;
GO

CREATE PROCEDURE TELESSVR.trata2_Reptsi1 
AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)

DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000


	-- ********************   ARRUMAR SITUAÇÕES PARA TSI1    -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA  (status '4')
	DECLARE Rcur_troubleIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG003 
			WHERE STATUS = '4'
		)
	OPEN Rcur_troubleIns1
	FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE Rcur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from RDIG003 
				WHERE (IFUNC = @z_mat and STATUS = '4')
			)
		OPEN Rcur_troubleIns2
		FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			DELETE RDIG003 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')

			UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip
		END


		CLOSE Rcur_troubleIns2
		deallocate Rcur_troubleIns2

		FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	END
	
	CLOSE Rcur_troubleIns1
	deallocate Rcur_troubleIns1



	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS TSI1 (DA TAB.CONTDIG_TSI1 CADASTRO)
	-- delete registro de RDIG003 se nao houver cadastro de BIO TSI1 desta matricula
	DECLARE Rcur_autoIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG003 
			WHERE STATUS = '3'
		)
	OPEN Rcur_autoIns1
	FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		-- VERIFICA SE HÁ CADASTRO DO BIO TSI1 DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_TSI1 WHERE ICARD = @z_mat;
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO TSI1 desta matricula
			DECLARE Rcur_autoIns2 CURSOR FOR 
				(SELECT END_IP from RDIG003 
					WHERE (IFUNC = @z_mat and STATUS = '3')
				)
			OPEN Rcur_autoIns2
			FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				DELETE RDIG003 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '3')

				UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip
			END


			CLOSE Rcur_autoIns2
			deallocate Rcur_autoIns2
		END

		FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat
	END
	
	CLOSE Rcur_autoIns1
	deallocate Rcur_autoIns1



	-- ******************** ALTERA STATUS DE TODOS OS CODINS PARA CARGA DE DIGITAIS, SE ESSES NÃO ESTIVEREM COM CARGA DE DIGITAIS OU ESTIVEREM PENDENTES
	-- nao altera status se o equipamento responde 'NAO IMPLEMENTADO'
	DECLARE Rcur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG003 
			--WHERE (STATUS != '0' and STATUS != '2' AND BIO_TIPO = '8')		-- biometrias pendentes na carga
			WHERE (STATUS != '0' and STATUS != '2' and STATUS != '4' AND BIO_TIPO = '8')		-- biometrias pendentes na carga
		)
	OPEN Rcur_endip
	FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status 
	
	while @@fetch_status != -1
	begin
		IF (@z_status != '4') begin
			UPDATE RDIG002 set status = '1'
				WHERE (END_IP = @z_endip and 
						--(STATUS = '0' or STATUS= '3') and 
						(STATUS = '0' or STATUS= '3' or STATUS= '4') and 		-- status '0':carregado, '3':pendente, '4':rep nao aceita carga digital
						BIO_TIPO = @z_biotipo)
		end
		FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_endip
	deallocate Rcur_endip



	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos TSI1 q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos TSI1 q tiveram carga de aplicativo 
	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from RDIG002 
			WHERE ((BIO_TIPO = '8')
					and 
				   (status = '5' or status = '6' or 		-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())) 
				  )
		)
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status

	WHILE @@fetch_status != -1
	begin
		-- OBSERVACAO: PARA BIOMETRIA TSI1, A CARGA DE APLICATIVO NO EQUIPAMENTO NAO APAGA AS BIOMETRIAS, POIS BIOMETRIA TSI1 FICA NO LEITOR E NAO NO EQUIPAMENTO,
		-- LOGO NAO É NECESSARIO FAZER A RECARGA DE BIOMETRIA
		IF (@z_status = '2') begin		-- situação q estava fazendo a carga e deu problema

			UPDATE RDIG003 set STATUS = '1'			-- status = 1 : a carregar
				WHERE (END_IP = @z_endip and STATUS = '2'  and BIO_TIPO = @z_biotipo) 

			UPDATE RDIG002 set status = '1' 
				where (END_IP = @z_endip and BIO_TIPO = @z_biotipo)
		end

		ELSE begin
			IF (@z_status = '5' OR @z_status = '6') begin		-- HOUVE CARGA DE APLICATIVO, MAS NAO VAI RECARREGAR AS BIOMETRIAS
				UPDATE RDIG002 set status = '0' 
					WHERE (end_ip = @z_endip  and BIO_TIPO = @z_biotipo)
			end
		end
		
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end

	CLOSE Rcur_dig02
	DEALLOCATE Rcur_dig02
	


	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUAÇÃO
	-- para BIOMETRIAS  TSI1 DE RDIG003 que ficaram em estado carregando '2', e o equipamento está em estado de repouso	, forca o equipamento a carrega-lo novamente

	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.status from RDIG002 A 
			INNER JOIN RDIG003 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = '8')
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG003 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' AND BIO_TIPO = '8';
		UPDATE RDIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip  and BIO_TIPO = '8';
			
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status;
	END
	CLOSE Rcur_dig02
	deallocate Rcur_dig02
	


	-- ********************   ARRUMAR SITUAÇÕES PARA   TSI1   -  EXCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins Sagem para exclusao de biometria, se esses não estiverem com exclusao de biometria ou estiverem pendentes

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO from RDIG103 
			--WHERE (STATUS != '0' and STATUS != '2' and BIO_TIPO = '8')
			WHERE (STATUS != '0' and STATUS != '2' and STATUS != '4' and BIO_TIPO = '8')		-- statys 4 indica resposta do rep de nao implementado
		)
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG102 set STATUS = '1'
			WHERE (END_IP = @z_endip) and 
			  	  --(STATUS = '0' or STATUS = '3') and 
			  	  (STATUS = '0' or STATUS = '3' or STATUS = '4') and 		-- statys 4 indica resposta do rep de nao implementado
				  (BIO_TIPO = '8')

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1
	


	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG102 
			WHERE ( (BIO_TIPO = '8')
					and   
					(status = '5' or status = '6' or 													-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip,  @z_biotipo, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE RDIG103 set status = '1'
				WHERE (END_IP = @z_endip) and (status = '2') and (BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')

			UPDATE RDIG102 set status = '1' 
				WHERE (END_IP = @z_endip  and BIO_TIPO = @z_biotipo)
		end
				
		else if (@z_status = '5' OR @z_status = '6') begin
			UPDATE RDIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;
				
		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1



	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUAÇÃO
	-- para digitais de RDIG103 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.status from RDIG102 A 
			INNER JOIN RDIG103 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = '8')
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG103 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and BIO_TIPO = '8';
		UPDATE RDIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip and BIO_TIPO = '8';
	
		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status;
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1

	SET LOCK_TIMEOUT -1
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'trata_RepOutrosBios')
	DROP PROCEDURE TELESSVR.trata_RepOutrosBios;
GO

CREATE PROCEDURE TELESSVR.trata_RepOutrosBios 
AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)

DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000


	-- ********************   ARRUMAR SITUAÇÕES PARA VIRDI / OUTRAS BIOS   -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS  QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA  (status '4')
	DECLARE Rcur_troubleIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG004 
			WHERE STATUS = '4'
		)
	OPEN Rcur_troubleIns1
	FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE Rcur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from RDIG004 
				WHERE (IFUNC = @z_mat and STATUS = '4')
			)
		OPEN Rcur_troubleIns2
		FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			DELETE RDIG004 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')

			UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip
		END


		CLOSE Rcur_troubleIns2
		deallocate Rcur_troubleIns2

		FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	END
	
	CLOSE Rcur_troubleIns1
	deallocate Rcur_troubleIns1


	-- ***********************  TRATA AS BIOMETRIAS VIRDI QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS VIRDI (DA TAB.CONTDIG_OUTROS CADASTRO)
	-- delete registro de RDIG004 se nao houver cadastro de BIO VIRDI desta matricula
	
	DECLARE Rcur_autoIns1 CURSOR FOR 
		(SELECT distinct IFUNC, BIO_TIPO from RDIG004 
			WHERE STATUS = '3'
		)
	OPEN Rcur_autoIns1
	FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat, @z_biotipo
	WHILE (@@fetch_status != -1) BEGIN
		
		-- VERIFICA SE HÁ CADASTRO DO BIO VIRDI DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_OUTROS WHERE ICARD = @z_mat and BIO_TIPO = @z_biotipo;
		
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO VIRDI desta matricula
			
			DECLARE Rcur_autoIns2 CURSOR FOR 
				(SELECT END_IP from RDIG004 
					WHERE (IFUNC = @z_mat and STATUS = '3' and BIO_TIPO = @z_biotipo)
				)
			OPEN Rcur_autoIns2
			FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				DELETE RDIG004 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '3')

				UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip
			END


			CLOSE Rcur_autoIns2
			deallocate Rcur_autoIns2
		END

		FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat, @z_biotipo
	END
	
	CLOSE Rcur_autoIns1
	deallocate Rcur_autoIns1



	-- ******************** ALTERA STATUS DE TODOS OS CODINS PARA CARGA DE DIGITAIS, SE ESSES NÃO ESTIVEREM COM CARGA DE DIGITAIS OU ESTIVEREM PENDENTES
	-- nao altera status se o equipamento responde 'NAO IMPLEMENTADO'
	DECLARE Rcur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG004 
			--WHERE (STATUS != '0' and STATUS != '2' AND BIO_TIPO = '9')		-- biometrias pendentes na carga
			WHERE (STATUS != '0' and STATUS != '2' )		-- biometrias pendentes na carga
		)
	OPEN Rcur_endip
	FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status 
	
	while @@fetch_status != -1
	begin
		IF (@z_status != '4') begin
			UPDATE RDIG002 set status = '1'
				WHERE (END_IP = @z_endip and 
						--(STATUS = '0' or STATUS= '3') and 
						(STATUS = '0' or STATUS= '3' or STATUS= '4') and 		-- status '0':carregado, '3':pendente, '4':rep nao aceita carga digital
						BIO_TIPO = @z_biotipo)
		end
		FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_endip
	deallocate Rcur_endip



	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos VIRDI q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos VIRDI q tiveram carga de aplicativo 
	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from RDIG002 
			WHERE (((BIO_TIPO != '6') and (BIO_TIPO != '7') and (BIO_TIPO != '8')) 
					and 
				   (status = '5' or status = '6' or		-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())) 
				  )
		)
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status

	WHILE @@fetch_status != -1
	begin
		-- OBSERVACAO: PARA BIOMETRIA VIRDI, A CARGA DE APLICATIVO NO EQUIPAMENTO NAO APAGA AS BIOMETRIAS, POIS BIOMETRIA VIRDI FICA NO LEITOR E NAO NO EQUIPAMENTO,
		-- LOGO NAO É NECESSARIO FAZER A RECARGA DE BIOMETRIA
		IF (@z_status = '2') begin		-- situação q estava fazendo a carga e deu problema

			UPDATE RDIG004 set STATUS = '1'			-- status = 1 : a carregar
				WHERE (END_IP = @z_endip and STATUS = '2'  and BIO_TIPO = @z_biotipo) 

			UPDATE RDIG002 set status = '1' 
				where (END_IP = @z_endip and BIO_TIPO = @z_biotipo)
		end

		ELSE begin
			IF (@z_status = '5' OR @z_status = '6') begin		-- HOUVE CARGA DE APLICATIVO, MAS NAO VAI RECARREGAR AS BIOMETRIAS
				UPDATE RDIG002 set status = '0' 
					WHERE (end_ip = @z_endip  and BIO_TIPO = @z_biotipo)
			end
		end
		
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end

	CLOSE Rcur_dig02
	DEALLOCATE Rcur_dig02
	


	-- ***********************  TRATA AS BIOMETRIAS VIRDI QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUAÇÃO
	-- para BIOMETRIAS  VIRDI DE RDIG004 que ficaram em estado carregando '2', e o equipamento está em estado de repouso	, forca o equipamento a carrega-lo novamente

	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.status, A.BIO_TIPO from RDIG002 A 
			INNER JOIN RDIG004 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = B.BIO_TIPO)
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG004 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' AND BIO_TIPO = @z_biotipo;
		UPDATE RDIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip  and BIO_TIPO = @z_biotipo;
			
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status, @z_biotipo;
	END
	CLOSE Rcur_dig02
	deallocate Rcur_dig02
	


	-- ********************   ARRUMAR SITUAÇÕES PARA   VIRDI   -  EXCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS VIRDI QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins VIRDI para exclusao de biometria, se esses não estiverem com exclusao de biometria ou estiverem pendentes

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO from RDIG104 
			--WHERE (STATUS != '0' and STATUS != '2' and BIO_TIPO = '9')
			WHERE (STATUS != '0' and STATUS != '2' and STATUS != '4')		-- statys 4 indica resposta do rep de nao implementado
		)
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG102 set STATUS = '1'
			WHERE (END_IP = @z_endip) and 
			  	  --(STATUS = '0' or STATUS = '3') and 
			  	  (STATUS = '0' or STATUS = '3' or STATUS = '4') and 		-- statys 4 indica resposta do rep de nao implementado
				  (BIO_TIPO = @z_biotipo)

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1
	


	-- ********************   TRATA EQUIPAMENTOS VIRDI QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG102 
			WHERE (((BIO_TIPO != '6') and (BIO_TIPO != '7') and (BIO_TIPO != '8')) 
					and   
					(status = '5' or status = '6' or 														-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip,  @z_biotipo, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE RDIG104 set status = '1'
				WHERE (END_IP = @z_endip) and (status = '2') and (BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')

			UPDATE RDIG102 set status = '1' 
				WHERE (END_IP = @z_endip  and BIO_TIPO = @z_biotipo)
		end
				
		else if (@z_status = '5' or @z_status = '6') begin
			UPDATE RDIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;
				
		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1



	-- ***********************  TRATA AS BIOMETRIAS VIRDI QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUAÇÃO
	-- para digitais de RDIG104 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.status, A.BIO_TIPO from RDIG102 A 
			INNER JOIN RDIG104 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = B.BIO_TIPO)
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG104 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and BIO_TIPO = @z_biotipo;
		UPDATE RDIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip and BIO_TIPO = @z_biotipo;
	
		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status, @z_biotipo;
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1

	SET LOCK_TIMEOUT -1
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'P_RepGerDigital2')
	DROP PROCEDURE TELESSVR.P_RepGerDigital2;
GO

CREATE PROCEDURE TELESSVR.P_RepGerDigital2 
AS

DECLARE @ret CHAR(1)


	SET DATEFORMAT YMD


	set @ret = 0
	
	-- prepara automatico digitais sagem RDIG001 / RDIG101
	exec TELESSVR.AntePrep2_RSagem	
	
	-- prepara automatico digitais tsi1 RDIG003 / RDIG103
	exec TELESSVR.AntePrep2_RTsi1	

	-- prepara automatico digitais virdi E OUTROS RDIG004 / RDIG104
	exec TELESSVR.AntePrep_ROutrosBios	


	exec TELESSVR.Prep_RepDigit2	


	-- trata biometria sagem
	exec TELESSVR.trata2_RepSagem	

	-- trata biometria tsi1
	exec TELESSVR.trata2_RepTsi1		
	
	-- trata biometria virdi/outros
	exec TELESSVR.trata_RepOutrosBios		
	
	
	select @ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlfim_rExcAutoDigit2')
	DROP PROCEDURE TELESSVR.sqlfim_rExcAutoDigit2;
GO

CREATE PROCEDURE TELESSVR.sqlfim_rExcAutoDigit2 @cEndIp CHAR(15), @cStat CHAR(1), @cBioTipo CHAR(1) 
AS

declare @nCont smallint
declare @nErr smallint
declare @Aux char(12)
declare @cIcard char(12)
declare @STATUS char(1)

	SET LOCK_TIMEOUT 5000
	SET @nCont = 0
	SET @nErr = 0
	
	IF (@cBioTipo =  '6' or @cBioTipo = '7') BEGIN		-- SAGEM
		DECLARE Rlexcldig_cur CURSOR FOR
			SELECT IFUNC, STATUS FROM RDIG101 
				WHERE END_IP = @cEndIp AND STATUS = '2'
				ORDER by IFUNC;

		OPEN Rlexcldig_cur
		FETCH next from Rlexcldig_cur into @cIcard, @STATUS
		WHILE (@@fetch_status != -1)
		begin
			update RDIG101 set STATUS = @cStat where current of Rlexcldig_cur 
			SET @nCont = @nCont+1

			fetch next from Rlexcldig_cur into @cIcard, @STATUS
		end
		close Rlexcldig_cur
		deallocate Rlexcldig_cur
	END

	ELSE	
	BEGIN
		IF (@cBioTipo = '8') BEGIN		-- TSI1
			DECLARE Rlexcldig_cur CURSOR FOR
				SELECT IFUNC, STATUS FROM RDIG103 
					WHERE END_IP = @cEndIp AND STATUS = '2'
					ORDER by IFUNC;

			OPEN Rlexcldig_cur
			FETCH next from Rlexcldig_cur into @cIcard, @STATUS
			WHILE (@@fetch_status != -1)
			begin
				update RDIG103 set STATUS = @cStat where current of Rlexcldig_cur 
				SET @nCont = @nCont+1

				fetch next from Rlexcldig_cur into @cIcard, @STATUS
			end
			close Rlexcldig_cur
			deallocate Rlexcldig_cur
		END
		
		ELSE
			--IF (@cBioTipo = '9') BEGIN		-- VIRDI
			IF (@cBioTipo != '0') BEGIN		-- VIRDI / OUTROS
				DECLARE Rlexcldig_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG104 
						WHERE END_IP = @cEndIp AND STATUS = '2'
						ORDER by IFUNC;

				OPEN Rlexcldig_cur
				FETCH next from Rlexcldig_cur into @cIcard, @STATUS
				WHILE (@@fetch_status != -1)
				begin
					update RDIG104 set STATUS = @cStat where current of Rlexcldig_cur 
					SET @nCont = @nCont+1

					fetch next from Rlexcldig_cur into @cIcard, @STATUS
				end
				close Rlexcldig_cur
				deallocate Rlexcldig_cur
			END
	END
	UPDATE RDIG102 SET STATUS = @cStat WHERE END_IP = @cEndIp;
	SET LOCK_TIMEOUT -1


	return @nCont	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlrhora_gerbiof')
	DROP PROCEDURE TELESSVR.sqlrhora_gerbiof;
GO

CREATE PROCEDURE TELESSVR.sqlrhora_gerbiof @EndIp CHAR(15), @nTipo INT
AS

DECLARE @xret int
DECLARE @cHoraIni CHAR(8),	@cHoraFim CHAR(8),	@cHoraCor CHAR(8)		-- 'hh:mi:ss'


BEGIN
	
	SET @xret = 0
	
	
	IF EXISTS (select * from REPAUTOBIOF where END_IP = @EndIp)
	begin
		IF (@nTipo = 2) 		-- PROCURA POR FAIXA DE EXECUÇÃO DE GERENCIAMENTO DE BIOMETRIA
			SELECT @cHoraIni = INICIO_GERBIO,  @cHoraFim = FINAL_GERBIO 
				FROM REPAUTOBIOF 
				WHERE END_IP = @EndIp 

		ELSE
			SELECT @cHoraIni = INICIO_GERFUN,  @cHoraFim = FINAL_GERFUN 
				FROM REPAUTOBIOF 
				WHERE END_IP = @EndIp 
		
		
		--SELECT CONVERT(VARCHAR(8),GETDATE(),114) AS '114'
		--SELECT CONVERT(@cHoraCor,GETDATE(),114)
		SET @cHoraCor = CONVERT(CHAR(8),GETDATE(),114)
		
		IF (@cHoraIni < @cHoraFim) begin 
			IF ((@cHoraCor >= @cHoraIni) AND (@cHoraCor <= @cHoraFim)) 
				SET @xret = 1;
		end
		ELSE begin
			IF (@cHoraCor >= @cHoraIni) 
				SET @xret = 1;
			ELSE
				IF (@cHoraCor <= @cHoraFim) 
					SET @xret = 1;
		end
	end
	ELSE
		SET @xret = 1
	
			
	select @xret
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqller_RautoLoadDigit2')
	DROP PROCEDURE TELESSVR.sqller_RautoLoadDigit2;
GO

CREATE PROCEDURE TELESSVR.sqller_RautoLoadDigit2  @cEndIp VARCHAR(15) 
AS

declare @nCont smallint
declare @nBloco smallint
declare @nTotal smallint
declare @cStatus char(1)
declare @cBio_Tipo char(1)
declare @ICARD varchar(12)
declare @STATUS char(1)
declare @cListaId VARCHAR(250)
declare @cListaId_1 VARCHAR(250)
declare @cListaId_2 VARCHAR(250)
declare @cListaId_3 VARCHAR(250)
declare @cListaId_4 VARCHAR(250)
declare @cListaId_5 VARCHAR(250)

	SET @nCont = 0
	SET @nBloco = 1
	SET @nTotal = 0
	
	SET @cListaId = ''
	SET @cListaId_1 = ''
	SET @cListaId_2 = ''
	SET @cListaId_3 = ''
	SET @cListaId_4 = ''
	SET @cListaId_5 = ''

	SET LOCK_TIMEOUT 5000

	-- procura pelo equipamento
	IF EXISTS (SELECT * FROM RDIG002  WHERE END_IP = @cEndIp and STATUS = '1')
	BEGIN
	    SELECT @cStatus = STATUS, @cBio_Tipo = BIO_TIPO
			FROM RDIG002
			WHERE END_IP = @cEndIp

		IF (@cStatus = '1') BEGIN
			-- SAGEM
			IF (@cBio_Tipo = '6' or @cBio_Tipo = '7') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG001 
						WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				while (@@fetch_status != -1) and (@nTotal < 24) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE RDIG001 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					if (@nCont >= 5) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			-- TSI1
			IF (@cBio_Tipo = '8') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG003 
						WHERE (END_IP = @cEndIp) and (STATUS != '0') and (STATUS != '2')
					ORDER by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				while (@@fetch_status != -1) and (@nTotal < 24) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE RDIG003 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					if (@nCont >= 5) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			-- VIRDI E OUTROS
			--IF (@cBio_Tipo = '9') BEGIN		
			IF (@cBio_Tipo != '0') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG004 
						WHERE (END_IP = @cEndIp) and (STATUS != '0') and (STATUS != '2')
					ORDER by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				while (@@fetch_status != -1) and (@nTotal < 24) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE RDIG004 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					if (@nCont >= 5) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			IF ((@nCont > 0) AND (@nCont < 5))
				if (@nBloco = 1) 
					set @cListaId_1 = @cListaId
				else if (@nBloco = 2) 
					set @cListaId_2 = @cListaId
				else if (@nBloco = 3) 
					set @cListaId_3 = @cListaId
				else if (@nBloco = 4) 
					set @cListaId_4 = @cListaId
				else if (@nBloco = 5) 
					set @cListaId_5 = @cListaId

			IF (@nTotal = 0) 
				UPDATE RDIG002 SET STATUS = '0' WHERE END_IP = @cEndIp;
			ELSE 
				UPDATE RDIG002 SET 
					STATUS = '2',
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;
		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaId_1 as cListaId_1,
		   @cListaId_2 as cListaId_2,
		   @cListaId_3 as cListaId_3,
		   @cListaId_4 as cListaId_4,
		   @cListaId_5 as cListaId_5
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO
	
IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqller_RautoExclDigit2')
	DROP PROCEDURE TELESSVR.sqller_RautoExclDigit2;
GO

CREATE PROCEDURE TELESSVR.sqller_RautoExclDigit2 @cEndIp VARCHAR(15) 
AS

declare @nCont smallint
declare @nBloco smallint
declare @nTotal smallint
declare @cStatus char(1)
declare @cBio_Tipo char(1)
declare @ICARD varchar(12)
declare @STATUS char(1)
declare @cListaId VARCHAR(250)
declare @cListaId_1 VARCHAR(250)
declare @cListaId_2 VARCHAR(250)
declare @cListaId_3 VARCHAR(250)
declare @cListaId_4 VARCHAR(250)
declare @cListaId_5 VARCHAR(250)

	SET @nCont = 0
	SET @nBloco = 1
	SET @nTotal = 0
	
	SET @cListaId = ''
	SET @cListaId_1 = ''
	SET @cListaId_2 = ''
	SET @cListaId_3 = ''
	SET @cListaId_4 = ''
	SET @cListaId_5 = ''

	SET LOCK_TIMEOUT 2000

	-- procura pelo equipamento
	IF EXISTS (SELECT * FROM RDIG102  WHERE END_IP = @cEndIp AND STATUS = '1')
	BEGIN
	    SELECT @cStatus = STATUS, @cBio_Tipo = BIO_TIPO
			FROM RDIG102 NOLOCK
			WHERE END_IP = @cEndIp

		IF (@cStatus = '1') BEGIN
			-- SAGEM
			IF (@cBio_Tipo = '6' or @cBio_Tipo = '7') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG101 
						WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				while (@@fetch_status != -1) and (@nTotal < 32) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE RDIG101 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					if (@nCont > 8) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			-- TSI1	
			ELSE IF (@cBio_Tipo = '8') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG103 
						WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				while (@@fetch_status != -1) and (@nTotal < 32) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE RDIG103 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					if (@nCont > 8) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			-- VIRDI	
			ELSE 
				--IF (@cBio_Tipo = '9') BEGIN		
				IF (@cBio_Tipo != '0') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG104 
						WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				while (@@fetch_status != -1) and (@nTotal < 32) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE RDIG104 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					if (@nCont > 8) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END

			IF ((@nCont > 0) AND (@nCont <= 8))
				if (@nBloco = 1) 
					set @cListaId_1 = @cListaId
				else if (@nBloco = 2) 
					set @cListaId_2 = @cListaId
				else if (@nBloco = 3) 
					set @cListaId_3 = @cListaId
				else if (@nBloco = 4) 
					set @cListaId_4 = @cListaId
				else if (@nBloco = 5) 
					set @cListaId_5 = @cListaId

			IF (@nTotal = 0) 
				UPDATE RDIG102 SET STATUS = '0' WHERE END_IP = @cEndIp;
			ELSE 
				UPDATE RDIG102 SET 
					STATUS = '2',
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;

		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaId_1 as cListaId_1,
		   @cListaId_2 as cListaId_2,
		   @cListaId_3 as cListaId_3,
		   @cListaId_4 as cListaId_4,
		   @cListaId_5 as cListaId_5
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO
	
IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlload_rlistadig2')
	DROP PROCEDURE TELESSVR.sqlload_rlistadig2;
GO

CREATE PROCEDURE TELESSVR.sqlload_rlistadig2 @cMatric CHAR(12), @cEndIp CHAR(15), @cNumRep CHAR(25), @cStatus CHAR(1) , @cErro CHAR(1)
AS

DECLARE @Ret smallint, @cBioTipo CHAR(1), @ERR INT  , @cAux char(12)

	SET @Ret = 0
	SET LOCK_TIMEOUT 2000
	SET @cBioTipo = '0'
	
	SELECT @cBioTipo = BIO_TIPO FROM RDIG002
		WHERE END_IP = @cEndIp;
		
	if (@@ROWCOUNT = 1) begin
		-- (SAGEM)
		IF (@cBioTipo = '6' or @cBioTipo = '7') 		
			UPDATE RDIG001 SET STATUS = @cStatus 
				where IFUNC = @cMatric and
					  END_IP = @cEndIp;

		--  (TSI1)
		ELSE IF (@cBioTipo = '8')  
			UPDATE RDIG003 SET STATUS = @cStatus 				  
				where IFUNC = @cMatric and
					  END_IP = @cEndIp;

		--  (VIRDI) E OUTROS
		--ELSE IF (@cBioTipo = '9')  
		ELSE IF (@cBioTipo != '0')  
			UPDATE RDIG004 SET STATUS = @cStatus 				  
				where IFUNC = @cMatric and
					  END_IP = @cEndIp;

	end

	UPDATE RDIG002 SET DATA_LOAD = getdate() where END_IP = @cEndIp


	-- NOVO
	IF (@cStatus = '0') 
		INSERT INTO HISTREPDIG (IFUNC, END_IP, BIO_TIPO, INSEXC, MODO) VALUES (@cMatric, @cEndIp, @cBioTipo, 'I', 'A')	-- TIPO:'I'= INCLUSAO, 'E'=EXCLUSAO; MODO:'A'=AUTOMATICO, 'M'=MANUAL
	ELSE
		IF (@cStatus = '4')  	-- ERRO DE CARGA (devido a memoria cheiia, minucia errada: que nao adianta enviar a digital novamente ao equipamento ), ou nao implementado
			INSERT INTO REPDIGLOAD001 (END_IP, REP, IFUNC, BIO_TIPO, NERRO) VALUES (@cEndIp, @cNumRep, @cMatric, @cBioTipo, @cErro);

	-- FIM NOVO



	SET LOCK_TIMEOUT -1
	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlrgrv_logerros')
	DROP PROCEDURE TELESSVR.sqlrgrv_logerros;
GO

CREATE PROCEDURE TELESSVR.sqlrgrv_logerros @EndIp  VARCHAR(15), @NumRep CHAR(17), @cTipo CHAR(1), @Reg1 CHAR(250), @Reg2 CHAR(250), @Reg3 CHAR(250), @Reg4 CHAR(250), @Reg5 CHAR(250), @Reg6 CHAR(250), @Reg7 CHAR(250), @Reg8 CHAR(250)
AS
	
DECLARE @nRetorno smallint
DECLARE @TotalReg as CHAR(2000)

	SET @nRetorno = '0'
	SET @TotalReg = @Reg1+coalesce(@Reg2,'')+coalesce(@Reg3,'')+coalesce(@Reg4,'')+coalesce(@Reg5,'')+coalesce(@Reg6,'')+coalesce(@Reg7,'')+coalesce(@Reg8,'')
		
	IF (@cTipo = '0')
	BEGIN
		DELETE REPINFO002 WHERE REP = @NumRep

		-- VERIFICA SE ERRO 
		IF (@@ERROR <> 0)
			SET @nRetorno = 0
	END
	
	ELSE
	BEGIN
		INSERT INTO REPINFO002 (END_IP, REP, DATINFO, INFOLOG) VALUES (@EndIp, @NumRep, getdate(), @TotalReg)

		-- VERIFICA SE ERRO 
		IF (@@ERROR <> 0)
			SET @nRetorno = -1
	END
	
	return @nRetorno
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlatualiza_veri_digital_tcp')
	DROP PROCEDURE TELESSVR.sqlatualiza_veri_digital_tcp;
GO

CREATE PROCEDURE TELESSVR.sqlatualiza_veri_digital_tcp @matric char(12), @templ1 char(160), @templ2 char(160), 
@templ3 char(160), @templ4 char(160), @nTipo char(1), @cNumDedo char(2), @cNivel char(1), @templ5 char(56)
AS

DECLARE @cAuxMat char(15), @nRetorno int, @cAux char(1)
BEGIN

        IF (@nTipo = '0')
	BEGIN
	    UPDATE CONTDIG_VERI SET TEMPL_TIT1 = @templ1,
			       TEMPL_TIT2 = @templ2,
			       TEMPL_TIT3 = @templ3,
			       TEMPL_TIT4 = @templ4,
              		       NIVEL = @cNivel,
			       NUM_DEDO_PAD = @cNumDedo,
			       TEMPL_TIT5 = @templ5
	    WHERE ICARD = @matric
	END
	ELSE
	BEGIN
	    UPDATE CONTDIG_VERI SET TEMPL_ALT1 = @templ1,
			       TEMPL_ALT2 = @templ2,
			       TEMPL_ALT3 = @templ3,
			       TEMPL_ALT4 = @templ4,
              		       NIVEL = @cNivel,
			       NUM_DEDO_ALT = @cNumDedo,
			       TEMPL_ALT5 = @templ5
	    WHERE ICARD = @matric
	END

	if (@@ROWCOUNT = 0)
	BEGIN
	    IF (@nTipo= '0')
	    BEGIN
		INSERT INTO CONTDIG_VERI (ICARD, TEMPL_TIT1, TEMPL_TIT2, TEMPL_TIT3, TEMPL_TIT4,
			      NIVEL, NUM_DEDO_PAD,TEMPL_TIT5) 
		VALUES (@matric, @templ1, @templ2, @templ3, @templ4, @cNivel, @cNumDedo,@templ5)
	    END
	    ELSE
	    BEGIN
		INSERT INTO CONTDIG_VERI (ICARD, TEMPL_ALT1, TEMPL_ALT2, TEMPL_ALT3, TEMPL_ALT4,
			      NIVEL, NUM_DEDO_ALT,TEMPL_ALT5) 
		VALUES (@matric, @templ1, @templ2, @templ3, @templ4, @cNivel, @cNumDedo,@templ5)
	    END

	    SET @nRetorno = 0
	END
	ELSE
	    SET @nRetorno = 1

    return @nRetorno
END
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlratu_outrosbios')
	DROP PROCEDURE TELESSVR.sqlratu_outrosbios;
GO

CREATE PROCEDURE TELESSVR.sqlratu_outrosbios @matric VARCHAR(12), @cBioTipo CHAR(1), @cTipo CHAR(1), @cTemplate VARCHAR(MAX)
AS
DECLARE  @nRetorno int
	

    set @nRetorno = 1
    IF NOT EXISTS (SELECT ICARD FROM CONTDIG_OUTROS WHERE ICARD = @matric and BIO_TIPO = @cBioTipo) BEGIN 			-- identificador  do biometrico 
		set @nRetorno = 0
	END
	
    IF (@nRetorno = 0) BEGIN		-- nao ha nenhum cadastro do ICARD+BIOTIPO
    	IF (@cTipo  = '0')		-- padrao
				INSERT INTO CONTDIG_OUTROS (ICARD, BIO_TIPO, DIGITAL_PAD, STATUS, STATUS_REP)  
					VALUES (@matric, @cBioTipo, @cTemplate, '1', '1')
		ELSE IF (@cTipo  = '1')
				INSERT INTO CONTDIG_OUTROS (ICARD, BIO_TIPO, DIGITAL_ALT, STATUS, STATUS_REP)  
					VALUES (@matric, @cBioTipo, @cTemplate,'1', '1')
		ELSE IF (@cTipo  = '2')
				INSERT INTO CONTDIG_OUTROS (ICARD, BIO_TIPO, DIGITAL_COA, STATUS, STATUS_REP)  
					VALUES (@matric, @cBioTipo, @cTemplate,'1', '1')

		IF (@@ROWCOUNT = 0)
			set @nRetorno = 0
	END
	
	ELSE begin
    	IF (@cTipo  = '0') 
				UPDATE CONTDIG_OUTROS 
					SET DIGITAL_PAD = @cTemplate, 
					Status = '1',
					Status_Rep = '1' 
				WHERE Icard = @matric AND 				-- matricula
			  	BIO_TIPO = @cBioTipo; 					-- identificador  do biometrico 
		ELSE IF (@cTipo  = '1')
				UPDATE CONTDIG_OUTROS 
					SET DIGITAL_ALT = @cTemplate, 
					Status = '1',
					Status_Rep = '1' 
				WHERE Icard = @matric AND 				-- matricula
				BIO_TIPO = @cBioTipo; 					-- identificador  do biometrico 
		ELSE IF (@cTipo  = '2')
				UPDATE CONTDIG_OUTROS 
					SET DIGITAL_COA = @cTemplate, 
					Status = '1',
					Status_Rep = '1' 
				WHERE Icard = @matric AND 				-- matricula
			  	BIO_TIPO = @cBioTipo; 					-- identificador  do biometrico 
		IF (@@ROWCOUNT = 0)
			set @nRetorno = 0
	end
	
    return @nRetorno


SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlrcon_sagem_digital2')
	DROP PROCEDURE TELESSVR.sqlrcon_sagem_digital2;
GO

CREATE PROCEDURE TELESSVR.sqlrcon_sagem_digital2 @cMatric char(12), @cEndIp char(15), @cNumRep char(17),
@cTempl_tit1tot CHAR(160) OUTPUT, @cTempl_tit2tot CHAR(160) OUTPUT, 
@cTempl_tit3tot CHAR(160) OUTPUT, @cTempl_tit4tot CHAR(160) OUTPUT, 
@cTempl_Alt1tot CHAR(160) OUTPUT, @cTempl_Alt2tot CHAR(160) OUTPUT, 
@cTempl_Alt3tot CHAR(160) OUTPUT, @cTempl_Alt4tot CHAR(160) OUTPUT,
@cNivel CHAR(1) OUTPUT, @cTempl_tit5tot CHAR(160) OUTPUT, @cTempl_Alt5tot CHAR(160) OUTPUT,
@cTempl_tit6tot CHAR(26) OUTPUT, @cTempl_Alt6tot CHAR(26) OUTPUT


AS
DECLARE @Retfun int, @Pad int, @Alt int,@cTempl_tit4aux AS CHAR(32), @cTempl_Alt4aux AS CHAR(32), @cVDigit char(1)


BEGIN
--	select @Retfun = -1
	select @Retfun = 3
	select @cTempl_tit1tot = NULL
	select @cTempl_tit2tot = NULL
	select @cTempl_tit3tot = NULL
	select @cTempl_tit4tot = NULL
	select @cTempl_tit4aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	select @cTempl_Alt1tot = NULL
	select @cTempl_Alt2tot = NULL
	select @cTempl_Alt3tot = NULL
	select @cTempl_Alt4tot = NULL
	select @cTempl_Alt4aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	select @cNivel = NULL


		-- procura por Templates da matricula
		IF EXISTS (SELECT * FROM CONTDIG_SAGEM  WHERE ICARD = @cMatric)
		begin
			SELECT @cTempl_tit1tot = TEMPL_TIT1,
			   @cTempl_tit2tot = TEMPL_TIT2,
			   @cTempl_tit3tot = TEMPL_TIT3,
			   @cTempl_tit4aux = TEMPL_TIT4,
			   @cTempl_Alt1tot = TEMPL_ALT1,
			   @cTempl_Alt2tot = TEMPL_ALT2,
			   @cTempl_Alt3tot = TEMPL_ALT3,
			   @cTempl_Alt4aux = TEMPL_ALT4,
			   @cNivel = NIVEL
			FROM CONTDIG_SAGEM
			WHERE ICARD = @cMatric
			select @Pad = 1    -- assume que tem template padrao
			select @Alt = 1    -- assume que tem template alternativo
			if ((@cTempl_tit1tot is Null) or (@cTempl_tit2tot is Null) or 
				(@cTempl_tit3tot is Null) or (@cTempl_tit4aux is Null) or
				(datalength(@cTempl_tit1tot) < 160) or (datalength(@cTempl_tit2tot) < 160) or
				(datalength(@cTempl_tit3tot) < 160) or (datalength(@cTempl_tit4aux) < 32)) 
			begin
				SELECT @Pad = 0
			end 

			IF (datalength(@cTempl_tit4aux) = 32) BEGIN
				SET @cTempl_tit4tot = @cTempl_tit4aux + REPLICATE('0',160-LEN(@cTempl_tit4aux) )
				SET @cTempl_tit5tot = REPLICATE('0', 160)
				SET @cTempl_tit6tot = REPLICATE('0', 26)
			END

			if ((@cTempl_Alt1tot is Null) or (@cTempl_Alt2tot is Null) or
				(@cTempl_Alt3tot is Null) or (@cTempl_Alt4aux is Null) or
				(datalength(@cTempl_Alt1tot) < 160) or (datalength(@cTempl_Alt2tot) < 160) or
				(datalength(@cTempl_Alt3tot) < 160) or (datalength(@cTempl_Alt4aux) < 32)) 
			begin 
				SELECT @Alt = 0
			end

			IF (datalength(@cTempl_Alt4aux) = 32) BEGIN
				SET @cTempl_Alt4tot = @cTempl_Alt4aux + REPLICATE('0',160-LEN(@cTempl_Alt4aux) )
				SET @cTempl_Alt5tot = REPLICATE('0', 160)
				SET @cTempl_Alt6tot = REPLICATE('0', 26)
			END
	    
		end
		ELSE BEGIN
			
				SET	@Pad = 0;
				SET @Alt = 0;
		END
		
		if (@Pad = 1) 
		begin
			if (@Alt = 1) 
				SET @Retfun = 0   -- tem padrao e tem alternativo
			else 
				SET @Retfun = 1   -- tem padrao e nao tem alternativo
		end
		ELSE
		begin
			if (@Alt = 1) 
				SET @Retfun = 2   -- nao tem padrao e tem alternativo
			else 
				SET @Retfun = 3   -- nao tem padrao e nao tem alternativo	
		end

	    
	    IF ((@Retfun = -1) or (@Retfun = 3))		-- problema ou digital nao cadastrado
	    	INSERT INTO REPDIGLOAD001 (END_IP, REP, IFUNC, BIO_TIPO, DATA_INS) 
				VALUES (@cEndIp, @cNumRep, @cMatric, '6', getdate());

	    
	return (@Retfun)
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlrcon_tsi1_digital2')
	DROP PROCEDURE TELESSVR.sqlrcon_tsi1_digital2;
GO

CREATE PROCEDURE TELESSVR.sqlrcon_tsi1_digital2 @cMatric char(12), @cEndIp char(15), @cNumRep char(17),
@cTempl_tit1tot CHAR(160) OUTPUT, @cTempl_tit2tot CHAR(160) OUTPUT, 
@cTempl_tit3tot CHAR(160) OUTPUT, @cTempl_tit4tot CHAR(160) OUTPUT, 
@cTempl_Alt1tot CHAR(160) OUTPUT, @cTempl_Alt2tot CHAR(160) OUTPUT, 
@cTempl_Alt3tot CHAR(160) OUTPUT, @cTempl_Alt4tot CHAR(160) OUTPUT,
@cNivel CHAR(1) OUTPUT, @cTempl_tit5tot CHAR(160) OUTPUT, @cTempl_Alt5tot CHAR(160) OUTPUT,
@cTempl_tit6tot CHAR(26) OUTPUT, @cTempl_Alt6tot CHAR(26) OUTPUT
AS
DECLARE @Retfun int, @Pad int, @Alt int,@cTempl_tit5aux AS CHAR(128), @cTempl_Alt5aux AS CHAR(128), @cVDigit char(1)

BEGIN
	select @Retfun = 3
	select @cTempl_tit1tot = NULL
	select @cTempl_tit2tot = NULL
	select @cTempl_tit3tot = NULL
	select @cTempl_tit4tot = NULL
	select @cTempl_tit5aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	select @cTempl_Alt1tot = NULL
	select @cTempl_Alt2tot = NULL
	select @cTempl_Alt3tot = NULL
	select @cTempl_Alt4tot = NULL
	select @cTempl_Alt5aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	select @cNivel = NULL

	-- procura por Templates da matricula
	IF EXISTS (SELECT * FROM CONTDIG_TSI1 WHERE ICARD = @cMatric)
	begin
		SELECT @cTempl_tit1tot = TEMPL_TIT1,
		   @cTempl_tit2tot = TEMPL_TIT2,
		   @cTempl_tit3tot = TEMPL_TIT3,
		   @cTempl_tit4tot = TEMPL_TIT4,
		   @cTempl_tit5aux = TEMPL_TIT5,
		   @cTempl_Alt1tot = TEMPL_ALT1,
		   @cTempl_Alt2tot = TEMPL_ALT2,
		   @cTempl_Alt3tot = TEMPL_ALT3,
		   @cTempl_Alt4tot = TEMPL_ALT4,
		   @cTempl_Alt5aux = TEMPL_ALT5,
		   @cNivel = NIVEL
		FROM CONTDIG_TSI1
		WHERE ICARD = @cMatric
		select @Pad = 1    -- assume que tem template padrao
		select @Alt = 1    -- assume que tem template alternativo
		if ((@cTempl_tit1tot is Null) or (@cTempl_tit2tot is Null) or 
			(@cTempl_tit3tot is Null) or (@cTempl_tit4tot is Null) or 
			(@cTempl_tit5aux is Null) or
			(datalength(@cTempl_tit1tot) < 160) or (datalength(@cTempl_tit2tot) < 160) or
			(datalength(@cTempl_tit3tot) < 160) or (datalength(@cTempl_tit4tot) < 160) or 
			(datalength(@cTempl_tit5aux) < 128)) 
		begin
			SELECT @Pad = 0
		end 

		IF (datalength(@cTempl_tit5aux) = 128) BEGIN
			SET @cTempl_tit5tot = @cTempl_tit5aux + REPLICATE('0',160-LEN(@cTempl_tit5aux) )
			SET @cTempl_tit6tot = REPLICATE('0', 26)
		END

		if ((@cTempl_Alt1tot is Null) or (@cTempl_Alt2tot is Null) or
			(@cTempl_Alt3tot is Null) or (@cTempl_Alt4tot is Null) or 
			(@cTempl_Alt5aux is Null) or
			(datalength(@cTempl_Alt1tot) < 160) or (datalength(@cTempl_Alt2tot) < 160) or
			(datalength(@cTempl_Alt3tot) < 160) or (datalength(@cTempl_Alt4tot) < 160) or 
			(datalength(@cTempl_Alt5aux) < 128)) 
		begin 
			SELECT @Alt = 0
		end

		IF (datalength(@cTempl_Alt5aux) = 128) BEGIN
			SET @cTempl_Alt5tot = @cTempl_Alt5aux + REPLICATE('0',160-LEN(@cTempl_Alt5aux) )
			SET @cTempl_Alt6tot = REPLICATE('0', 26)
		END
		
		if (@Pad = 1) 
		begin
			if (@Alt = 1) 
				SET @Retfun = 0   -- tem padrao e tem alternativo
			else 
				SET @Retfun = 1   -- tem padrao e nao tem alternativo
		end
		ELSE
		begin
			if (@Alt = 1) 
				SET @Retfun = 2   -- nao tem padrao e tem alternativo
			else 
				SET @Retfun = 3   -- nao tem padrao e nao tem alternativo	
		end
	end

    IF (@Retfun = 3)		-- digital nao cadastrado
    	INSERT INTO REPDIGLOAD001 (END_IP, REP, IFUNC, BIO_TIPO, DATA_INS) 
			VALUES (@cEndIp, @cNumRep, @cMatric, '8', getdate());


	return (@Retfun)
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlrcon_coacao_omokx')
	DROP PROCEDURE TELESSVR.sqlrcon_coacao_omokx;
GO

CREATE PROCEDURE TELESSVR.sqlrcon_coacao_omokx @cMatric char(12),
@cTempl_Coa1tot CHAR(160) OUTPUT, @cTempl_Coa2tot CHAR(160) OUTPUT, 
@cTempl_Coa3tot CHAR(160) OUTPUT, @cTempl_Coa4tot CHAR(160) OUTPUT, 
@cTempl_Coa5tot CHAR(160) OUTPUT, @cTempl_Coa6tot CHAR(160) OUTPUT 

AS
DECLARE @RetFun int, @Coa int
BEGIN
	set @RetFun = 1
	set @Coa = 1
	select @cTempl_Coa1tot = NULL
	select @cTempl_Coa2tot = NULL
	select @cTempl_Coa3tot = NULL
	select @cTempl_Coa4tot = NULL
	select @cTempl_Coa5tot = NULL
	select @cTempl_Coa6tot = NULL
	
	-- procura por Templates da matricula
	IF EXISTS (SELECT * FROM CONTDIG_OMOK WITH (Index = CONTDIG_OMOK_IND1) WHERE ICARD = @cMatric)
	begin
	    SELECT @cTempl_Coa1tot = TEMPL_COA1,
		   @cTempl_Coa2tot = TEMPL_COA2,
		   @cTempl_Coa3tot = TEMPL_COA3,
		   @cTempl_Coa4tot = TEMPL_COA4,
		   @cTempl_Coa5tot = TEMPL_COA5,
		   @cTempl_Coa6tot = TEMPL_COA6
		FROM CONTDIG_OMOK
		WHERE ICARD = @cMatric

	    if ((@cTempl_Coa1tot is Null) or (@cTempl_Coa2tot is Null) or 
			(@cTempl_Coa3tot is Null) or (@cTempl_Coa4tot is Null) or
			(@cTempl_Coa5tot is Null) or (@cTempl_Coa6tot is Null) or 
			(datalength(@cTempl_Coa1tot) < 160) or (datalength(@cTempl_Coa2tot) < 160) or
			(datalength(@cTempl_Coa3tot) < 160) or (datalength(@cTempl_Coa4tot) < 160) or
			(datalength(@cTempl_Coa5tot) < 160) or (datalength(@cTempl_Coa6tot) < 26)) 
	    begin
			SET @Coa = 0
	    end 
	end
	IF (@Coa = 0) 
	begin
		Set @RetFun = 0
	end
	return (@RetFun)
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlrcon_coacao_sagemx')
	DROP PROCEDURE TELESSVR.sqlrcon_coacao_sagemx;
GO

CREATE PROCEDURE TELESSVR.sqlrcon_coacao_sagemx @cMatric char(12),
@cTempl_Coa1tot CHAR(160) OUTPUT, @cTempl_Coa2tot CHAR(160) OUTPUT, 
@cTempl_Coa3tot CHAR(160) OUTPUT, @cTempl_Coa4tot CHAR(160) OUTPUT, 
@cTempl_Coa5tot CHAR(160) OUTPUT, @cTempl_Coa6tot CHAR(160) OUTPUT 

AS
DECLARE @RetFun int, @Coa int, @cTempl_Coa4aux AS CHAR(32)
BEGIN
	set @RetFun = 1
	set @Coa = 1
	select @cTempl_Coa1tot = NULL
	select @cTempl_Coa2tot = NULL
	select @cTempl_Coa3tot = NULL
	select @cTempl_Coa4tot = NULL
	select @cTempl_Coa4aux = NULL
	select @cTempl_Coa5tot = NULL
	select @cTempl_Coa6tot = NULL
	
	-- procura por Templates da matricula
	IF EXISTS (SELECT * FROM CONTDIG_SAGEM WITH (Index = CONTDIG_SAGEM_IND1) WHERE ICARD = @cMatric)
	begin
	    SELECT @cTempl_Coa1tot = TEMPL_COA1,
		   @cTempl_Coa2tot = TEMPL_COA2,
		   @cTempl_Coa3tot = TEMPL_COA3,
		   @cTempl_Coa4aux = TEMPL_COA4
		FROM CONTDIG_SAGEM
		WHERE ICARD = @cMatric

	    IF ((@cTempl_Coa1tot is Null) or (@cTempl_Coa2tot is Null) or 
			(@cTempl_Coa3tot is Null) or (@cTempl_Coa4tot is Null) or
			(datalength(@cTempl_Coa1tot) < 160) or (datalength(@cTempl_Coa2tot) < 160) or
			(datalength(@cTempl_Coa3tot) < 160) or (datalength(@cTempl_Coa4aux) < 32))
			
			SET @Coa = 0
	    else 
	    begin
			SET @cTempl_Coa4tot = @cTempl_Coa4aux + REPLICATE('0',160-LEN(@cTempl_Coa4aux) )
			SET @cTempl_Coa5tot = REPLICATE('0', 160)
			SET @cTempl_Coa6tot = REPLICATE('0', 26)
	    end
	END

	IF (@Coa = 0) 
	begin
		Set @RetFun = 0
	end
	return (@RetFun)
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlrcon_coacao_tsi1')
	DROP PROCEDURE TELESSVR.sqlrcon_coacao_tsi1;
GO

CREATE PROCEDURE TELESSVR.sqlrcon_coacao_tsi1 @cMatric char(12),
@cTempl_Coa1tot CHAR(160) OUTPUT, @cTempl_Coa2tot CHAR(160) OUTPUT, 
@cTempl_Coa3tot CHAR(160) OUTPUT, @cTempl_Coa4tot CHAR(160) OUTPUT, 
@cTempl_Coa5tot CHAR(160) OUTPUT, @cTempl_Coa6tot CHAR(160) OUTPUT 

AS
DECLARE @RetFun int, @Coa int, @cTempl_Coa5aux AS CHAR(128)
BEGIN
	set @RetFun = 1
	set @Coa = 1
	select @cTempl_Coa1tot = NULL
	select @cTempl_Coa2tot = NULL
	select @cTempl_Coa3tot = NULL
	select @cTempl_Coa4tot = NULL
	select @cTempl_Coa5tot = NULL
	select @cTempl_Coa5aux = NULL
	select @cTempl_Coa6tot = NULL
	
	-- procura por Templates da matricula
	IF EXISTS (SELECT * FROM CONTDIG_TSI1 WHERE ICARD = @cMatric)
	begin
	    SELECT @cTempl_Coa1tot = TEMPL_COA1,
		   @cTempl_Coa2tot = TEMPL_COA2,
		   @cTempl_Coa3tot = TEMPL_COA3,
		   @cTempl_Coa4tot = TEMPL_COA4,
		   @cTempl_Coa5aux = TEMPL_COA5
		FROM CONTDIG_TSI1
		WHERE ICARD = @cMatric

	    IF ((@cTempl_Coa1tot is Null) or (@cTempl_Coa2tot is Null) or 
			(@cTempl_Coa3tot is Null) or (@cTempl_Coa4tot is Null) or 
			(@cTempl_Coa5aux is Null) or
			(datalength(@cTempl_Coa1tot) < 160) or (datalength(@cTempl_Coa2tot) < 160) or
			(datalength(@cTempl_Coa3tot) < 160) or (datalength(@cTempl_Coa4tot) < 160) or 
			(datalength(@cTempl_Coa5aux) < 128))
			SET @Coa = 0
	    else 
	    begin
			SET @cTempl_Coa5tot = @cTempl_Coa5aux + REPLICATE('0',160-LEN(@cTempl_Coa5aux) )
			SET @cTempl_Coa6tot = REPLICATE('0', 26)
	    end
	END

	IF (@Coa = 0) 
	begin
		Set @RetFun = 0
	end
	return (@RetFun)
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlproc_icardpis')
	DROP PROCEDURE TELESSVR.sqlproc_icardpis;
GO

CREATE PROCEDURE TELESSVR.sqlproc_icardpis @cEndIp CHAR(15), @cNumRep CHAR(17), @nTotal int, @cInicio CHAR(1), @cTipoCom CHAR(1), @cProcLisMat1 VARCHAR(250), @cProcLisMat2 VARCHAR(250), @cProcLisMat3 VARCHAR(250)
AS
DECLARE @cLisMat as VARCHAR(750)
DECLARE @Retfun int, @RetAux int, @nCont int, @nContOK int, @nPos int
DECLARE @cFunc VARCHAR(12), @cPis VARCHAR(12), @cNome VARCHAR(52)
DECLARE @cLisOKMat_1 VARCHAR(250), @cLisPis_1 VARCHAR(250) 
DECLARE @cLisOKMat_2 VARCHAR(250), @cLisPis_2 VARCHAR(250) 
DECLARE @cLisOKMat_3 VARCHAR(250), @cLisPis_3 VARCHAR(250) 
DECLARE @cErrMat VARCHAR(250)



	SET @nCont = 0
	SET @nContOK = 0

	SET @cLisOKMat_1 = ''		-- assume lista vazia de matriculas ok
	SET @cLisPis_1 = ''

	SET @cLisOKMat_2 = ''		-- assume lista vazia de matriculas ok
	SET @cLisPis_2 = ''

	SET @cLisOKMat_3 = ''		-- assume lista vazia de matriculas ok
	SET @cLisPis_3 = ''

	SET @cErrMat = NULL

	SET @cLisMat = @cProcLisMat1+coalesce(@cProcLisMat2,'')+coalesce(@cProcLisMat3,'')

	-- se é inicio de busca, limpa tabela auxiliar para o rep em questao no modo automatico ou manual
	IF (@cInicio = '1') begin 

		DELETE REPAUXEMPR WHERE END_IP = @cEndIp and TIPO = @cTipoCom;
		IF (@@ROWCOUNT = 0) begin
			SET @RetAux = 0
		END
	END 

	-- inicia a busca da lista de matriculas
	
	WHILE (@nCont < @nTotal) BEGIN
		SET @nPos = (@nCont * 12) + 1;
		SET @cFunc = SUBSTRING (@cLisMat, @nPos, 12);

		-- procura pelo nome e PIS contendo somente 12 digitos
		SELECT @cPis = PIS, @cNome = NOME  
			FROM REPEMPR002 WHERE (IFUNC = @cFunc) and (PIS not like '%[^0-9]%')		-- NAO DEVERA VIR PIS Q TENHA NAO DIGITO E MENOR Q 12 POSICOES

		IF (@@ROWCOUNT = 0) BEGIN
			INSERT INTO REPLOAD001 (END_IP, REP, IFUNC, DIA) 
				VALUES (@cEndIp, @cNumRep, @cFunc, getdate());
					
			if (@cErrMat IS null) BEGIN 
				SET @cErrMat = @cFunc 
			END
		END
		ELSE begin
			-- cada 20 matriculas, vai em 1 variavel, pois somente 20 matriculs (12 * 20) cabem em 250
			IF (@nContOK < 20) begin
				SET @cLisOKMat_1 = @cLisOKMat_1 + @cFunc ;
				SET @cLisPis_1 = @cLisPis_1 + @cPis ;
			end
			ELSE IF (@nContOK < 40) begin
				SET @cLisOKMat_2 = @cLisOKMat_2 + @cFunc ;
				SET @cLisPis_2 = @cLisPis_2 + @cPis ;
			end
			ELSE IF (@nContOK < 60) begin
				SET @cLisOKMat_3 = @cLisOKMat_3 + @cFunc ;
				SET @cLisPis_3 = @cLisPis_3 + @cPis ;
			end
			ELSE begin
				SET @nCont = @nTotal;
			end
			SET @nContOK = @nContOK + 1;
			
			-- guarda informacoes de Pis e Nome em tabela auxilar REPAUXEMPR
			UPDATE REPAUXEMPR SET NOME = @cNome, TIPO = @cTipoCom 
				WHERE END_IP = @cEndIp and TIPO = @cTipoCom and PIS = @cPis;

			IF (@@ROWCOUNT = 0) BEGIN
				INSERT INTO REPAUXEMPR (END_IP, PIS, NOME, TIPO) VALUES 
					(@cEndIp, @cPis, @cNome, @cTipoCom)		-- cTipoCom :'0' = carga via comando, 1 = automatico
			END
			
		END
		SET @nCont = @nCont+1;
	END	
	
			
	SELECT @nContOK,
		@cLisOKMat_1, @cLisPis_1, 
		@cLisOKMat_2, @cLisPis_2, 
		@cLisOKMat_3, @cLisPis_3, 
		@cErrMat

	GO
			

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlrnivel_biomet')
	DROP PROCEDURE TELESSVR.sqlrnivel_biomet;
GO

CREATE PROCEDURE TELESSVR.sqlrnivel_biomet @cEndIp CHAR(15), @cBlueb CHAR(2), @cCodin CHAR(2) AS

DECLARE @cBioTipo AS CHAR(1)

DECLARE @Retfun SMALLINT, @Pad int, @Alt int, @cNivel char(2)

	set @cBioTipo = '0'
	set @cNivel = '2'

	IF EXISTS (SELECT * FROM DAT07 WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
	begin
	   	SELECT @cBioTipo = BIO_TIPO 
		FROM DAT07
		WHERE END_IP = @cEndIp and 
			  BLUEB = @cBlueb and 
			  CODIN = @cCodin

		IF ((@cBioTipo = '4') or (@cBioTipo = '5')) begin
			IF EXISTS (SELECT *	FROM GEOMOK001 
						WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
				SELECT @cNivel = NIVEL
					FROM GEOMOK001
					WHERE END_IP = @cEndIp and 
						  BLUEB = @cBlueb and 
						  CODIN = @cCodin
			ELSE
				SET @cNivel = '4'
			end
		ELSE begin 
			IF ((@cBioTipo = '6') or (@cBioTipo = '7') or (@cBioTipo = '9')) begin
				IF EXISTS (SELECT *	FROM GEOMOK001 
							WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
					SELECT @cNivel = NIVELSAG
						FROM GEOMOK001
						WHERE END_IP = @cEndIp and 
							  BLUEB = @cBlueb and 
							  CODIN = @cCodin
				ELSE
					SET @cNivel = '5'
			end
			ELSE begin
				IF (@cBioTipo = '8') begin
					IF EXISTS (SELECT *	FROM GEOMOK001 
								WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
						SELECT @cNivel = NIVEL
							FROM GEOMOK001
							WHERE END_IP = @cEndIp and 
								  BLUEB = @cBlueb and 
								  CODIN = @cCodin
					ELSE
						SET @cNivel = '3'
				end
			end
		end
	end
	
	SET @Retfun = convert(int, @cNivel)
		
	SELECT @cBioTipo, @Retfun
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlrproc_outrosbios')
	DROP PROCEDURE TELESSVR.sqlrproc_outrosbios;
GO

CREATE PROCEDURE TELESSVR.sqlrproc_outrosbios @cMatric char(12), @cEndIp char(15), @cNumRep char(17),
@nQtdBytes INT, @cBioTipo CHAR(1)


AS
DECLARE @Retfun int, @Pad int, @Alt int, @nTotal int, @i int, @tam int, @pos int, @cVDigit char(1), @cDigPadChar VARCHAR(MAX), @cDigAltChar VARCHAR(MAX)

DECLARE @Ret INT, @nTotalPad INT , @nTotalAlt INT , @nTamPad INT, @nTamAlt INT
DECLARE @cDigPadBin VARBINARY(MAX), @cDigAltBin VARBINARY(MAX)



BEGIN
	SET @Retfun = 3
	SET @Pad = 0
	SET @Alt = 0
	
	SET @nTotalPad = 0
	SET @nTotalAlt = 0
	
	SET @nTamPad = 0
	SET @nTamAlt = 0

	-- PROCURA PELO PADRAO
	IF EXISTS (SELECT * FROM CONTDIG_OUTROS  WHERE ICARD = @cMatric AND BIO_TIPO = @cBioTipo)		
	begin
		SELECT @cDigPadBin = CONVERT(varbinary(max), DIGITAL_PAD, LEN(DIGITAL_PAD)), 
			   @cDigAltBin = CONVERT(varbinary(max), DIGITAL_ALT, LEN(DIGITAL_ALT)),
			   @nTamPad = LEN(DIGITAL_PAD),
			   @nTamAlt = LEN(DIGITAL_ALT)
			FROM CONTDIG_OUTROS  WHERE ICARD = @cMatric AND BIO_TIPO = @cBioTipo
		

		IF (@nTamPad IS NULL) 
			SET @nTotalPad = 0
		ELSE begin
			SET @nTotalPad = @nTamPad
			SET @Pad = 1
		end
		
		IF (@nTamAlt IS NULL) 
			SET @nTotalAlt = 0
		ELSE begin
			SET @nTotalAlt = @nTamAlt
			SET @Alt = 1				
		end
	end
	-- PREPARA RESULTADO	
	if (@Pad = 1) begin
	    if (@Alt = 1) 
			SET @Retfun = 0;   -- tem padrao e tem alternativo
		else 
			SET @Retfun = 1;   -- tem padrao e nao tem alternativo
	end 
	if (@Pad = 0) begin
	    if (@Alt = 1) 
			SET @Retfun = 2;   -- nao tem padrao e tem alternativo
		else 
			SET @Retfun = 3;   -- nao tem padrao e nao tem alternativo
	end
	
    IF (@Retfun = 3)		-- digital nao cadastrado
    	INSERT INTO REPDIGLOAD001 (END_IP, REP, IFUNC, BIO_TIPO, DATA_INS) 
			VALUES (@cEndIp, @cNumRep, @cMatric, '9', getdate());
	
	
	SELECT @Retfun, @cDigPadBin, @cDigAltBin, @nTotalPad, @nTotalAlt	
	    	
END
GO

-----------------------------------------------------------------------------------
-- CONEX ACESSO V.38.01.01 || CONEX ACESSO V.38.01.01 || CONEX ACESSO V.38.01.01 ||
-----------------------------------------------------------------------------------

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.TrgSitCont_U'))
	DROP TRIGGER TELESSVR.TrgSitCont_U;
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'CONTROLE_IND4')
    DROP INDEX TELESSVR.CONTROLE.CONTROLE_IND4;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'GRUPO')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN GRUPO CHAR(5) -- default '00000'
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'SUBNV')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN SUBNV CHAR(7) -- default '00     '
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'PLANTA')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN PLANTA CHAR(5) -- default '00000'
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'GRUPO1')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN GRUPO1 CHAR(5) -- default '00000'
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'GRUPO2')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN GRUPO2 CHAR(5) -- default '00000'
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'GRUPO3')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN GRUPO3 CHAR(5) -- default '00000'
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'GRUPO_SAB')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN GRUPO_SAB CHAR(5) -- default '00000'
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'GRUPO_DOM')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN GRUPO_DOM CHAR(5) -- default '00000'
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'GRUPO_FER')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN GRUPO_FER CHAR(5) -- default '00000'
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'CONTROLE_IND4')
    CREATE INDEX CONTROLE_IND4 ON TELESSVR.CONTROLE (GRUPO);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DAT07_IND3')
    DROP INDEX TELESSVR.DAT07.DAT07_IND3;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'DAT07' AND UPPER(COLUMN_NAME) = 'LACES')
	ALTER TABLE TELESSVR.DAT07 ALTER COLUMN LACES CHAR(5);
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'DAT07' AND UPPER(COLUMN_NAME) = 'PLANTA')
	ALTER TABLE TELESSVR.DAT07 ALTER COLUMN PLANTA CHAR(5) -- DEFAULT '00000'
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DAT07_IND3')
    CREATE INDEX DAT07_IND3 ON TELESSVR.DAT07 (LACES, PLANTA);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DAT08_IND1')
    DROP INDEX TELESSVR.DAT08.DAT08_IND1;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'DAT08' AND UPPER(COLUMN_NAME) = 'GRUPO')
	ALTER TABLE TELESSVR.DAT08 ALTER COLUMN GRUPO CHAR(5);
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'DAT08' AND UPPER(COLUMN_NAME) = 'LACES')
	ALTER TABLE TELESSVR.DAT08 ALTER COLUMN LACES CHAR(5);
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'DAT08' AND UPPER(COLUMN_NAME) = 'PLANTA')
	ALTER TABLE TELESSVR.DAT08 ALTER COLUMN PLANTA CHAR(5); -- DEFAULT '00000'  
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DAT08_IND1')
    CREATE UNIQUE INDEX DAT08_IND1 ON TELESSVR.DAT08 (GRUPO, LACES, PLANTA);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'MATNGRUPOS_IND1')
    DROP INDEX TELESSVR.MATNGRUPOS.MATNGRUPOS_IND1;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'MATNGRUPOS' AND UPPER(COLUMN_NAME) = 'GRUPO')
	ALTER TABLE TELESSVR.MATNGRUPOS ALTER COLUMN GRUPO CHAR(5) -- default '00000'
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'MATNGRUPOS')
    CREATE UNIQUE INDEX MATNGRUPOS_IND1 ON TELESSVR.MATNGRUPOS (ICARD, GRUPO, DIA_TIPO);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'FERIADO_IND1')
    DROP INDEX TELESSVR.FERIADO.FERIADO_IND1;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'FERIADO' AND UPPER(COLUMN_NAME) = 'PLANTA_FER')
	ALTER TABLE TELESSVR.FERIADO ALTER COLUMN PLANTA_FER CHAR(5); -- default '00000'
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'FERIADO_IND1')
    CREATE UNIQUE INDEX FERIADO_IND1 ON TELESSVR.FERIADO (DATA_FER, PLANTA_FER);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'CONTPLANTA_IND1')
    DROP INDEX TELESSVR.CONTPLANTA.CONTPLANTA_IND1;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTPLANTA' AND UPPER(COLUMN_NAME) = 'PLANTACESSO')
	ALTER TABLE TELESSVR.CONTPLANTA ALTER COLUMN PLANTACESSO CHAR(5); -- DEFAULT '00000'
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'CONTPLANTA_IND1')
    CREATE INDEX CONTPLANTA_IND1 ON TELESSVR.CONTPLANTA (ICARD, PLANTACESSO);
GO

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'MATNREFEIT')
BEGIN
	CREATE TABLE TELESSVR.MATNREFEIT (
		ICARD 		CHAR(12) 	NOT NULL,
		PLANTA   	CHAR(5) 	DEFAULT '00000' NOT NULL,	
		FX_REF      CHAR(8)  	DEFAULT'24002400'  NOT NULL,
		CRED_FXREF  CHAR(2)  	DEFAULT '00'  NOT NULL CONSTRAINT MATNREFEIT_ct1 CHECK (convert(int,CRED_FXREF) >= 0)
	)
	CREATE UNIQUE INDEX MATNREFEIT_IND1 ON TELESSVR.MATNREFEIT (ICARD, PLANTA, FX_REF)	
END

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'AUXMATNREFEIT')
BEGIN
	CREATE TABLE TELESSVR.AUXMATNREFEIT (
		ICARD 		CHAR(12) 	NOT NULL,
		PLANTA   	CHAR(5) 	DEFAULT '00000' NOT NULL,	
		ULTPAS_REF  CHAR(10) 	default '          ' -- DDMMYYHHMI (DATA/HORA DA ULTIMA PASSAGEM NO REFEITORIO)
	)
	CREATE UNIQUE INDEX AUXMATNREFEIT_IND1 ON TELESSVR.AUXMATNREFEIT (ICARD, PLANTA) 
END

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlconG3G5_ace_usuario')
	DROP PROCEDURE TELESSVR.sqlconG3G5_ace_usuario;
GO

CREATE PROCEDURE TELESSVR.sqlconG3G5_ace_usuario @cMatricNS char(22), @cInform char(20), @cTipTerm char(1), @Usuario char(15), @cOwner char(30), @cDataOcorr char(10), @cVisita char(12) AS
DECLARE	@cReg1 as varchar(250), @cReg2 as varchar(250), @cReg3 as varchar(250), 
		@cReg4 as varchar(250), @RetFun SMALLINT,
		@cReg5 as varchar(250), @cReg6 as varchar(250), @cReg7 as varchar(250), @cReg8 as varchar(250),
		@cReg9 as varchar(250), @cReg10 as varchar(250), @cReg11 as varchar(250)
DECLARE @ret int, @cUsuLock char(15), @cFxDiaEsp char(28), @cFxCred char(4), @Result int, @cMatBusca char(12)
DECLARE	@cIniHalm char(12), @cFimHalm char(12), @cIniIntj char(12), @cFimIntj char(12), @cFimAntD char(12)
DECLARE	@cIniHalmAux char(16), @cFimHalmAux char(16), @cIniIntjAux char(16), @cFimIntjAux char(16), @cFimAntDAux char(16)
DECLARE @dDataBD DATETIME, @dDataOcor DATETIME;
DECLARE @pos int
DECLARE @cModo char(1), @cFazLock char(1), @cDesbloqRev char(1),@cVerNumS char(1)
DECLARE @cVarAux char(12)
DECLARE @nGrest int, @nGrestEquip int, @nCont int
DECLARE @nArea int, @nAreaEquip int
DECLARE	@cEmFixa char(1), @AuxGr char(3), @AuxGr2 varchar(3);
DECLARE @cEscoltado char(12), @cEscolta char(12), @cEndIP char(15), @cTemEsc char(1), @cEhEscolta char(1), @cProcurado char(12), @cSentido CHAR(1)
DECLARE @nContArea int, @cFinalSentido CHAR(1), @AuxSentido CHAR(1), @nAuxArea int

DECLARE
        @cMatric   char(12),
        @cIcard    char(12),
        @cCPF	   char(11),
        @cNumSerial	   char(10),
		@cBloqBDCC char(1),
        --@cGrupo    char(3),
        @cCodig    char(6),
        @cTpFis    char(1),
        @cSitua    char(1),
        --@cSubNv    char(5),
        --@cPlanta   char(3),
        @cDataHora char(10),
        @cUltrs    char(25),
        @cDatIni   char(6),
        @cDatFim   char(6),
        @cTitular  char(12),
        @cFx_Flg   char(1), 
        @cFx_Dta   char(11), 
        @cFx_Alm   char(3),
        @cMensagem char(32), 
        @cDta_mens char(6),
        @cQtd_mens char(2),
        @cCred_Fx1 char(2), 
        @cCred_Fx2 char(2),
        @cCred_Fx3 char(2),
        @cCred_Fx4 char(2),
        @cCred_Fx5 char(2),
        @cCred_Fx6 char(2),
        @cFx1 char(8), 
        @cFx2 char(8), 
        @cFx3 char(8), 
        @cFx4 char(8), 
        @cFx5 char(8), 
        @cFx6 char(8), 
        @cUltPasR  char(10),
        --@cGrupo1   char(3),
        @cDatIniG1 char(10),
        @cDatFimG1 char(10),
        --@cGrupo2   char(3),
        @cDatIniG2 char(10),
        @cDatFimG2 char(10),
        --@cGrupo3   char(3),
        @cDatIniG3 char(10),
        @cDatFimG3 char(10),
        --@cGpoSab   char(3),
        --@cGpoDom   char(3),
        --@cGpoFer   char(3),
        @cAnti_D   char(1),
        @cBloq     char(1),
        @cVHora    char(1),
        @cVLocal   char(1),
        @cVValid   char(1),
        @cVAfast   char(1),
        @cVCred    char(1),
        @cVisEsp   char(1),
        @cVPonto   char(1),
        @cPonto    char(1),	
        @cVDigit   char(1),
      	@cTpoIntj  char(3), 
      	@cTolIntj  char(3), 
      	@cInterj   char(1),
      	@cTpoJorn  char(3), 
      	@cSaidaMax   char(1),
      	@cTipoDoc	char(1),
		@cVnDias   char(2),
		@cDiasSuc  char(2),
		@cPne    char(1),
		@cBloqRev    char(1),
		@cvViaRep char(1)

DECLARE
@cGrupo    char(5),	-- novo
@cSubNv    char(7),	-- novo
@cGrupo1   char(5),	-- novo
@cGrupo2   char(5),	-- novo
@cGrupo3   char(5),	-- novo
@cGpoSab   char(5),	-- novo
@cGpoDom   char(5),	-- novo
@cGpoFer   char(5),	-- novo
@cAdBuf VARCHAR(2),			-- novo
@nTamG int,
@cPlanta   char(5)

/*
DECLARE
@cGrupo    varchar(5),	-- novo
@cSubNv    varchar(7),	-- novo
@cGrupo1   varchar(5),	-- novo
@cGrupo2   varchar(5),	-- novo
@cGrupo3   varchar(5),	-- novo
@cGpoSab   varchar(5),	-- novo
@cGpoDom   varchar(5),	-- novo
@cGpoFer   varchar(5),	-- novo
@cAdBuf CHAR(2),			-- novo
@nTamG int,
@cPlanta   varchar(5)
*/


DECLARE @stmt1 nvarchar(4000)
DECLARE @ParmDefinition nvarchar(500);



	SET LOCK_TIMEOUT 1000	
	SET @RetFun = 0
	SET @cReg1  = ''
	SET @cReg2  = ''
	SET @cReg3  = ''
	SET @cReg4  = ''

	SET @cReg5  = ''
	SET @cReg6  = ''
	SET @cReg7  = ''
	SET @cReg8  = ''
	SET @cUsuLock = @Usuario

	SELECT @cAdBuf = null
	SELECT @nTamG = 3 
	SELECT	@nTamG  = COLUNAS.LENGTH
	FROM 
		SYSOBJECTS AS TABELAS,
		SYSCOLUMNS AS COLUNAS
	WHERE 
		-- JOINS 
		TABELAS.ID = COLUNAS.ID
		AND TABELAS.NAME = 'DAT07'
		AND COLUNAS.NAME = 'LACES'


	SET @Result = 1	
	SET @cMatric = substring(@cMatricNS, 1, 12);
	SET @cMatBusca = '000000000000'
	SET @cTipoDoc = '0'
	SET @cBloqBDCC = '0'
	SET @cFx1 = '24002400'
	SET @cFx2 = '24002400'
	SET @cFx3 = '24002400'
	SET @cFx4 = '24002400'
	SET @cFx5 = '24002400'
	SET @cFx6 = '24002400'

	set DATEFORMAT dmy
	SET @dDataOcor = CAST((substring(@cDataOcorr,5,2)+'-'+
							 substring(@cDataOcorr,7,2)+'-'+
							 substring(@cDataOcorr,9,2)+' '+
							 substring(@cDataOcorr,1,2)+':'+
							 substring(@cDataOcorr,3,2)+':'+
							 '00') AS datetime);

	SET @cModo = substring(@cInform, 1, 1);  -- TIPO DE PESQUISA
	-- cModo = 0 :icard; 
	-- cModo = 1 :numero serial
	-- cModo = 2 :cpf
	-- cModo = 3 :bdcc


	SET @cFazLock = 	substring(@cInform, 3, 1);  -- SE CONSULTA ONLINE
	SET @cDesbloqRev = 	substring(@cInform, 4, 1);  -- SE DESBLOQUEIO REVISTA
	SET @cVerNumS = 	substring(@cInform, 5, 1);  -- SE verifica NUMSERIAL
	SET @cEhEscolta =  	substring(@cInform, 6, 1);	-- SE É INDICADOR DE ESCOLTA

	-- *******************************************************
	-- verifica se modo de busca é por CPF
	IF (@cModo ='2') begin					-- CPF
		SELECT	@cIcard   = a.ICARD,
				@cCPF	  = c.CPF,
				@cTipoDoc = c.TIPODOC
				
			FROM ContCPF c 
				INNER JOIN Controle a
					ON c.CPF = substring(@cMatric, 2, 11) and c.icard = a.icard 

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end
	
	-- *******************************************************
	-- verifica se modo de busca é por ICARD
	ELSE IF (@cModo = '0') begin  			-- ICARD
		IF (@cVerNumS = '1') BEGIN
			SELECT	@cIcard   = a.ICARD,
					@cNumSerial  = a.NUMSERIAL
				FROM Controle a 
			WHERE a.ICARD = @cMatric and
   				  a.NumSerial = substring(@cMatricNS, 13, 10) 
				
			IF (@@ROWCOUNT = 0) begin
				-- SITUACAO SURICATO: VARIOS CARTOES SM COM MESMO ICARD, E NA CONTROLE ESTAO OS VALORES DE NUM.SERIAL NA COLUNA ICARD, TODOS COM O MESMO VALOR DO TITULAR
				-- A BUSCA PRIMEIRO SERA FEITA ICARD+NUMSERIAL. SE NÃO ACHOU, QUE É ONDE SE ENCONTRA AGORA, A BUSCA SERÁ SOBRE TITULAR+ICARD. QDO ENCONTRAR, O VALOR DE
				-- CMATBUSCA SERÁ O VALOR DO CAMPO ICARD

				SELECT	@cIcard   = a.TITULAR,
						@cVarAux  = a.ICARD
					FROM Controle a 
				WHERE a.TITULAR = @cMatric and
					  a.ICARD = '00'+substring(@cMatricNS, 13, 10) 

				IF (@@ROWCOUNT = 0) begin
					set @cIcard = '000000000000'	-- 12 zeros
					SET @RetFun = -2
					SET @Result = 0	
				end
				ELSE begin
					SET	@cMatBusca = @cIcard;
				end
			end
			ELSE begin
				SET	@cMatBusca = @cIcard;
			end
		end	

		ELSE begin
			SET @cMatBusca = @cMatric;
		end
	end
				
	-- *******************************************************
	-- verifica se modo de busca é por NUMERO SERIAL
	ELSE IF (@cModo = '1') begin  			-- NUMERO SERIAL
		SELECT	@cIcard   = a.ICARD,
				@cNumSerial  = a.NUMSERIAL
				
			FROM Controle a 
				WHERE a.NumSerial = substring(@cMatric, 3, 10) 
	
		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end


	-- *******************************************************
	-- verifica se modo de busca é por BDCC
	ELSE IF (@cModo = '3') begin  		
		SELECT	@cIcard   = a.ICARD,
				@cBloqBDCC  = c.Bloqueado
				
			FROM bdcc_cracha c 
			INNER JOIN Controle a
				ON c.Cracha = @cMatric and 
				   c.Cracha = a.ICARD  

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end


	-- *******************************************************
	-- verifica se encontrou o usuario, entao coleta informacoes do usuario
	IF (@Result = 1) begin			
		
		-- COLETA faixa horaria do usuario de acordo com o tipo de terminal 
				
		IF (@cTipTerm = '3') begin		  -- TERMINAL TIPO PONTO
			-- colocar 'X' no final de cReg1,cReg2,cReg3 e cReg4 pois o SQL trunca   valores
			-- com campos que contem branco (se o campo for o ultimo a ser concatenado)
			SELECT @cIcard    = a.ICARD,
					   @cReg1 = b.FX_DOM_P + b.FX_SEG_P + b.FX_TER_P + 'X', 
					   @cReg2 = b.FX_QUA_P + b.FX_QUI_P + b.FX_SEX_P + 'X', 
					   @cReg3 = b.FX_SAB_P + b.FX_REF + 'X',
					   --@cReg4 = a.FX_1 + a.FX_2 + a.FX_3 + a.FX_4 + a.FX_5 + a.FX_6 + 'X'
					   @cFx1 = a.FX_1, @cFx2 = a.FX_2, @cFx3 = a.FX_3, @cFx4 = a.FX_4, @cFx5 = a.FX_5, @cFx6 = a.FX_6
					   
			FROM  Controle a
				INNER JOIN  FxHoraria b  
					ON a.ICard = @cMatBusca and b.ICard = a.ICard
		end  			
		
		ELSE begin						-- TERMINAL QUE NAO É PONTO (ACESSO)
			SELECT @cIcard    = a.ICARD,
				   @cReg1 = b.FX_DOM_A + b.FX_SEG_A + b.FX_TER_A + 'X', 
				   @cReg2 = b.FX_QUA_A + b.FX_QUI_A + b.FX_SEX_A + 'X', 
				   @cReg3 = b.FX_SAB_A + b.FX_REF + 'X',
				   --@cReg4 = a.FX_1 + a.FX_2 + a.FX_3 + a.FX_4 + a.FX_5 + a.FX_6 + 'X' 
				   @cFx1 = a.FX_1, @cFx2 = a.FX_2, @cFx3 = a.FX_3, @cFx4 = a.FX_4, @cFx5 = a.FX_5, @cFx6 = a.FX_6
			FROM  Controle a
				INNER JOIN  FxHoraria b  
					ON a.ICard = @cMatBusca and b.ICard = a.ICard
		end

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
		end

		-- *******************************************************
		-- COLETA outros dados do usuario
		ELSE begin
			SELECT	@cIcard   = a.ICARD,
					@cGrupo   = a.GRUPO,
					@cCodig   = a.CODIG,
					@cTpFis   = a.TPFIS, 
					@cSitua   = a.SITUA,
					@cSubNv   = a.SUBNV,
					@cPlanta  = a.PLANTA,
					@cDataHora = a.DATAHORA,
					@cUltrs    = a.ULTRS,
					@cDatIni   = a.DATINI,
					@cDatFim   = a.DATFIM,
					@cTitular  = a.TITULAR,
					@cFx_Flg   = a.FX_FLG,
					@cFx_Dta   = a.FX_DTA,
					@cFx_Alm   = a.TEMPO_ALM,
					@cMensagem = a.MENSAGEM,
					@cDta_mens = a.DTA_MENS, 
					@cQtd_mens = a.QTD_MENS,
					@cCred_Fx1 = a.CRED_FX1,
					@cCred_Fx2 = a.CRED_FX2,
					@cCred_Fx3 = a.CRED_FX3,
					@cCred_Fx4 = a.CRED_FX4,
					@cCred_Fx5 = a.CRED_FX5,
					@cCred_Fx6 = a.CRED_FX6,
					@cUltPasR  = a.ULTPAS_REF,
					@cGrupo1   = a.GRUPO1,
					@cDatIniG1 = a.DATINIG1,
					@cDatFimG1 = a.DATFIMG1,
					@cGrupo2   = a.GRUPO2,
					@cDatIniG2 = a.DATINIG2,
					@cDatFimG2 = a.DATFIMG2,
					@cGrupo3   = a.GRUPO3,
					@cDatIniG3 = a.DATINIG3,
					@cDatFimG3 = a.DATFIMG3,
					@cGpoSab   = a.GRUPO_SAB,
					@cGpoDom   = a.GRUPO_DOM,
					@cGpoFer   = a.GRUPO_FER,
					@cAnti_D   = a.ANTI_DUPLA,
					@cBloq     = a.BLOQ_FALTA,
					@cVHora    = a.VER_HORA,
					@cVLocal   = a.VER_LOCAL,
					@cVValid   = a.VER_VALID,
					@cVAfast   = a.VER_AFAST,
					@cVCred    = a.VER_CRED,
					@cVisEsp   = a.VIS_ESP,
					@cVDigit   = a.VER_DIGIT,

					@cTpoIntj = a.TEMPO_RET,				
					@cTolIntj = a.TOLER_RET,
					@cInterj  = a.VER_RET,

					@cTpoJorn  = a.TEMPO_JORNADA, 
					@cSaidaMax = a.VER_SAIDAMAX,
					@cVnDias   = a.VER_NDIAS,
					@cPne      = a.PNE,
					@cBloqRev  = a.BLOQREV,
					@cvViaRep  = a.VER_VIAREP

				FROM Controle a
					WHERE  a.icard = @cMatBusca

			IF (@@ROWCOUNT = 0) begin
				set @cIcard = '000000000000'	-- 12 zeros
				SET @RetFun = -2
			end

			-- *******************************************************
			-- locka usuario se necessario
			ELSE begin
				IF (@cSitua = '4') or (@cFazLock = '0') begin 	-- se Provisorio, não 'bloqueia'. Sera 'bloqueado' o Titular
					set @ret = 0
				end
				ELSE begin
					SET @stmt1 = 'execute @p1 = ' + @cOwner + '.request_lock @cMat, @cUsu'
					SET @ParmDefinition = N'@cMat nvarchar(30), @cUsu CHAR(15), @p1 int OUTPUT ';		
					EXEC sp_executesql @stmt1, 
									@ParmDefinition, 
									@cMat = @cMatric, 
									@cUsu = @Usuario,
									@p1 = @ret OUTPUT		
				end		
	
				-- *******************************************************
				-- verifica se dados são nulos para preencher com valores default
				IF (@ret = 0) begin
					SET @cFxDiaEsp = SPACE(28);
					SET @cFxCred   = SPACE(4);
					-- Armazena dados da matricula em Registro
					-- colocar 'X' no final de cReg1, cReg2 e cReg3 pois o SQL trunca            -- valores com campos que contem branco (se o campo for o ultimo a ser       -- concatenado)
					if (@cCodig is Null) 
						SET @cCodig = SPACE(6);
					if (@cTpFis is Null) 
						SET @cTpFis = SPACE(1);
					if (@cSubNv is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cSubNv = '00'+SPACE(3);	-- 3 espacos
						ELSE
							SET @cSubNv = '00'+SPACE(5);	-- 5 espacos
					END
						
					if (@cPlanta is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cPlanta = '000';		--3
						ELSE
							SET @cPlanta = '00000';		-- 5 
					END

					if (@cDataHora is Null) 
						SET @cDataHora = '3112202359';
					if (@cUltrs is Null) 
						SET @cUltrs = '0101902359'+SPACE(10);
					if (@cFx_Flg is Null)  
						SET @cFx_Flg = '0';		-- 1 
					if (@cFx_Dta is Null)  
						SET @cFx_Dta = SPACE(11);
					if (@cFx_Alm is Null)  
						SET @cFx_Alm = SPACE(3);
					if (@cDatIni is Null) 
						SET @cDatIni = SPACE(6);
					if (@cDatFim is Null) 
						SET @cDatFim = SPACE(6);
					if (@cTitular is Null) 
						SET @cTitular = SPACE(12);
					if (@cMensagem is Null)  
						SET @cMensagem = SPACE(32);
					if (@cDta_mens is Null)  
						SET @cDta_mens = SPACE(6);
					if (@cQtd_mens is Null)  
						SET @cQtd_mens = SPACE(2);
					if (@cCred_Fx1 is Null)  
						SET @cCred_Fx1 = '00';		-- 2
					if (@cCred_Fx2 is Null)  
						SET @cCred_Fx2 = '00';		-- 2
					if (@cCred_Fx3 is Null)  
						SET @cCred_Fx3 = '00';		-- 2
					if (@cCred_Fx4 is Null)  
						SET @cCred_Fx4 = '00';		-- 2
					if (@cCred_Fx5 is Null)  
						SET @cCred_Fx5 = '00';		-- 2
					if (@cCred_Fx6 is Null)  
						SET @cCred_Fx6 = '00';		-- 2
					if (@cUltPasR is Null)  
						SET @cUltPasR = SPACE(10);

					if (@cGrupo1 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo1 = '000';	-- 3 
						ELSE
							SET @cGrupo1 = '00000'	-- 5 
					END
					if (@cDatIniG1 is Null) 
						SET @cDatIniG1 = SPACE(10);
					if (@cDatFimG1 is Null) 
						SET @cDatFimG1 = SPACE(10);

					if (@cGrupo2 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo2 = '000';	-- 3 
						ELSE
							SET @cGrupo2 = '00000'	-- 5 
					END
					if (@cDatIniG2 is Null) 
						SET @cDatIniG2 = SPACE(10);
					if (@cDatFimG2 is Null) 
						SET @cDatFimG2 = SPACE(10);
					
					if (@cGrupo3 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo3 = '000';	-- 3 
						ELSE
							SET @cGrupo3 = '00000'	-- 5 
					END
					if (@cDatIniG3 is Null) 
						SET @cDatIniG3 = SPACE(10);
					if (@cDatFimG3 is Null) 
						SET @cDatFimG3 = SPACE(10);

					if (@cGpoSab is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoSab = '000';	-- 3 
						ELSE
							SET @cGpoSab = '00000'	-- 5 
					END

					if (@cGpoDom is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoDom = '000';	-- 3 
						ELSE
							SET @cGpoDom = '00000'	-- 5 
					END

					if (@cGpoFer is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoFer = '000';	-- 3 
						ELSE
							SET @cGpoFer = '00000'	-- 5 
					END

					if (@cVisEsp is Null) 
						SET @cVisEsp = '0';		-- 1
					if (@cVDigit is Null) 
						SET @cVDigit = '2';		-- 1
					if (@cTpoIntj is Null) 
						SET @cTpoIntj = '000';		-- 3
					if (@cTolIntj is Null)
						SET @cTolIntj = '000';		-- 3
					if (@cInterj is Null)
						SET @cInterj = '0';		-- 1 
					if (@cTpoJorn is Null)
						SET @cTpoJorn = '000';		-- 3
					if (@cSaidaMax is Null)
						SET @cSaidaMax = '0';		-- 1 
					if (@cTipoDoc is Null)
						SET @cTipoDoc = '2';		-- 1 

					if (@cVnDias is Null) 
						SET @cVnDias = '00';		-- 2

					if (@cPne is Null)
						SET @cPne = '0';		-- 1 
					if (@cBloqRev is Null)
						SET @cBloqRev = '0';		-- 1 
					if (@cvViaRep is Null)
						SET @cvViaRep = '0';		-- 1 

					if (@cFx1 is Null)
						SET @cFx1 = '24002400';		-- 8 
					if (@cFx2 is Null)
						SET @cFx2 = '24002400';		-- 8 
					if (@cFx3 is Null)
						SET @cFx3 = '24002400';		-- 8 
					if (@cFx4 is Null)
						SET @cFx4 = '24002400';		-- 8 
					if (@cFx5 is Null)
						SET @cFx5 = '24002400';		-- 8 
					if (@cFx6 is Null)
						SET @cFx6 = '24002400';		-- 8 


					IF (@nTamG = 3) 
						SELECT @cAdBuf = SPACE(2);		-- 2 espços
					ELSE
						SELECT @cAdBuf = null


					SET @cReg4 = @cFx1 + @cFx2 + @cFx3 + @cFx4 + @cFx5 + @cFx6 + 'X'
					
					SET @cReg5 = @cIcard + @cGrupo + 
								 @cCodig + @cTpFis + @cSitua + @cSubNv + 
								 @cPlanta + 
								 'X'
					
					/*
					SET @cReg5 = @cIcard + @cGrupo + COALESCE(@cAdBuf, '') + 
								 @cCodig + @cTpFis + @cSitua + @cSubNv + COALESCE(@cAdBuf, '') + 
								 @cPlanta + COALESCE(@cAdBuf, '') + 'X'
					*/
					

					SET @cReg6 = substring(@cDataHora,1,10) + @cUltrs + @cFx_Flg + @cFx_Dta + @cFx_Alm + 
								 @cFxDiaEsp + @cDatIni + @cDatFim + @cMensagem + @cDta_mens + @cQtd_mens  + 
								 @cCred_Fx1 + @cFxCred +
								 @cCred_Fx2 + @cFxCred +
								 @cCred_Fx3 + @cFxCred +
								 @cCred_Fx4 + @cFxCred +
								 @cCred_Fx5 + @cFxCred +
								 @cCred_Fx6 + @cFxCred +
								 @cUltPasR + @cTitular  + 'X'
								 
					SET @cReg7 = @cGrupo1 + @cDatIniG1 + @cDatFimG1 +
								 @cGrupo2 + @cDatIniG2 + @cDatFimG2 +
								 @cGrupo3 + @cDatIniG3 + @cDatFimG3 +
								 @cGpoSab + 
								 @cGpoDom + 
								 @cGpoFer + 
								 @cAnti_D + @cBloq + @cVHora + @cVLocal +
								 @cVValid + @cVAfast + @cVCred + @cVisEsp + 'X'


					/*
					SET @cReg7 = @cGrupo1 + COALESCE(@cAdBuf, '') + @cDatIniG1 + @cDatFimG1 +
								 @cGrupo2 + COALESCE(@cAdBuf, '') + @cDatIniG2 + @cDatFimG2 +
								 @cGrupo3 + COALESCE(@cAdBuf, '') + @cDatIniG3 + @cDatFimG3 +
								 @cGpoSab + COALESCE(@cAdBuf, '') + 
								 @cGpoDom + COALESCE(@cAdBuf, '') + 
								 @cGpoFer + COALESCE(@cAdBuf, '') + 
								 @cAnti_D + @cBloq + @cVHora + @cVLocal +
								 @cVValid + @cVAfast + @cVCred + @cVisEsp + 'X'
					*/					


					IF (@cDesbloqRev = '1')  
						SET @cBloqRev = '0'
					

					--SET @cReg8 = @cIcard + '0' + '0' + @cVDigit + 
					SET @cReg8 = @cIcard + @cvViaRep + '0' + @cVDigit + 
								 @cTpoIntj + @cTolIntj + @cInterj + 
								 @cTpoJorn + @cSaidaMax + 
								 @cTipoDoc + '00' + @cVnDias + 
								 --@cPne + @cBloqRev + 'X'
								 @cPne + @cBloqRev
				end
				-- matricula ja lockada
				ELSE
					SET @RetFun = -3
			end
		end
	END

	SET DATEFORMAT dmy
	SELECT @cIniHalmAux = CONVERT(char(8), a.Ini_Halm, 3)+ CONVERT(char(8), a.Ini_Halm, 8),
		   @cFimHalmAux = CONVERT(char(8), a.Fim_Halm, 3)+ CONVERT(char(8), a.Fim_Halm, 8),
		   @cIniIntjAux = CONVERT(char(8), a.Ini_Intj, 3)+ CONVERT(char(8), a.Ini_Intj, 8),
		   @cFimIntjAux = CONVERT(char(8), a.Fim_Intj, 3)+ CONVERT(char(8), a.Fim_Intj, 8),
		   @cFimAntDAux = CONVERT(char(8), a.Fim_AntiD, 3)+ CONVERT(char(8), a.Fim_AntiD, 8) ,
		   @cDiasSuc = a.Dias_Suc   
		   
	FROM DATAHORA a 
	WHERE a.ICARD = @cMatBusca
	
	IF (@@ROWCOUNT = 0) begin
  		SET @cIniHalm = '010106000000'	-- 01/01/06
		SET @cFimHalm = '010106000000'	-- 01/01/06
		SET @cIniIntj = '010106000000'	-- 01/01/06
		SET @cFimIntj = '010106000000'	-- 01/01/06
		SET @cFimAntD = '010106000000'	-- 01/01/06
		SET @cDiasSuc = '00';
	end
	ELSE begin
		SET @cIniHalm = substring (@cIniHalmAux,1,2)+substring (@cIniHalmAux, 4,2)+substring (@cIniHalmAux, 7,2)+
						substring (@cIniHalmAux,9,2)+substring (@cIniHalmAux,12,2)+substring (@cIniHalmAux,15,2)
		SET @cFimHalm = substring (@cFimHalmAux,1,2)+substring (@cFimHalmAux, 4,2)+substring (@cFimHalmAux, 7,2)+
						substring (@cFimHalmAux,9,2)+substring (@cFimHalmAux,12,2)+substring (@cFimHalmAux,15,2)
		SET @cIniIntj = substring (@cIniIntjAux,1,2)+substring (@cIniIntjAux, 4,2)+substring (@cIniIntjAux, 7,2)+
						substring (@cIniIntjAux,9,2)+substring (@cIniIntjAux,12,2)+substring (@cIniIntjAux,15,2)
		SET @cFimIntj = substring (@cFimIntjAux,1,2)+substring (@cFimIntjAux, 4,2)+substring (@cFimIntjAux, 7,2)+
						substring (@cFimIntjAux,9,2)+substring (@cFimIntjAux,12,2)+substring (@cFimIntjAux,15,2)
		SET @cFimAntD = substring (@cFimAntDAux,1,2)+substring (@cFimAntDAux, 4,2)+substring (@cFimAntDAux, 7,2)+
						substring (@cFimAntDAux,9,2)+substring (@cFimAntDAux,12,2)+substring (@cFimAntDAux,15,2)
	END
	
	SET @cReg9 = @cIcard + @cIniHalm + @cFimHalm + @cIniIntj + @cFimIntj + @cFimAntD + @cDiasSuc + 'X';

	--SET @cReg10 = @cBloqBDCC + 'X';
	SET @cReg10 = @cBloqBDCC;

	-- *******************************************************
	-- atualiza tab.CONTROLE se o usuario foi liberado pelo equipamento para revista
	IF (@RetFun = 0 AND 
		@Result = 1 AND 
		@cDesbloqRev = '1') begin
			IF (@cFazLock = '0') begin				-- marcacao offline
				SET @pos = CHARINDEX(' ', @cUltrs);  	-- VERIFICA SE data armazenada em BD tem valor em branco

				IF (@pos <= 10) and (@pos > 0) 
					SET @dDataBD = @dDataOcor;		-- assume temporariamente a mesma data de ocorrencia para que haja tualização
				ELSE begin
					set DATEFORMAT dmy
					SET @dDataBD = CAST((substring(@cUltrs,1,2)+'-'+substring(@cUltrs,3,2)+'-'+substring(@cUltrs,5,2)+' '+
							 			 substring(@cUltrs,7,2)+':'+substring(@cUltrs,9,2)+':'+'00') AS datetime);					
				end
				
				IF (@dDataOcor >= @dDataBD) 			-- atualiza BD porque a marcacao offline é mais recente que está em BD
					UPDATE CONTROLE SET BLOQREV = '0' WHERE ICARD = @cMatBusca;
			end
			ELSE
				UPDATE CONTROLE SET BLOQREV = '0' 
					WHERE ICARD = @cMatBusca
	end		
				
	-- *******************************************************
	-- verifica grupo do Estacionamento
	SET @nGrest = 0;
	SET @nGrestEquip = 0;
	SET @cEmFixa = '0';
	
	SELECT @nGrest = convert(int, GREST)  			-- VERIFICA SE O EQUIPAMENTO PERTENCE A ALGUM ESTACIONAMENTO
		FROM ESTAC001 
		WHERE END_IP = @Usuario;
	
	IF (@@ROWCOUNT = 0) begin
		SET @nGrest = 0;
		SET @nGrestEquip = 0;
	end			
	ELSE begin
		SET @nGrestEquip = @nGrest;
		
		SELECT @cEmFixa = EMFIXA   					-- VERIFICA SE A MATRICULA POSSUI VAGA FIXA NESTE ESTACIONAMENTO
			FROM ESTAC003 
			WHERE ICARD = @cMatBusca AND GREST = @nGrest;
			
		IF (@@ROWCOUNT = 0)			
			SET @nGrest = 0;
	END;


	SET @AuxGr2 = convert(char, @nGrest);
	SET @AuxGr = REPLICATE('0',3-LEN(@AuxGr2) ) + @AuxGr2;
	SET @cReg8 = @cReg8 + @AuxGr;								-- grupo de estacionamento do qual o usuario tem vaga fixa
	SET @cReg8 = @cReg8 + @cEmFixa + 'X';						-- indicador se estacionou em vaga fixa

	SET @AuxGr2 = convert(char, @nGrestEquip);
	SET @AuxGr = REPLICATE('0',3-LEN(@AuxGr2) ) + @AuxGr2;			-- grupo de estacionamento ao qual o equipamento faz parte
	SET @cReg10 = @cReg10 + @AuxGr + 'X'		-- posic 1 a 3		



	-- *******************************************************
	-- verifica Area de ESCOLTA
	SET @cTemEsc = '0'

	IF (@cEhEscolta = '0')		-- não é a escolta
	BEGIN
		SET @cProcurado = @cMatBusca
		SET @nContArea = 0
		SET @cFinalSentido = '0'
		
		SET @cEscoltado = @cMatBusca
		SET @cEscolta = '000000000000'
		SET @cTemEsc = '0'
		SET @cSentido = '0'
	
		
		DECLARE escolt_cur CURSOR FOR
			SELECT AREA, SENTIDO FROM ESCOLT002 
				WHERE END_IP = @Usuario
				ORDER by AREA;

		OPEN escolt_cur
		FETCH next from escolt_cur into @nAuxArea, @AuxSentido
		WHILE (@@fetch_status != -1)
		BEGIN
			SET @nContArea = @nContArea + 1
		
			-- localiza a AREA e MATRICULA NA TABELA DE PESSOAS A SEREM ESCOLTADAS
			IF EXISTS (
				SELECT ICARD_ESCOLTADO, AREA 
					FROM ESCOLT001 
					WHERE ICARD_ESCOLTADO = @cProcurado AND
						  AREA = @nAuxArea)

			BEGIN
				SET @cFinalSentido = 
				CASE 
					WHEN @cFinalSentido = '0' 
						THEN ( @AuxSentido)
					WHEN @cFinalSentido = '1' AND (@AuxSentido = '2' OR  @AuxSentido = '3') 
						THEN '3'
					WHEN @cFinalSentido = '2' AND (@AuxSentido = '1' OR  @AuxSentido = '3')
						THEN '3'
						ELSE @cFinalSentido
				END
					
				SET @cTemEsc = '1'
				SET @cSentido = @cFinalSentido
			END
			
			FETCH next from escolt_cur into @nAuxArea, @AuxSentido
		END
		
		CLOSE escolt_cur
		DEAllocate escolt_cur
	END


	-- É A ESCOLTA
	ELSE BEGIN
	
		SET @nContArea = 0
		SET @cEscoltado = @cVisita
		SET @cEscolta = '000000000000'
		SET @cTemEsc = '0'
		SET @cSentido = '0'
	
		DECLARE escolt_cur CURSOR FOR
			SELECT AREA FROM ESCOLT002 
				WHERE END_IP = @Usuario
				ORDER by AREA;

	
		OPEN escolt_cur
		FETCH next from escolt_cur into @nAuxArea
		WHILE (@@fetch_status != -1)
		BEGIN
			SET @nContArea = @nContArea + 1
		
			-- VERIFICA SE A MATRICULA É AUTORIZADA A SER  ESCOLTA 

			IF EXISTS (
				SELECT ICARD_ESCOLTADO, AREA 
					FROM ESCOLT001 
					WHERE ICARD_ESCOLTADO = @cVisita AND
					   	  ICARD_GUARDA = @cMatBusca AND 
					      AREA = @nAuxArea)
			BEGIN
				SET @cEscoltado = @cVisita;
				SET @cEscolta = @cMatBusca;
				SET @cTemEsc = '0'	
				--SET @@fetch_status  = -1
				BREAK
			END
			ELSE
				FETCH next from escolt_cur into @nAuxArea
		END
		CLOSE escolt_cur
		DEAllocate escolt_cur
	END
	
	SET @cReg11 = @cEscoltado + @cEscolta + @cTemEsc + @cSentido + 'X';

	SET LOCK_TIMEOUT -1		
	
	SELECT @RetFun, 
		@cReg1, 
		@cReg2, 
		@cReg3, 
		@cReg4, 
		@cReg5, 
		@cReg6, 
		@cReg7, 
		@cReg8, 
		@cReg9,
		@cReg10,
		@cReg11,
		@nTamG		
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlconsG3G5_term_fer_tcp')
	DROP PROCEDURE TELESSVR.sqlconsG3G5_term_fer_tcp;
GO

CREATE PROCEDURE TELESSVR.sqlconsG3G5_term_fer_tcp @cEndIp CHAR(15), @cData varchar(6) AS

DECLARE @cTipo AS CHAR(1), --@cLocal AS CHAR(3), 
		@cLocal AS CHAR(5), --@cPlanta AS CHAR(3), 
		@cPlanta AS CHAR(5), 
		@ctipobio AS CHAR(1), 
		@cRastr AS CHAR(1), @cBuf AS VARCHAR(50), @cIniHA AS CHAR(1), @cFimHA AS CHAR(1), 
		@cValidR AS CHAR(1), @cValidSMax AS CHAR(1), @cTolAntes AS CHAR(2), @cTolApos AS CHAR(2),
		@cLeitSm AS CHAR(1), @cPosVPlaca AS CHAR(1), @cPosMensBloq  AS CHAR(1), @cValDiasSuc AS CHAR(1),
		@cParidRep AS CHAR(1), @cQtdMult AS CHAR(2),
		@cLMinimo AS CHAR(4), @cLMaximo AS CHAR(4), @cQtdAtual AS CHAR(4)
		
/*
OBS: SE USAR VARCHAR PARA ESTAS VARIAVEIS, DEVERÁ USAR O RECURSO DE COALESCE(ADBUF) para compor o resultado em cBuf.
SE USAR CHAR(5) como esta sendo usado, o select mesmo com local e planta com 3 digitos armazenara 2espacos em branco no final da variavel CHAR, portanto 
nao será necessario utilizar COALESCE 
DECLARE @cLocal AS VARCHAR(5), 
		@cPlanta AS VARCHAR(5)
*/
		

DECLARE @ret int, @DataAux varchar(10), @Descr varchar(31) 
DECLARE @nTamG int, @cAdBuf char(2)  --@cAdBuf varchar(2)			-- novo


--	SET LOCK_TIMEOUT 1000
	SET @ret = 0
	SET @cBuf = ' '
	set @DataAux = substring (@cData,1,2)+ '-'+ substring (@cData, 3,2)+ '-'+ substring (@cData, 5,2)
	SET DATEFORMAT DMY

	SET @cLocal = NULL;
	SET @cPlanta = NULL;
	SET @nTamG = 3 

	SELECT	@nTamG  = COLUNAS.LENGTH
		FROM 
			SYSOBJECTS AS TABELAS,
			SYSCOLUMNS AS COLUNAS
		WHERE 
			-- JOINS 
			TABELAS.ID = COLUNAS.ID
			AND TABELAS.NAME = 'DAT07'
			AND COLUNAS.NAME = 'LACES'


	IF (@nTamG = 3) 
		SET @cAdBuf = SPACE(2);		-- 2 espços
	ELSE
		SET @cAdBuf = null;


	SELECT @cTipo = TIP_TERM,
	       @cLocal = LACES,
	       @ctipobio = BIO_TIPO,
	       @cPlanta = PLANTA,
	       @cRastr = RASTREADOR,
	       @cIniHA = POS_INIHALM,
	       @cFimHA = POS_FIMHALM,
	       @cValidR = VALID_RET,
	       @cValidSMax = VALID_SAIDAMAX,
	       @cTolAntes = TOLER_ANTES,
	       @cTolApos = TOLER_APOS,
	       @cLeitSm = TIP_LEIT,
	       @cPosVPlaca = POSVALPLACA, 
	       @cPosMensBloq = POSMENSBLOQ,
	       @cValDiasSuc = VALID_NDIAS,
	       @cParidRep = PARIDREP,
	       @cQtdMult = QTDMULT,
		   @cLMinimo = REPLICATE('0', 4 - LEN(CAST (LMINIMO as varCHAR(4)))) + RTrim(LTRIM(STR(LMINIMO,4))),		-- insere 0's à esquerda para string final tamanho 4
		   @cLMaximo = REPLICATE('0', 4 - LEN(CAST (LMAXIMO as varCHAR(4)))) + RTrim(LTRIM(STR(LMAXIMO,4))),			-- insere 0's à esquerda para string final tamanho 4
		   @cQtdAtual = REPLICATE('0', 4 - LEN(CAST (QTDATUAL as varCHAR(4)))) + RTrim(LTRIM(STR(QTDATUAL,4)))			-- insere 0's à esquerda para string final tamanho 4
		       
	FROM DAT07 (NOLOCK)
		  WHERE END_IP = @cEndIp and blueb = '00' and codin = '00'

	IF (@@ROWCOUNT <> 0)
	BEGIN
		if (@cTipo is Null) 
			SET @cTipo = '1'
		
		if (@cLocal is Null) begin
			if (@nTamG = 3)	
				SET @cLocal = '000';
			else
				SET @cLocal = '00000';
		end
		
		if (@ctipobio is Null) 
			SET @ctipobio = '0'

		if (@cPlanta is Null) BEGIN
			if (@nTamG = 3)	
				SET @cPlanta = '000'
			else
				SET @cPlanta = '00000'
		end
		
		if (@cRastr is Null) 
			SET @cRastr = '0'
		if (@cIniHA is Null) 
			SET @cIniHA = '0'
		if (@cFimHA is Null) 
			SET @cFimHA = '0'
		if (@cValidR is Null) 
			SET @cValidR = '0'
		if (@cValidSMax is Null) 
			SET @cValidSMax = '0'
		if (@cLeitSm is Null) 
			SET @cLeitSm = '0'
		if (@cTolAntes is Null) 
			SET @cTolAntes = '00'
		if (@cTolApos is Null) 
			SET @cTolApos = '00'
		if (@cPosVPlaca is Null) 
			SET @cPosVPlaca = '0'
		if (@cPosMensBloq is Null) 
			SET @cPosMensBloq = '0'
		if (@cValDiasSuc is Null) 
			SET @cValDiasSuc = '0'
		if (@cParidRep is Null) 
			SET @cParidRep = '0'
		if (@cQtdMult is Null) 
			SET @cQtdMult = '00'
		if (@cLMinimo is Null) 
			SET @cLMinimo = '0000'
		if (@cLMaximo is Null) 
			SET @cLMaximo = '0000'
		if (@cQtdAtual is Null) 
			SET @cQtdAtual = '0000'

		SET @cBuf = @cTipo + @cLocal + 
					@ctipobio + @cPlanta + 
					@cRastr + @cIniHA + @cFimHA + @cValidR + @cValidSMax + @cTolAntes + @cTolApos + @cLeitSm + 
					@cPosVPlaca + @cPosMensBloq + @cValDiasSuc + @cParidRep + @cQtdMult +
					@cLMinimo + @cLMaximo + @cQtdAtual
		

		
		/*
		SET @cBuf = @cTipo + @cLocal + COALESCE(@cAdBuf, '') + 
					@ctipobio + @cPlanta + COALESCE(@cAdBuf, '') + 
					@cRastr + @cIniHA + @cFimHA + @cValidR + @cValidSMax + @cTolAntes + @cTolApos + @cLeitSm + 
					@cPosVPlaca + @cPosMensBloq + @cValDiasSuc + @cParidRep + @cQtdMult +
					@cLMinimo + @cLMaximo + @cQtdAtual
		
		*/
		SET @ret = 1

		IF (@cData != '000000')
		BEGIN
			-- verifica se data e´de Feriado
			IF EXISTS (SELECT DESC_FER FROM FERIADO (NOLOCK)
			   WHERE ((DATA_FER = @DataAux) and
					  (CONVERT(int, PLANTA_FER) = CONVERT(int, @cPlanta) or PLANTA_FER is null or CONVERT(int, PLANTA_FER) = 0)))
			BEGIN
				SET @ret = 2
			END
		END
	END

--	SET LOCK_TIMEOUT -1		

	SELECT @ret, @cBuf, @nTamG
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlatG3G5_tab_acessoSeg')
	DROP PROCEDURE TELESSVR.sqlatG3G5_tab_acessoSeg;
GO

CREATE PROCEDURE TELESSVR.sqlatG3G5_tab_acessoSeg @cRegistro1 char(85) 
AS

DECLARE @cMatric char(12), @Retorno int
DECLARE @nTamG int , @cSubnv VARCHAR(9) , @cPlanta VARCHAR(9);

BEGIN

	SET @cMatric = substring(@cRegistro1, 1, 12)
	SET @Retorno = 0

	SET @nTamG = 3 
	SELECT	@nTamG  = COLUNAS.LENGTH
		FROM 
			SYSOBJECTS AS TABELAS,
			SYSCOLUMNS AS COLUNAS
		WHERE 
			-- JOINS 
			TABELAS.ID = COLUNAS.ID
			AND TABELAS.NAME = 'CONTROLE'
			AND COLUNAS.NAME = 'GRUPO'

	IF (@nTamG = 5) begin
		SET @cSubnv =  substring(@cRegistro1, 14, 7);
		SET @cPlanta =  substring(@cRegistro1, 21,5);
	end
	ELSE begin
		SET @cSubnv = substring (substring(@cRegistro1, 14, 7), 1, 5);
		SET @cPlanta = substring (substring(@cRegistro1, 21, 5), 1, 3);
	END


	SET LOCK_TIMEOUT 1000	
	UPDATE CONTROLE
	 set SITUA = substring(@cRegistro1, 13, 1),
	     --SUBNV = substring(@cRegistro1, 14,5),
	     Subnv = @cSubnv,
	     --PLANTA = substring(@cRegistro1, 21,3),
	     PLANTA = @cPlanta,
	     ULTRS = substring(@cRegistro1, 24+2,25),
	     FX_DTA = substring(@cRegistro1, 49+2,11),
	     QTD_MENS = substring(@cRegistro1, 60+2, 2),
	     CRED_FX1 = substring(@cRegistro1, 62+2, 2),
	     CRED_FX2 = substring(@cRegistro1, 64+2, 2),
	     CRED_FX3 = substring(@cRegistro1, 66+2, 2),
	     CRED_FX4 = substring(@cRegistro1, 68+2, 2),
	     CRED_FX5 = substring(@cRegistro1, 70+2, 2),
	     CRED_FX6 = substring(@cRegistro1, 72+2, 2),
	     ULTPAS_REF = substring(@cRegistro1, 74+2, 10),
	     ULTRSEG = substring(@cRegistro1, 84+2, 2)
	WHERE ICARD = @cMatric

	SET LOCK_TIMEOUT -1		

	return @Retorno
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlvermat_nrefeit')
	DROP PROCEDURE TELESSVR.sqlvermat_nrefeit;
GO

CREATE PROCEDURE TELESSVR.sqlvermat_nrefeit @cMatric char(12), @cEndIp char(15)
AS

DECLARE @nCont int, @nMax int
DECLARE @cPlanta CHAR(5), @cCredito CHAR(2), @cFaixa CHAR(8)
DECLARE @cRegFaixa VARCHAR(120)	-- maximo 15 faixas horarias (15*8 = 120)
DECLARE @cRegCred  VARCHAR(40)	-- maximo 15 creditos (15*2 = 30)
DECLARE @cUltPasRef CHAR(10);		-- DDMMYYHHMI
	
	SET DATEFORMAT DMY
	SET @nMax = 15;
	SET @nCont = 0;
	SET @cRegFaixa = ''
	SET @cRegCred  = ''
	SET @cUltPasRef  = SPACE(10);
	SET @cPlanta  = ''


	-- PROCURA POR TODOS AS FAIXAS DE REFEITORIO DO USUARIO DE ACORDO COM A PLANTA DO QUAL O EQUIPAMENTO FAZ PARTE
	SELECT @cPlanta = PLANTA FROM DAT07 
		WHERE END_IP = @cEndIp 

		
	DECLARE cur_NREFEIT cursor FOR 
		SELECT top (@nMax ) FX_REF, CRED_FXREF 
			FROM MATNREFEIT  
			WHERE ICARD = @cMatric  AND
			  	  CONVERT(INT, PLANTA) = CONVERT(INT, @cPlanta)  ORDER BY FX_REF ASC
			  
	OPEN cur_NREFEIT
	FETCH NEXT FROM cur_NREFEIT INTO @cFaixa, @cCredito
	WHILE (@@fetch_status != -1)
	begin
		SET @cRegFaixa = @cRegFaixa + @cFaixa
		SET @cRegCred  = @cRegCred + @cCredito
		SET @nCont = @nCont + 1
		
		FETCH NEXT FROM cur_NREFEIT INTO @cFaixa, @cCredito
	end

	CLOSE cur_NREFEIT
	DEALLOCATE cur_NREFEIT


	-- PROCURA PELA ULTIMA PASSAGEM EM REFEITORIO FEITA PELA MATRICULA NESTA PLANTA
	IF (@nCont != 0) 
		SELECT @cUltPasRef = ULTPAS_REF FROM AUXMATNREFEIT  
			WHERE ICARD = @cMatric AND 
				  CONVERT(INT, PLANTA) = CONVERT(INT, @cPlanta)
		
	
	SELECT @nCont, @cPlanta, @cRegFaixa, @cRegCred, @cUltPasRef
	GO
			

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlat_tab_refplanta')
	DROP PROCEDURE TELESSVR.sqlat_tab_refplanta;
GO

CREATE PROCEDURE TELESSVR.sqlat_tab_refplanta @cRegistro1 char(50) 
AS

DECLARE @cMatric char(12), @cPlanta char(5), @cFaixa char(8), @cCred char(2), @cDatHorRef char(10), @cAux char(12)
DECLARE @Retorno int


BEGIN

	SET @cMatric  = substring(@cRegistro1,  1, 12)
	SET @cPlanta  = substring(@cRegistro1, 13,  5)
	SET @cFaixa   = substring(@cRegistro1, 18,  8)
	SET @cCred    = substring(@cRegistro1, 26,  2)
	SET @cDatHorRef = substring(@cRegistro1, 28,  10)
	SET @Retorno = 0

	
	SET LOCK_TIMEOUT 1000	
	
	-- atualiza tabela MATNREFEIT, na faixa especifica
	UPDATE MATNREFEIT set CRED_FXREF = @cCred
		WHERE ICARD =  @cMatric and 
			  CONVERT(INT,PLANTA) = CONVERT(INT,@cPlanta) and
			  FX_REF = @cFaixa


	-- insere ou atualiza tabela AUXMATNREFEIT, a data/faixa da última passagem no refeitorio de acordo com a planta
	IF EXISTS (select * from AUXMATNREFEIT WHERE ICARD =  @cMatric and PLANTA = @cPlanta )
		UPDATE AUXMATNREFEIT set ULTPAS_REF = @cDatHorRef 
			WHERE ICARD =  @cMatric and 
				  CONVERT(INT,PLANTA) = CONVERT(INT,@cPlanta) 
	ELSE
		INSERT INTO AUXMATNREFEIT (ICARD, PLANTA, ULTPAS_REF) 
						   VALUES (@cMatric, @cPlanta, @cDatHorRef);


	SET LOCK_TIMEOUT -1		

	return @Retorno
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlver_tipobio')
	DROP PROCEDURE TELESSVR.sqlver_tipobio;
GO

CREATE PROCEDURE TELESSVR.sqlver_tipobio @cEndIp CHAR(15) AS

DECLARE @ctipobio AS CHAR(1) 

DECLARE @ret int

	SET @ret = 0
	SET @ctipobio = '0'


	SELECT @ctipobio = BIO_TIPO	           
		FROM DAT07 (NOLOCK)
		  WHERE END_IP = @cEndIp and blueb = '00' and codin = '00'

	IF (@@ROWCOUNT <> 0)
	BEGIN
		SET @ret = 1
		if (@ctipobio is Null) 
			SET @ctipobio = '0'
	END

	SELECT @ret, @ctipobio
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlbloco_col_dam00_new2')
	DROP PROCEDURE TELESSVR.sqlbloco_col_dam00_new2;
GO

CREATE PROCEDURE TELESSVR.sqlbloco_col_dam00_new2 @Registro CHAR(110), @cTipo char(1)
AS
DECLARE @ret int,
@C1 char(12), @C2 char(2), @C3 char(2), 
@C4 char(2), @C5 char(4), @C6 char(2), 
@C7 char(2), @C8 char(1), @C9 char(15), 
@C10 char(2), @C11 char(1), @C12 char(15), 
@C13 char(2),
@C14 char(10), @C15 char(10) ,
@C16 CHAR (6), @C17 char(7), @C18 char(7), @C19 char(2), @C20 CHAR(1)

set ansi_warnings on
set ansi_padding on
set ansi_nulls on
set concat_null_yields_null on

	SET @ret = 0
	SET @C1 = SUBSTRING(@Registro, 1, 12)  -- ICARD
	SET @C2 = SUBSTRING(@Registro, 13, 2)	--diam
	SET @C3 = SUBSTRING(@Registro, 15, 2)	--mesm
	SET @C4 = SUBSTRING(@Registro, 17, 2)	--anom
	SET @C5 = SUBSTRING(@Registro, 19, 4)	--horam
	SET @C6 = SUBSTRING(@Registro, 23, 2)	--segundo
	SET @C7 = SUBSTRING(@Registro, 25, 2)	--codac
	SET @C8 = SUBSTRING(@Registro, 27, 1)	--posic
	SET @C9 = SUBSTRING(@Registro, 28, 15)	--end_ip
	SET @C10 = SUBSTRING(@Registro, 43, 2) 	--codfnc
	SET @C11 = SUBSTRING(@Registro, 45, 1) 	--onoff
	SET @C12 = SUBSTRING(@Registro, 46, 15)	--veiculo
	SET @C13 = SUBSTRING(@Registro, 61, 2)	--tipodoc
	SET @C14 = SUBSTRING(@Registro, 63, 10)	--ns_icard
	SET @C15 = SUBSTRING(@Registro, 73, 10)	--ns_veic
	SET @C16 = SUBSTRING(@Registro, 83, 6)	--peso
	SET @C17 = SUBSTRING(@Registro, 89, 7)	--valkilo
	SET @C18 = SUBSTRING(@Registro, 96, 7)	--valor
	SET @C19 = SUBSTRING(@Registro, 103, 2)	--qtde
	SET @C20 = SUBSTRING(@Registro, 105, 1)	--BIO1N 


	INSERT INTO DAM00 (ICARD, DIAM, MESM, ANOM, HORAM, SEGUNDO,CODAC, POSIC, END_IP, CODFNC, 
						ONOFF, VEICULO, TIPODOC, ICARD_NS, VEICULO_NS, BIO1N)
			VALUES (@C1, @C2, @C3, @C4, @C5, @C6, @C7, @C8, @C9, @C10, 
					@C11, @C12, @C13, @C14, @C15, @C20)
   
	SELECT @ret
	GO

-----------------------------------------------------------------------------------
-- CONEX ACESSO V.38.02.01 || CONEX ACESSO V.38.02.01 || CONEX ACESSO V.38.02.01 ||
-----------------------------------------------------------------------------------

IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'DIGLOAD001' AND UPPER(COLUMN_NAME) = 'NERRO')
	ALTER TABLE TELESSVR.DIGLOAD001 ADD NERRO CHAR(1) DEFAULT '0';
GO

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'HISTDIG')
	BEGIN
		CREATE TABLE TELESSVR.HISTDIG (
			IFUNC		CHAR(12) 		NOT NULL,
			END_IP		VARCHAR(15)		DEFAULT '000.000.000.000' NOT NULL ,
			BIO_TIPO	CHAR(1) 		NOT NULL,
			INSEXC		CHAR(1) 		NOT NULL CONSTRAINT histdig_1 CHECK (INSEXC	IN ('I','E')),					-- TIPO:'I'= INCLUSAO, 'E'=EXCLUSAO;
			MODO		CHAR(1) 		NOT NULL CONSTRAINT histdig_2 CHECK (MODO	IN ('A','a','M','m','T','t')),			-- MODO:'A'=AUTOMATICO, 'M'=MANUAL, 'T'=TOTAL
			DATA_INS	DATETIME 		DEFAULT GETDATE() NOT NULL 
		)
	END
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG001_IND5')
	CREATE INDEX DIG001_IND5 ON TELESSVR.DIG001 (ICARD, STATUS);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG003_IND5')
	CREATE INDEX DIG003_IND5 ON TELESSVR.DIG003 (ICARD, STATUS);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DAT07_IND4')
	CREATE INDEX DAT07_IND4 ON TELESSVR.DAT07 (BIO_TIPO, END_IP);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG002_IND2')
	DROP INDEX TELESSVR.DIG002.DIG002_IND2;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG002_IND2')
	CREATE INDEX DIG002_IND2 ON TELESSVR.DIG002 (STATUS, DATA_LOAD);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG002_IND3')
	CREATE INDEX DIG002_IND3 ON TELESSVR.DIG002 (END_IP, STATUS, BIO_TIPO);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG002_IND4')
	CREATE INDEX DIG002_IND4 ON TELESSVR.DIG002 (BIO_TIPO, STATUS);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG102_IND2')
	DROP INDEX TELESSVR.DIG102.DIG102_IND2;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG102_IND2')
	CREATE INDEX DIG102_IND2 ON TELESSVR.DIG102 (STATUS, DATA_LOAD);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG102_IND3')
	CREATE INDEX DIG102_IND3 ON TELESSVR.DIG102 (END_IP, STATUS, BIO_TIPO);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG102_IND4')
	CREATE INDEX DIG102_IND4 ON TELESSVR.DIG102 (BIO_TIPO, STATUS);
GO

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'TMP_DIG004')
	BEGIN
		CREATE TABLE TELESSVR.TMP_DIG004 (
			ICARD        	CHAR(12)	NOT NULL,
			END_IP       	VARCHAR(15)	DEFAULT '000.000.000.000' NOT NULL CONSTRAINT ctTmpDig004_01 CHECK ((datalength(END_IP) = 15) and (END_IP NOT IN ('               '))),
			STATUS			CHAR(1),
			BIO_TIPO		CHAR(1)
		)
	END
GO

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'DIG004')
	BEGIN
		CREATE TABLE TELESSVR.DIG004 (
			ICARD        	CHAR(12)	NOT NULL,
			END_IP       	VARCHAR(15)	DEFAULT '000.000.000.000' NOT NULL CONSTRAINT ctDIG004_01 CHECK ((datalength(END_IP) = 15) and (END_IP NOT IN ('               '))),
			STATUS			CHAR(1),
			BIO_TIPO		CHAR(1)
		)
	END
GO


IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG004_IND1')
	DROP INDEX TELESSVR.DIG004.DIG004_IND1;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG004_IND1')
	CREATE UNIQUE INDEX DIG004_IND1 ON TELESSVR.DIG004 (ICARD,END_IP, BIO_TIPO);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG004_IND2')
	DROP INDEX TELESSVR.DIG004.DIG004_IND2;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG004_IND2')
	CREATE UNIQUE INDEX DIG004_IND2 ON TELESSVR.DIG004 (END_IP, ICARD, BIO_TIPO);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG004_IND3')
	DROP INDEX TELESSVR.DIG004.DIG004_IND3;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG004_IND3')
	CREATE INDEX DIG004_IND3 ON TELESSVR.DIG004 (STATUS);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG004_IND4')
	DROP INDEX TELESSVR.DIG004.DIG004_IND4;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG004_IND4')
	CREATE INDEX DIG004_IND4 ON TELESSVR.DIG004 (END_IP, STATUS);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG004_IND5')
	DROP INDEX TELESSVR.DIG004.DIG004_IND5;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG004_IND5')
	CREATE INDEX DIG004_IND5 ON TELESSVR.DIG004 (ICARD, STATUS, BIO_TIPO);
GO

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'TMP_DIG104')
	BEGIN
		CREATE TABLE TELESSVR.TMP_DIG104 (
			ICARD       CHAR(12)	NOT NULL,
			END_IP      VARCHAR(15)	DEFAULT '000.000.000.000' NOT NULL CONSTRAINT ctTmpDig104_01 CHECK ((datalength(END_IP) = 15) and (END_IP NOT IN ('               '))),
			STATUS		CHAR(1),
			BIO_TIPO	CHAR(1)
		)
	END
GO

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'DIG104')
	BEGIN
		CREATE TABLE TELESSVR.DIG104 (
			ICARD       CHAR(12)	NOT NULL,
			END_IP      VARCHAR(15)	DEFAULT '000.000.000.000' NOT NULL CONSTRAINT ctDIG104_01 CHECK ((datalength(END_IP) = 15) and (END_IP NOT IN ('               '))),
			STATUS		CHAR(1),
			BIO_TIPO	CHAR(1)
		)
	END
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG104_IND1')
	DROP INDEX TELESSVR.DIG104.DIG104_IND1;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG104_IND1')
	CREATE UNIQUE INDEX DIG104_IND1 ON TELESSVR.DIG104 (ICARD,END_IP, BIO_TIPO);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG104_IND2')
	DROP INDEX TELESSVR.DIG104.DIG104_IND2;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG104_IND2')
	CREATE UNIQUE INDEX DIG104_IND2 ON TELESSVR.DIG104 (END_IP, ICARD, BIO_TIPO);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG104_IND3')
	DROP INDEX TELESSVR.DIG104.DIG104_IND3;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG104_IND3')
	CREATE INDEX DIG104_IND3 ON TELESSVR.DIG104 (STATUS);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG104_IND4')
	DROP INDEX TELESSVR.DIG104.DIG104_IND4;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG104_IND4')
	CREATE INDEX DIG104_IND4 ON TELESSVR.DIG104 (END_IP, STATUS);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG104_IND5')
	DROP INDEX TELESSVR.DIG104.DIG104_IND5;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DIG104_IND5')
	CREATE INDEX DIG104_IND5 ON TELESSVR.DIG104 (ICARD, STATUS, BIO_TIPO);
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('request_lock'))
	DROP PROCEDURE TELESSVR.request_lock;
GO

CREATE PROCEDURE TELESSVR.request_lock @cMatric char(12), @cUsuario char(15)
AS

DECLARE @ret int, @dh_lock char(30), @difsecond int, @cUsuLock char(15)

	set @ret = 0
	
	BEGIN TRAN
	
	-- locka matricula se esta nao estiver lockada
	if NOT EXISTS (SELECT * from TABLOCKS WITH (XLOCK) where ICARD = @cMatric) begin
		insert into TABLOCKS (ICARD, DATAHORA, USUARIO) values (@cMatric, getdate(), @cUsuario)
	end

	-- se matricula lockada, verifica se o lock tem validade (menos que 10 SEGUNDOS)
	else begin
		select @dh_lock = DATAHORA, @cUsuLock = USUARIO from TABLOCKS WITH (XLOCK) where ICARD = @cMatric
		-- verificar diferenca de minutos
		set @difsecond = DATEDIFF(second, @dh_lock, getdate())
		
		if (@difsecond > 10) begin			-- ERA 60 (SEGUNDOS)
			-- modifica data e hora do lock
			update TABLOCKS set DATAHORA = getdate(), USUARIO = @cUsuario 
			    where ICARD = @cMatric
		end
		else begin
			if (@cUsuario != @cUsuLock) begin
				set @ret = -1     -- lock ativo
			end
		end
	end
	
	COMMIT TRAN
	return (@ret)
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlconG3G5_ace_usuario'))
	DROP PROCEDURE TELESSVR.sqlconG3G5_ace_usuario;
GO

CREATE PROCEDURE TELESSVR.sqlconG3G5_ace_usuario @cMatricNS char(22), @cInform char(20), @cTipTerm char(1), @Usuario char(15), @cOwner char(30), @cDataOcorr char(10), @cVisita char(12) AS
DECLARE	@cReg1 as varchar(250), @cReg2 as varchar(250), @cReg3 as varchar(250), 
		@cReg4 as varchar(250), @RetFun SMALLINT,
		@cReg5 as varchar(250), @cReg6 as varchar(250), @cReg7 as varchar(250), @cReg8 as varchar(250),
		@cReg9 as varchar(250), @cReg10 as varchar(250), @cReg11 as varchar(250)
DECLARE @ret int, @cUsuLock char(15), @cFxDiaEsp char(28), @cFxCred char(4), @Result int, @cMatBusca char(12)
DECLARE	@cIniHalm char(12), @cFimHalm char(12), @cIniIntj char(12), @cFimIntj char(12), @cFimAntD char(12)
DECLARE	@cIniHalmAux char(16), @cFimHalmAux char(16), @cIniIntjAux char(16), @cFimIntjAux char(16), @cFimAntDAux char(16)
DECLARE @dDataBD DATETIME, @dDataOcor DATETIME;
DECLARE @pos int
DECLARE @cModo char(1), @cFazLock char(1), @cDesbloqRev char(1),@cVerNumS char(1)
DECLARE @cVarAux char(12)
DECLARE @nGrest int, @nGrestEquip int, @nCont int
DECLARE @nArea int, @nAreaEquip int
DECLARE	@cEmFixa char(1), @AuxGr char(3), @AuxGr2 varchar(3);
DECLARE @cEscoltado char(12), @cEscolta char(12), @cEndIP char(15), @cTemEsc char(1), @cEhEscolta char(1), @cProcurado char(12), @cSentido CHAR(1)
DECLARE @nContArea int, @cFinalSentido CHAR(1), @AuxSentido CHAR(1), @nAuxArea int

DECLARE
        @cMatric   char(12),
        @cIcard    char(12),
        @cCPF	   char(11),
        @cNumSerial	   char(10),
		@cBloqBDCC char(1),
        --@cGrupo    char(3),
        @cCodig    char(6),
        @cTpFis    char(1),
        @cSitua    char(1),
        --@cSubNv    char(5),
        --@cPlanta   char(3),
        @cDataHora char(10),
        @cUltrs    char(25),
        @cDatIni   char(6),
        @cDatFim   char(6),
        @cTitular  char(12),
        @cFx_Flg   char(1), 
        @cFx_Dta   char(11), 
        @cFx_Alm   char(3),
        @cMensagem char(32), 
        @cDta_mens char(6),
        @cQtd_mens char(2),
        @cCred_Fx1 char(2), 
        @cCred_Fx2 char(2),
        @cCred_Fx3 char(2),
        @cCred_Fx4 char(2),
        @cCred_Fx5 char(2),
        @cCred_Fx6 char(2),
        @cFx1 char(8), 
        @cFx2 char(8), 
        @cFx3 char(8), 
        @cFx4 char(8), 
        @cFx5 char(8), 
        @cFx6 char(8), 
        @cUltPasR  char(10),
        --@cGrupo1   char(3),
        @cDatIniG1 char(10),
        @cDatFimG1 char(10),
        --@cGrupo2   char(3),
        @cDatIniG2 char(10),
        @cDatFimG2 char(10),
        --@cGrupo3   char(3),
        @cDatIniG3 char(10),
        @cDatFimG3 char(10),
        --@cGpoSab   char(3),
        --@cGpoDom   char(3),
        --@cGpoFer   char(3),
        @cAnti_D   char(1),
        @cBloq     char(1),
        @cVHora    char(1),
        @cVLocal   char(1),
        @cVValid   char(1),
        @cVAfast   char(1),
        @cVCred    char(1),
        @cVisEsp   char(1),
        @cVPonto   char(1),
        @cPonto    char(1),	
        @cVDigit   char(1),
      	@cTpoIntj  char(3), 
      	@cTolIntj  char(3), 
      	@cInterj   char(1),
      	@cTpoJorn  char(3), 
      	@cSaidaMax   char(1),
      	@cTipoDoc	char(1),
		@cVnDias   char(2),
		@cDiasSuc  char(2),
		@cPne    char(1),
		@cBloqRev    char(1),
		@cvViaRep char(1)

DECLARE
@cGrupo    char(5),	-- novo
@cSubNv    char(7),	-- novo
@cGrupo1   char(5),	-- novo
@cGrupo2   char(5),	-- novo
@cGrupo3   char(5),	-- novo
@cGpoSab   char(5),	-- novo
@cGpoDom   char(5),	-- novo
@cGpoFer   char(5),	-- novo
@cAdBuf VARCHAR(2),			-- novo
@nTamG int,
@cPlanta   char(5)

/*
DECLARE
@cGrupo    varchar(5),	-- novo
@cSubNv    varchar(7),	-- novo
@cGrupo1   varchar(5),	-- novo
@cGrupo2   varchar(5),	-- novo
@cGrupo3   varchar(5),	-- novo
@cGpoSab   varchar(5),	-- novo
@cGpoDom   varchar(5),	-- novo
@cGpoFer   varchar(5),	-- novo
@cAdBuf CHAR(2),			-- novo
@nTamG int,
@cPlanta   varchar(5)
*/


DECLARE @stmt1 nvarchar(4000)
DECLARE @ParmDefinition nvarchar(500);



	SET LOCK_TIMEOUT 1000	
	SET @RetFun = 0
	SET @cReg1  = ''
	SET @cReg2  = ''
	SET @cReg3  = ''
	SET @cReg4  = ''

	SET @cReg5  = ''
	SET @cReg6  = ''
	SET @cReg7  = ''
	SET @cReg8  = ''
	SET @cUsuLock = @Usuario

	SELECT @cAdBuf = null
	SELECT @nTamG = 3 
	SELECT	@nTamG  = COLUNAS.LENGTH
	FROM 
		SYSOBJECTS AS TABELAS,
		SYSCOLUMNS AS COLUNAS
	WHERE 
		-- JOINS 
		TABELAS.ID = COLUNAS.ID
		AND TABELAS.NAME = 'DAT07'
		AND COLUNAS.NAME = 'LACES'


	SET @Result = 1	
	SET @cMatric = substring(@cMatricNS, 1, 12);
	SET @cMatBusca = '000000000000'
	SET @cTipoDoc = '0'
	SET @cBloqBDCC = '0'
	SET @cFx1 = '24002400'
	SET @cFx2 = '24002400'
	SET @cFx3 = '24002400'
	SET @cFx4 = '24002400'
	SET @cFx5 = '24002400'
	SET @cFx6 = '24002400'

	set DATEFORMAT dmy
	SET @dDataOcor = CAST((substring(@cDataOcorr,5,2)+'-'+
							 substring(@cDataOcorr,7,2)+'-'+
							 substring(@cDataOcorr,9,2)+' '+
							 substring(@cDataOcorr,1,2)+':'+
							 substring(@cDataOcorr,3,2)+':'+
							 '00') AS datetime);

	SET @cModo = substring(@cInform, 1, 1);  -- TIPO DE PESQUISA
	-- cModo = 0 :icard; 
	-- cModo = 1 :numero serial
	-- cModo = 2 :cpf
	-- cModo = 3 :bdcc


	SET @cFazLock = 	substring(@cInform, 3, 1);  -- SE CONSULTA ONLINE
	SET @cDesbloqRev = 	substring(@cInform, 4, 1);  -- SE DESBLOQUEIO REVISTA
	SET @cVerNumS = 	substring(@cInform, 5, 1);  -- SE verifica NUMSERIAL
	SET @cEhEscolta =  	substring(@cInform, 6, 1);	-- SE É INDICADOR DE ESCOLTA

	-- *******************************************************
	-- verifica se modo de busca é por CPF
	IF (@cModo ='2') begin					-- CPF
		SELECT	@cIcard   = a.ICARD,
				@cCPF	  = c.CPF,
				@cTipoDoc = c.TIPODOC
				
			FROM ContCPF c 
				INNER JOIN Controle a
					ON c.CPF = substring(@cMatric, 2, 11) and c.icard = a.icard 

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end
	
	-- *******************************************************
	-- verifica se modo de busca é por ICARD
	ELSE IF (@cModo = '0') begin  			-- ICARD
		IF (@cVerNumS = '1') BEGIN
			SELECT	@cIcard   = a.ICARD,
					@cNumSerial  = a.NUMSERIAL
				FROM Controle a 
			WHERE a.ICARD = @cMatric and
   				  a.NumSerial = substring(@cMatricNS, 13, 10) 
				
			IF (@@ROWCOUNT = 0) begin
				-- SITUACAO SURICATO: VARIOS CARTOES SM COM MESMO ICARD, E NA CONTROLE ESTAO OS VALORES DE NUM.SERIAL NA COLUNA ICARD, TODOS COM O MESMO VALOR DO TITULAR
				-- A BUSCA PRIMEIRO SERA FEITA ICARD+NUMSERIAL. SE NÃO ACHOU, QUE É ONDE SE ENCONTRA AGORA, A BUSCA SERÁ SOBRE TITULAR+ICARD. QDO ENCONTRAR, O VALOR DE
				-- CMATBUSCA SERÁ O VALOR DO CAMPO ICARD

				SELECT	@cIcard   = a.TITULAR,
						@cVarAux  = a.ICARD
					FROM Controle a 
				WHERE a.TITULAR = @cMatric and
					  a.ICARD = '00'+substring(@cMatricNS, 13, 10) 

				IF (@@ROWCOUNT = 0) begin
					set @cIcard = '000000000000'	-- 12 zeros
					SET @RetFun = -2
					SET @Result = 0	
				end
				ELSE begin
					SET	@cMatBusca = @cIcard;
				end
			end
			ELSE begin
				SET	@cMatBusca = @cIcard;
			end
		end	

		ELSE begin
			SET @cMatBusca = @cMatric;
		end
	end
				
	-- *******************************************************
	-- verifica se modo de busca é por NUMERO SERIAL
	ELSE IF (@cModo = '1') begin  			-- NUMERO SERIAL
		SELECT	@cIcard   = a.ICARD,
				@cNumSerial  = a.NUMSERIAL
				
			FROM Controle a 
				WHERE a.NumSerial = substring(@cMatric, 3, 10) 
	
		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end


	-- *******************************************************
	-- verifica se modo de busca é por BDCC
	ELSE IF (@cModo = '3') begin  		
		SELECT	@cIcard   = a.ICARD,
				@cBloqBDCC  = c.Bloqueado
				
			FROM bdcc_cracha c 
			INNER JOIN Controle a
				ON c.Cracha = @cMatric and 
				   c.Cracha = a.ICARD  

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end


	-- *******************************************************
	-- verifica se encontrou o usuario, entao coleta informacoes do usuario
	IF (@Result = 1) begin			
		
		-- COLETA faixa horaria do usuario de acordo com o tipo de terminal 
				
		IF (@cTipTerm = '3') begin		  -- TERMINAL TIPO PONTO
			-- colocar 'X' no final de cReg1,cReg2,cReg3 e cReg4 pois o SQL trunca   valores
			-- com campos que contem branco (se o campo for o ultimo a ser concatenado)
			SELECT @cIcard    = a.ICARD,
					   @cReg1 = b.FX_DOM_P + b.FX_SEG_P + b.FX_TER_P + 'X', 
					   @cReg2 = b.FX_QUA_P + b.FX_QUI_P + b.FX_SEX_P + 'X', 
					   @cReg3 = b.FX_SAB_P + b.FX_REF + 'X',
					   --@cReg4 = a.FX_1 + a.FX_2 + a.FX_3 + a.FX_4 + a.FX_5 + a.FX_6 + 'X'
					   @cFx1 = a.FX_1, @cFx2 = a.FX_2, @cFx3 = a.FX_3, @cFx4 = a.FX_4, @cFx5 = a.FX_5, @cFx6 = a.FX_6
					   
			FROM  Controle a
				INNER JOIN  FxHoraria b  
					ON a.ICard = @cMatBusca and b.ICard = a.ICard
		end  			
		
		ELSE begin						-- TERMINAL QUE NAO É PONTO (ACESSO)
			SELECT @cIcard    = a.ICARD,
				   @cReg1 = b.FX_DOM_A + b.FX_SEG_A + b.FX_TER_A + 'X', 
				   @cReg2 = b.FX_QUA_A + b.FX_QUI_A + b.FX_SEX_A + 'X', 
				   @cReg3 = b.FX_SAB_A + b.FX_REF + 'X',
				   --@cReg4 = a.FX_1 + a.FX_2 + a.FX_3 + a.FX_4 + a.FX_5 + a.FX_6 + 'X' 
				   @cFx1 = a.FX_1, @cFx2 = a.FX_2, @cFx3 = a.FX_3, @cFx4 = a.FX_4, @cFx5 = a.FX_5, @cFx6 = a.FX_6
			FROM  Controle a
				INNER JOIN  FxHoraria b  
					ON a.ICard = @cMatBusca and b.ICard = a.ICard
		end

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
		end

		-- *******************************************************
		-- COLETA outros dados do usuario
		ELSE begin
			SELECT	@cIcard   = a.ICARD,
					@cGrupo   = a.GRUPO,
					@cCodig   = a.CODIG,
					@cTpFis   = a.TPFIS, 
					@cSitua   = a.SITUA,
					@cSubNv   = a.SUBNV,
					@cPlanta  = a.PLANTA,
					@cDataHora = a.DATAHORA,
					@cUltrs    = a.ULTRS,
					@cDatIni   = a.DATINI,
					@cDatFim   = a.DATFIM,
					@cTitular  = a.TITULAR,
					@cFx_Flg   = a.FX_FLG,
					@cFx_Dta   = a.FX_DTA,
					@cFx_Alm   = a.TEMPO_ALM,
					@cMensagem = a.MENSAGEM,
					@cDta_mens = a.DTA_MENS, 
					@cQtd_mens = a.QTD_MENS,
					@cCred_Fx1 = a.CRED_FX1,
					@cCred_Fx2 = a.CRED_FX2,
					@cCred_Fx3 = a.CRED_FX3,
					@cCred_Fx4 = a.CRED_FX4,
					@cCred_Fx5 = a.CRED_FX5,
					@cCred_Fx6 = a.CRED_FX6,
					@cUltPasR  = a.ULTPAS_REF,
					@cGrupo1   = a.GRUPO1,
					@cDatIniG1 = a.DATINIG1,
					@cDatFimG1 = a.DATFIMG1,
					@cGrupo2   = a.GRUPO2,
					@cDatIniG2 = a.DATINIG2,
					@cDatFimG2 = a.DATFIMG2,
					@cGrupo3   = a.GRUPO3,
					@cDatIniG3 = a.DATINIG3,
					@cDatFimG3 = a.DATFIMG3,
					@cGpoSab   = a.GRUPO_SAB,
					@cGpoDom   = a.GRUPO_DOM,
					@cGpoFer   = a.GRUPO_FER,
					@cAnti_D   = a.ANTI_DUPLA,
					@cBloq     = a.BLOQ_FALTA,
					@cVHora    = a.VER_HORA,
					@cVLocal   = a.VER_LOCAL,
					@cVValid   = a.VER_VALID,
					@cVAfast   = a.VER_AFAST,
					@cVCred    = a.VER_CRED,
					@cVisEsp   = a.VIS_ESP,
					@cVDigit   = a.VER_DIGIT,

					@cTpoIntj = a.TEMPO_RET,				
					@cTolIntj = a.TOLER_RET,
					@cInterj  = a.VER_RET,

					@cTpoJorn  = a.TEMPO_JORNADA, 
					@cSaidaMax = a.VER_SAIDAMAX,
					@cVnDias   = a.VER_NDIAS,
					@cPne      = a.PNE,
					@cBloqRev  = a.BLOQREV,
					@cvViaRep  = a.VER_VIAREP

				FROM Controle a
					WHERE  a.icard = @cMatBusca

			IF (@@ROWCOUNT = 0) begin
				set @cIcard = '000000000000'	-- 12 zeros
				SET @RetFun = -2
			end

			-- *******************************************************
			-- locka usuario se necessario
			ELSE begin
				IF (@cSitua = '4') or (@cFazLock = '0') begin 	-- se Provisorio, não 'bloqueia'. Sera 'bloqueado' o Titular
					set @ret = 0
				end
				ELSE begin
					SET @stmt1 = 'execute @p1 = ' + @cOwner + '.request_lock @cMat, @cUsu'
					SET @ParmDefinition = N'@cMat nvarchar(30), @cUsu CHAR(15), @p1 int OUTPUT ';		
					EXEC sp_executesql @stmt1, 
									@ParmDefinition, 
									@cMat = @cMatric, 
									@cUsu = @Usuario,
									@p1 = @ret OUTPUT		
				end		
	
				-- *******************************************************
				-- verifica se dados são nulos para preencher com valores default
				IF (@ret = 0) begin
					SET @cFxDiaEsp = SPACE(28);
					SET @cFxCred   = SPACE(4);
					-- Armazena dados da matricula em Registro
					-- colocar 'X' no final de cReg1, cReg2 e cReg3 pois o SQL trunca            -- valores com campos que contem branco (se o campo for o ultimo a ser       -- concatenado)
					if (@cCodig is Null) 
						SET @cCodig = SPACE(6);
					if (@cTpFis is Null) 
						SET @cTpFis = SPACE(1);
					if (@cSubNv is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cSubNv = '00'+SPACE(3);	-- 3 espacos
						ELSE
							SET @cSubNv = '00'+SPACE(5);	-- 5 espacos
					END
						
					if (@cPlanta is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cPlanta = '000';		--3
						ELSE
							SET @cPlanta = '00000';		-- 5 
					END

					if (@cDataHora is Null) 
						SET @cDataHora = '3112202359';
					if (@cUltrs is Null) 
						SET @cUltrs = '0101902359'+SPACE(10);
					if (@cFx_Flg is Null)  
						SET @cFx_Flg = '0';		-- 1 
					if (@cFx_Dta is Null)  
						SET @cFx_Dta = SPACE(11);
					if (@cFx_Alm is Null)  
						SET @cFx_Alm = SPACE(3);
					if (@cDatIni is Null) 
						SET @cDatIni = SPACE(6);
					if (@cDatFim is Null) 
						SET @cDatFim = SPACE(6);
					if (@cTitular is Null) 
						SET @cTitular = SPACE(12);
					if (@cMensagem is Null)  
						SET @cMensagem = SPACE(32);
					if (@cDta_mens is Null)  
						SET @cDta_mens = SPACE(6);
					if (@cQtd_mens is Null)  
						SET @cQtd_mens = SPACE(2);
					if (@cCred_Fx1 is Null)  
						SET @cCred_Fx1 = '00';		-- 2
					if (@cCred_Fx2 is Null)  
						SET @cCred_Fx2 = '00';		-- 2
					if (@cCred_Fx3 is Null)  
						SET @cCred_Fx3 = '00';		-- 2
					if (@cCred_Fx4 is Null)  
						SET @cCred_Fx4 = '00';		-- 2
					if (@cCred_Fx5 is Null)  
						SET @cCred_Fx5 = '00';		-- 2
					if (@cCred_Fx6 is Null)  
						SET @cCred_Fx6 = '00';		-- 2
					if (@cUltPasR is Null)  
						SET @cUltPasR = SPACE(10);

					if (@cGrupo1 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo1 = '000';	-- 3 
						ELSE
							SET @cGrupo1 = '00000'	-- 5 
					END
					if (@cDatIniG1 is Null) 
						SET @cDatIniG1 = SPACE(10);
					if (@cDatFimG1 is Null) 
						SET @cDatFimG1 = SPACE(10);

					if (@cGrupo2 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo2 = '000';	-- 3 
						ELSE
							SET @cGrupo2 = '00000'	-- 5 
					END
					if (@cDatIniG2 is Null) 
						SET @cDatIniG2 = SPACE(10);
					if (@cDatFimG2 is Null) 
						SET @cDatFimG2 = SPACE(10);
					
					if (@cGrupo3 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo3 = '000';	-- 3 
						ELSE
							SET @cGrupo3 = '00000'	-- 5 
					END
					if (@cDatIniG3 is Null) 
						SET @cDatIniG3 = SPACE(10);
					if (@cDatFimG3 is Null) 
						SET @cDatFimG3 = SPACE(10);

					if (@cGpoSab is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoSab = '000';	-- 3 
						ELSE
							SET @cGpoSab = '00000'	-- 5 
					END

					if (@cGpoDom is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoDom = '000';	-- 3 
						ELSE
							SET @cGpoDom = '00000'	-- 5 
					END

					if (@cGpoFer is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoFer = '000';	-- 3 
						ELSE
							SET @cGpoFer = '00000'	-- 5 
					END

					if (@cVisEsp is Null) 
						SET @cVisEsp = '0';		-- 1
					if (@cVDigit is Null) 
						SET @cVDigit = '2';		-- 1
					if (@cTpoIntj is Null) 
						SET @cTpoIntj = '000';		-- 3
					if (@cTolIntj is Null)
						SET @cTolIntj = '000';		-- 3
					if (@cInterj is Null)
						SET @cInterj = '0';		-- 1 
					if (@cTpoJorn is Null)
						SET @cTpoJorn = '000';		-- 3
					if (@cSaidaMax is Null)
						SET @cSaidaMax = '0';		-- 1 
					if (@cTipoDoc is Null)
						SET @cTipoDoc = '2';		-- 1 

					if (@cVnDias is Null) 
						SET @cVnDias = '00';		-- 2

					if (@cPne is Null)
						SET @cPne = '0';		-- 1 
					if (@cBloqRev is Null)
						SET @cBloqRev = '0';		-- 1 
					if (@cvViaRep is Null)
						SET @cvViaRep = '0';		-- 1 

					if (@cFx1 is Null)
						SET @cFx1 = '24002400';		-- 8 
					if (@cFx2 is Null)
						SET @cFx2 = '24002400';		-- 8 
					if (@cFx3 is Null)
						SET @cFx3 = '24002400';		-- 8 
					if (@cFx4 is Null)
						SET @cFx4 = '24002400';		-- 8 
					if (@cFx5 is Null)
						SET @cFx5 = '24002400';		-- 8 
					if (@cFx6 is Null)
						SET @cFx6 = '24002400';		-- 8 


					IF (@nTamG = 3) 
						SELECT @cAdBuf = SPACE(2);		-- 2 espços
					ELSE
						SELECT @cAdBuf = null


					SET @cReg4 = @cFx1 + @cFx2 + @cFx3 + @cFx4 + @cFx5 + @cFx6 + 'X'
					
					SET @cReg5 = @cIcard + @cGrupo + 
								 @cCodig + @cTpFis + @cSitua + @cSubNv + 
								 @cPlanta + 
								 'X'
					
					/*
					SET @cReg5 = @cIcard + @cGrupo + COALESCE(@cAdBuf, '') + 
								 @cCodig + @cTpFis + @cSitua + @cSubNv + COALESCE(@cAdBuf, '') + 
								 @cPlanta + COALESCE(@cAdBuf, '') + 'X'
					*/
					

					SET @cReg6 = substring(@cDataHora,1,10) + @cUltrs + @cFx_Flg + @cFx_Dta + @cFx_Alm + 
								 @cFxDiaEsp + @cDatIni + @cDatFim + @cMensagem + @cDta_mens + @cQtd_mens  + 
								 @cCred_Fx1 + @cFxCred +
								 @cCred_Fx2 + @cFxCred +
								 @cCred_Fx3 + @cFxCred +
								 @cCred_Fx4 + @cFxCred +
								 @cCred_Fx5 + @cFxCred +
								 @cCred_Fx6 + @cFxCred +
								 @cUltPasR + @cTitular  + 'X'
								 
					SET @cReg7 = @cGrupo1 + @cDatIniG1 + @cDatFimG1 +
								 @cGrupo2 + @cDatIniG2 + @cDatFimG2 +
								 @cGrupo3 + @cDatIniG3 + @cDatFimG3 +
								 @cGpoSab + 
								 @cGpoDom + 
								 @cGpoFer + 
								 @cAnti_D + @cBloq + @cVHora + @cVLocal +
								 @cVValid + @cVAfast + @cVCred + @cVisEsp + 'X'


					/*
					SET @cReg7 = @cGrupo1 + COALESCE(@cAdBuf, '') + @cDatIniG1 + @cDatFimG1 +
								 @cGrupo2 + COALESCE(@cAdBuf, '') + @cDatIniG2 + @cDatFimG2 +
								 @cGrupo3 + COALESCE(@cAdBuf, '') + @cDatIniG3 + @cDatFimG3 +
								 @cGpoSab + COALESCE(@cAdBuf, '') + 
								 @cGpoDom + COALESCE(@cAdBuf, '') + 
								 @cGpoFer + COALESCE(@cAdBuf, '') + 
								 @cAnti_D + @cBloq + @cVHora + @cVLocal +
								 @cVValid + @cVAfast + @cVCred + @cVisEsp + 'X'
					*/					


					IF (@cDesbloqRev = '1')  
						SET @cBloqRev = '0'
					

					--SET @cReg8 = @cIcard + '0' + '0' + @cVDigit + 
					SET @cReg8 = @cIcard + @cvViaRep + '0' + @cVDigit + 
								 @cTpoIntj + @cTolIntj + @cInterj + 
								 @cTpoJorn + @cSaidaMax + 
								 @cTipoDoc + '00' + @cVnDias + 
								 --@cPne + @cBloqRev + 'X'
								 @cPne + @cBloqRev
				end
				-- matricula ja lockada
				ELSE
					SET @RetFun = -3
			end
		end
	END

	SET DATEFORMAT dmy
	SELECT @cIniHalmAux = CONVERT(char(8), a.Ini_Halm, 3)+ CONVERT(char(8), a.Ini_Halm, 8),
		   @cFimHalmAux = CONVERT(char(8), a.Fim_Halm, 3)+ CONVERT(char(8), a.Fim_Halm, 8),
		   @cIniIntjAux = CONVERT(char(8), a.Ini_Intj, 3)+ CONVERT(char(8), a.Ini_Intj, 8),
		   @cFimIntjAux = CONVERT(char(8), a.Fim_Intj, 3)+ CONVERT(char(8), a.Fim_Intj, 8),
		   @cFimAntDAux = CONVERT(char(8), a.Fim_AntiD, 3)+ CONVERT(char(8), a.Fim_AntiD, 8) ,
		   @cDiasSuc = a.Dias_Suc   
		   
	FROM DATAHORA a 
	WHERE a.ICARD = @cMatBusca
	
	IF (@@ROWCOUNT = 0) begin
  		SET @cIniHalm = '010106000000'	-- 01/01/06
		SET @cFimHalm = '010106000000'	-- 01/01/06
		SET @cIniIntj = '010106000000'	-- 01/01/06
		SET @cFimIntj = '010106000000'	-- 01/01/06
		SET @cFimAntD = '010106000000'	-- 01/01/06
		SET @cDiasSuc = '00';
	end
	ELSE begin
		SET @cIniHalm = substring (@cIniHalmAux,1,2)+substring (@cIniHalmAux, 4,2)+substring (@cIniHalmAux, 7,2)+
						substring (@cIniHalmAux,9,2)+substring (@cIniHalmAux,12,2)+substring (@cIniHalmAux,15,2)
		SET @cFimHalm = substring (@cFimHalmAux,1,2)+substring (@cFimHalmAux, 4,2)+substring (@cFimHalmAux, 7,2)+
						substring (@cFimHalmAux,9,2)+substring (@cFimHalmAux,12,2)+substring (@cFimHalmAux,15,2)
		SET @cIniIntj = substring (@cIniIntjAux,1,2)+substring (@cIniIntjAux, 4,2)+substring (@cIniIntjAux, 7,2)+
						substring (@cIniIntjAux,9,2)+substring (@cIniIntjAux,12,2)+substring (@cIniIntjAux,15,2)
		SET @cFimIntj = substring (@cFimIntjAux,1,2)+substring (@cFimIntjAux, 4,2)+substring (@cFimIntjAux, 7,2)+
						substring (@cFimIntjAux,9,2)+substring (@cFimIntjAux,12,2)+substring (@cFimIntjAux,15,2)
		SET @cFimAntD = substring (@cFimAntDAux,1,2)+substring (@cFimAntDAux, 4,2)+substring (@cFimAntDAux, 7,2)+
						substring (@cFimAntDAux,9,2)+substring (@cFimAntDAux,12,2)+substring (@cFimAntDAux,15,2)
	END
	
	SET @cReg9 = @cIcard + @cIniHalm + @cFimHalm + @cIniIntj + @cFimIntj + @cFimAntD + @cDiasSuc + 'X';

	--SET @cReg10 = @cBloqBDCC + 'X';
	SET @cReg10 = @cBloqBDCC;

	-- *******************************************************
	-- atualiza tab.CONTROLE se o usuario foi liberado pelo equipamento para revista
	IF (@RetFun = 0 AND 
		@Result = 1 AND 
		@cDesbloqRev = '1') begin
			IF (@cFazLock = '0') begin				-- marcacao offline
				SET @pos = CHARINDEX(' ', @cUltrs);  	-- VERIFICA SE data armazenada em BD tem valor em branco

				IF (@pos <= 10) and (@pos > 0) 
					SET @dDataBD = @dDataOcor;		-- assume temporariamente a mesma data de ocorrencia para que haja tualização
				ELSE begin
					set DATEFORMAT dmy
					SET @dDataBD = CAST((substring(@cUltrs,1,2)+'-'+substring(@cUltrs,3,2)+'-'+substring(@cUltrs,5,2)+' '+
							 			 substring(@cUltrs,7,2)+':'+substring(@cUltrs,9,2)+':'+'00') AS datetime);					
				end
				
				IF (@dDataOcor >= @dDataBD) 			-- atualiza BD porque a marcacao offline é mais recente que está em BD
					UPDATE CONTROLE SET BLOQREV = '0' WHERE ICARD = @cMatBusca;
			end
			ELSE
				UPDATE CONTROLE SET BLOQREV = '0' 
					WHERE ICARD = @cMatBusca
	end		
				
	-- *******************************************************
	-- verifica grupo do Estacionamento
	SET @nGrest = 0;
	SET @nGrestEquip = 0;
	SET @cEmFixa = '0';
	
	SELECT @nGrest = convert(int, GREST)  			-- VERIFICA SE O EQUIPAMENTO PERTENCE A ALGUM ESTACIONAMENTO
		FROM ESTAC001 
		WHERE END_IP = @Usuario;
	
	IF (@@ROWCOUNT = 0) begin
		SET @nGrest = 0;
		SET @nGrestEquip = 0;
	end			
	ELSE begin
		SET @nGrestEquip = @nGrest;
		
		SELECT @cEmFixa = EMFIXA   					-- VERIFICA SE A MATRICULA POSSUI VAGA FIXA NESTE ESTACIONAMENTO
			FROM ESTAC003 
			WHERE ICARD = @cMatBusca AND GREST = @nGrest;
			
		IF (@@ROWCOUNT = 0)			
			SET @nGrest = 0;
	END;


	SET @AuxGr2 = convert(char, @nGrest);
	SET @AuxGr = REPLICATE('0',3-LEN(@AuxGr2) ) + @AuxGr2;
	SET @cReg8 = @cReg8 + @AuxGr;								-- grupo de estacionamento do qual o usuario tem vaga fixa
	SET @cReg8 = @cReg8 + @cEmFixa + 'X';						-- indicador se estacionou em vaga fixa

	SET @AuxGr2 = convert(char, @nGrestEquip);
	SET @AuxGr = REPLICATE('0',3-LEN(@AuxGr2) ) + @AuxGr2;			-- grupo de estacionamento ao qual o equipamento faz parte
	SET @cReg10 = @cReg10 + @AuxGr + 'X'		-- posic 1 a 3		



	-- *******************************************************
	-- verifica Area de ESCOLTA
	SET @cTemEsc = '0'

	IF (@cEhEscolta = '0')		-- não é a escolta
	BEGIN
		SET @cProcurado = @cMatBusca
		SET @nContArea = 0
		SET @cFinalSentido = '0'
		
		SET @cEscoltado = @cMatBusca
		SET @cEscolta = '000000000000'
		SET @cTemEsc = '0'
		SET @cSentido = '0'
	
		
		DECLARE escolt_cur CURSOR FOR
			SELECT AREA, SENTIDO FROM ESCOLT002 
				WHERE END_IP = @Usuario
				ORDER by AREA;

		OPEN escolt_cur
		FETCH next from escolt_cur into @nAuxArea, @AuxSentido
		WHILE (@@fetch_status != -1)
		BEGIN
			SET @nContArea = @nContArea + 1
		
			-- localiza a AREA e MATRICULA NA TABELA DE PESSOAS A SEREM ESCOLTADAS
			IF EXISTS (
				SELECT ICARD_ESCOLTADO, AREA 
					FROM ESCOLT001 
					WHERE ICARD_ESCOLTADO = @cProcurado AND
						  AREA = @nAuxArea)

			BEGIN
				SET @cFinalSentido = 
				CASE 
					WHEN @cFinalSentido = '0' 
						THEN ( @AuxSentido)
					WHEN @cFinalSentido = '1' AND (@AuxSentido = '2' OR  @AuxSentido = '3') 
						THEN '3'
					WHEN @cFinalSentido = '2' AND (@AuxSentido = '1' OR  @AuxSentido = '3')
						THEN '3'
						ELSE @cFinalSentido
				END
					
				SET @cTemEsc = '1'
				SET @cSentido = @cFinalSentido
			END
			
			FETCH next from escolt_cur into @nAuxArea, @AuxSentido
		END
		
		CLOSE escolt_cur
		DEAllocate escolt_cur
	END


	-- É A ESCOLTA
	ELSE BEGIN
	
		SET @nContArea = 0
		SET @cEscoltado = @cVisita
		SET @cEscolta = '000000000000'
		SET @cTemEsc = '0'
		SET @cSentido = '0'
	
		DECLARE escolt_cur CURSOR FOR
			SELECT AREA FROM ESCOLT002 
				WHERE END_IP = @Usuario
				ORDER by AREA;

	
		OPEN escolt_cur
		FETCH next from escolt_cur into @nAuxArea
		WHILE (@@fetch_status != -1)
		BEGIN
			SET @nContArea = @nContArea + 1
		
			-- VERIFICA SE A MATRICULA É AUTORIZADA A SER  ESCOLTA 

			IF EXISTS (
				SELECT ICARD_ESCOLTADO, AREA 
					FROM ESCOLT001 
					WHERE ICARD_ESCOLTADO = @cVisita AND
					   	  ICARD_GUARDA = @cMatBusca AND 
					      AREA = @nAuxArea)
			BEGIN
				SET @cEscoltado = @cVisita;
				SET @cEscolta = @cMatBusca;
				SET @cTemEsc = '0'	
				--SET @@fetch_status  = -1
				BREAK
			END
			ELSE
				FETCH next from escolt_cur into @nAuxArea
		END
		CLOSE escolt_cur
		DEAllocate escolt_cur
	END

	
	SET @cReg11 = @cEscoltado + @cEscolta + @cTemEsc + @cSentido + 'X';

	


	SET LOCK_TIMEOUT -1		
	
	SELECT @RetFun, 
		@cReg1, 
		@cReg2, 
		@cReg3, 
		@cReg4, 
		@cReg5, 
		@cReg6, 
		@cReg7, 
		@cReg8, 
		@cReg9,
		@cReg10,
		@cReg11,
		@nTamG		
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlatG3G5_dados_smartseg'))
	DROP PROCEDURE TELESSVR.sqlatG3G5_dados_smartseg;
GO

CREATE PROCEDURE TELESSVR.sqlatG3G5_dados_smartseg @cRegistro VARCHAR(100), @cRegdh VARCHAR(120), @Faixa INT, @Tipo INT 
AS


DECLARE
    @NumMat VARCHAR(12),
    --@cSUBNV VARCHAR(5),
    @SUBNV VARCHAR(9),
    @ULTRS VARCHAR(25),
    @QTD_MENS VARCHAR(2),
    @CRED_FX VARCHAR(2),
    @ULTPAS_REF VARCHAR(10),
    @SITUA VARCHAR(1),
    --@PLANTA VARCHAR(3),
    @PLANTA VARCHAR(9),
    @ULTRSEG VARCHAR(2),
    @VarAux VARCHAR(12),
    @Retorno SMALLINT, 
    @IniHA datetime, 
    @FimHA  datetime, 
    @IniIJ  datetime, 
    @FimIJ  datetime,
	@FimAntD datetime,
    @cDiasSuc VARCHAR(2),
    @nTamG int

      
	SET @Retorno = 0
	SET @NumMat = substring(@cRegistro, 1, 12)
	
	SET @nTamG = 3 
	SELECT	@nTamG  = COLUNAS.LENGTH
		FROM 
			SYSOBJECTS AS TABELAS,
			SYSCOLUMNS AS COLUNAS
		WHERE 
			-- JOINS 
			TABELAS.ID = COLUNAS.ID
			AND TABELAS.NAME = 'CONTROLE'
			AND COLUNAS.NAME = 'GRUPO'

	IF (@nTamG = 5) begin 		
		SET @SUBNV =  substring(@cRegistro, 13, 7);
		SET @PLANTA = substring(@cRegistro, 60, 5);
	end
	ELSE begin
		SET @SUBNV = substring (substring(@cRegistro, 13, 7), 1, 5);
		SET @PLANTA = substring (substring(@cRegistro, 60, 5), 1, 3);
	end

	
	
	IF @Tipo in (1,3,5,7) BEGIN	-- atualiza CONTROLE   
		IF NOT EXISTS (SELECT ICARD from CONTROLE WHERE ICARD = @NumMat)
			SET @Retorno = -1
		ELSE BEGIN
			--SET @SUBNV = substring(@cRegistro, 13, 5)
			SET @ULTRS = substring(@cRegistro, 20, 25)			-- subnv alterou de tamanho 5 para 7
			SET @QTD_MENS = substring(@cRegistro, 45, 2)
			SET @CRED_FX = substring(@cRegistro, 47, 2)
			SET @ULTPAS_REF = substring(@cRegistro, 49, 10)
			SET @SITUA = substring(@cRegistro, 59, 1)
			--SET @PLANTA = substring(@cRegistro, 60, 3)
			SET @ULTRSEG = substring(@cRegistro, 65, 2)			-- planta alterou de tamanho 3 para 5

			IF (@Faixa = 1)
				UPDATE CONTROLE SET
					SUBNV = @SUBNV,
					ULTRS = @ULTRS,
					QTD_MENS = @QTD_MENS,
					CRED_FX1 = @CRED_FX,
					ULTPAS_REF = @ULTPAS_REF,
					SITUA = @SITUA,
					PLANTA = @PLANTA,
					ULTRSEG = @ULTRSEG
				  WHERE ICARD = @NumMat	
				  
			ELSE IF (@Faixa = 2)
				UPDATE CONTROLE SET
					SUBNV = @SUBNV,
					ULTRS = @ULTRS,
					QTD_MENS = @QTD_MENS,
					CRED_FX2 = @CRED_FX,
					ULTPAS_REF = @ULTPAS_REF,
					SITUA = @SITUA,
					PLANTA = @PLANTA,
					ULTRSEG = @ULTRSEG
				WHERE ICARD = @NumMat
				
			ELSE IF (@Faixa = 3)
				UPDATE CONTROLE SET
					SUBNV = @SUBNV,
					ULTRS = @ULTRS,
					QTD_MENS = @QTD_MENS,
					CRED_FX3 = @CRED_FX,
					ULTPAS_REF = @ULTPAS_REF,
					SITUA = @SITUA,
					PLANTA = @PLANTA,
					ULTRSEG = @ULTRSEG
				WHERE ICARD = @NumMat
				
			ELSE IF (@Faixa = 4)
				UPDATE CONTROLE SET
					SUBNV = @SUBNV,
					ULTRS = @ULTRS,
					QTD_MENS = @QTD_MENS,
					CRED_FX4 = @CRED_FX,
					ULTPAS_REF = @ULTPAS_REF,
					SITUA = @SITUA,
					PLANTA = @PLANTA,
					ULTRSEG = @ULTRSEG
				WHERE ICARD = @NumMat
				
			ELSE IF (@Faixa = 5)
				UPDATE CONTROLE SET
					SUBNV = @SUBNV,
					ULTRS = @ULTRS,
					QTD_MENS = @QTD_MENS,
					CRED_FX5 = @CRED_FX,
					ULTPAS_REF = @ULTPAS_REF,
					SITUA = @SITUA,
					PLANTA = @PLANTA,
					ULTRSEG = @ULTRSEG
				WHERE ICARD = @NumMat
				
			ELSE IF (@Faixa = 6)
				UPDATE CONTROLE SET
					SUBNV = @SUBNV,
					ULTRS = @ULTRS,
					QTD_MENS = @QTD_MENS,
					CRED_FX6 = @CRED_FX,
					ULTPAS_REF = @ULTPAS_REF,
					SITUA = @SITUA,
					PLANTA = @PLANTA,
					ULTRSEG = @ULTRSEG
				WHERE ICARD = @NumMat
				
			ELSE
				UPDATE CONTROLE SET
					SUBNV = @SUBNV,
					ULTRS = @ULTRS,
					QTD_MENS = @QTD_MENS,
					SITUA = @SITUA,
					PLANTA = @PLANTA,
					ULTRSEG = @ULTRSEG
				WHERE ICARD = @NumMat
		END
	END
	IF @Tipo in (2,6) BEGIN	-- atualiza CONTROLE  MAS SOMENTE ULTPASREF E CREDITOS
		IF NOT EXISTS (SELECT ICARD from CONTROLE WHERE ICARD = @NumMat)
			SET @Retorno = -1
		ELSE IF (@Faixa = 1)
			UPDATE CONTROLE  
				SET CRED_FX1 = substring(@cRegistro, 45, 2),
					ULTPAS_REF = substring(@cRegistro, 47, 10)
			WHERE ICARD = @NumMat
		ELSE IF (@Faixa = 2)
			UPDATE CONTROLE  
				SET CRED_FX2 = substring(@cRegistro, 45, 2),
					ULTPAS_REF = substring(@cRegistro, 47, 10)
			WHERE ICARD = @NumMat
		ELSE IF (@Faixa = 3)
			UPDATE CONTROLE  
				SET CRED_FX3 = substring(@cRegistro, 45, 2),
					ULTPAS_REF = substring(@cRegistro, 47, 10)
			WHERE ICARD = @NumMat
		ELSE IF (@Faixa = 4)
			UPDATE CONTROLE  
				SET CRED_FX4 = substring(@cRegistro, 45, 2),
					ULTPAS_REF = substring(@cRegistro, 47, 10)
			WHERE ICARD = @NumMat
		ELSE IF (@Faixa = 5)
			UPDATE CONTROLE  
				SET CRED_FX5 = substring(@cRegistro, 45, 2),
					ULTPAS_REF = substring(@cRegistro, 47, 10)
			WHERE ICARD = @NumMat
		ELSE IF (@Faixa = 6)
			UPDATE CONTROLE  
				SET CRED_FX6 = substring(@cRegistro, 45, 2),
					ULTPAS_REF = substring(@cRegistro, 47, 10)
				WHERE ICARD = @NumMat
	END

	IF @Tipo in (4,5,6,7) BEGIN	-- atualiza DATAHORA
		SET @IniHA = CAST((substring(@cRegdh,13,2)+'-'+
							 substring(@cRegdh,15,2)+'-'+
							 substring(@cRegdh,17,2)+' '+
							 substring(@cRegdh,19,2)+':'+
							 substring(@cRegdh,21,2)+':'+
							 substring(@cRegdh,23,2)) AS datetime);

		SET @FimHA = CAST((substring(@cRegdh,25,2)+'-'+
							 substring(@cRegdh,27,2)+'-'+
							 substring(@cRegdh,29,2)+' '+
							 substring(@cRegdh,31,2)+':'+
							 substring(@cRegdh,33,2)+':'+
							 substring(@cRegdh,35,2)) AS datetime);

		SET @IniIJ = CAST((substring(@cRegdh,37,2)+'-'+
							 substring(@cRegdh,39,2)+'-'+
							 substring(@cRegdh,41,2)+' '+
							 substring(@cRegdh,43,2)+':'+
							 substring(@cRegdh,45,2)+':'+
							 substring(@cRegdh,47,2)) AS datetime);

		SET @FimIJ = CAST((substring(@cRegdh,49,2)+'-'+
							 substring(@cRegdh,51,2)+'-'+
							 substring(@cRegdh,53,2)+' '+
							 substring(@cRegdh,55,2)+':'+
							 substring(@cRegdh,57,2)+':'+
							 substring(@cRegdh,59,2)) AS datetime);

		SET @FimAntD = CAST((substring(@cRegdh,61,2)+'-'+
							 substring(@cRegdh,63,2)+'-'+
							 substring(@cRegdh,65,2)+' '+
							 substring(@cRegdh,67,2)+':'+
							 substring(@cRegdh,69,2)+':'+
							 substring(@cRegdh,71,2)) AS datetime);

		SET @cDiasSuc = substring(@cRegdh, 73, 2);


		IF NOT EXISTS (SELECT ICARD from DATAHORA WHERE ICARD = @NumMat) 
			INSERT INTO DATAHORA (Icard, Ini_Halm, Fim_Halm, Ini_Intj, Fim_Intj, Fim_AntiD, Dias_Suc) 
		   				  values (@NumMat, @IniHA, @FimHA, @IniIJ, @FimIJ, @FimAntD, @cDiasSuc);
		ELSE
			UPDATE DATAHORA 
				SET Ini_Halm = @IniHA,
					Fim_Halm = @FimHA,
					Ini_Intj = @IniIJ,
					Fim_Intj = @FimIJ,
					Fim_AntiD = @FimAntD,
					Dias_Suc = @cDiasSuc 
		   	 	WHERE Icard = @NumMat;
	END

    SELECT @Retorno
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlatG3G5_tab_acessoSeg'))
	DROP PROCEDURE TELESSVR.sqlatG3G5_tab_acessoSeg;
GO

CREATE PROCEDURE TELESSVR.sqlatG3G5_tab_acessoSeg @cRegistro1 char(85) 
AS

DECLARE @cMatric char(12), @Retorno int
DECLARE @nTamG int , @cSubnv VARCHAR(9) , @cPlanta VARCHAR(9)

BEGIN

	SET @cMatric = substring(@cRegistro1, 1, 12)
	SET @Retorno = 0

	SET @nTamG = 3 
	SELECT	@nTamG  = COLUNAS.LENGTH
		FROM 
			SYSOBJECTS AS TABELAS,
			SYSCOLUMNS AS COLUNAS
		WHERE 
			-- JOINS 
			TABELAS.ID = COLUNAS.ID
			AND TABELAS.NAME = 'CONTROLE'
			AND COLUNAS.NAME = 'GRUPO'

	IF (@nTamG = 5) begin		
		SET @cSubnv =  substring(@cRegistro1, 14, 7)
		SET @cPlanta =  substring(@cRegistro1, 21,5)
	end
	ELSE begin
		SET @cSubnv = substring (substring(@cRegistro1, 14, 7), 1, 5)
		SET @cPlanta = substring (substring(@cRegistro1, 21, 5), 1, 3)
	end


	SET LOCK_TIMEOUT 1000	
	UPDATE CONTROLE
	 set SITUA = substring(@cRegistro1, 13, 1),
	     --SUBNV = substring(@cRegistro1, 14,5),
	     SUBNV = @cSubnv,
	     --PLANTA = substring(@cRegistro1, 21,3),
	     PLANTA = @cPlanta,
	     ULTRS = substring(@cRegistro1, 24+2,25),
	     FX_DTA = substring(@cRegistro1, 49+2,11),
	     QTD_MENS = substring(@cRegistro1, 60+2, 2),
	     CRED_FX1 = substring(@cRegistro1, 62+2, 2),
	     CRED_FX2 = substring(@cRegistro1, 64+2, 2),
	     CRED_FX3 = substring(@cRegistro1, 66+2, 2),
	     CRED_FX4 = substring(@cRegistro1, 68+2, 2),
	     CRED_FX5 = substring(@cRegistro1, 70+2, 2),
	     CRED_FX6 = substring(@cRegistro1, 72+2, 2),
	     ULTPAS_REF = substring(@cRegistro1, 74+2, 10),
	     ULTRSEG = substring(@cRegistro1, 84+2, 2)
	WHERE ICARD = @cMatric

	SET LOCK_TIMEOUT -1		

	return @Retorno
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sp_rastreamento'))
	DROP PROCEDURE TELESSVR.sp_rastreamento;
GO

CREATE PROCEDURE TELESSVR.sp_rastreamento 
AS
begin
	select * from dam03
	declare @sp_motivo char(3)
        declare @sp_grupo char(3)
	declare @sp_matricula integer
	declare @sp_situa char(1)
	declare @sp_Val_situa char(1)
	declare @sp_datahora char(20)
	declare	@sp_Val_datahora char(1)
	declare @mensagem varchar(255) 
	declare @valor integer
	declare @cFaixa AS varchar(56)
	declare @NumLaces int
	
	declare @contador integer
	set @contador = (select count(*) from dam03)
--	CLOSE NEWCURSOR
--	DEALLOCATE NEWCURSOR
	
	select * into #tmp_dam03 from dam03 
	delete from dam03
	DECLARE NEWCURSOR CURSOR FOR ( select ICARD, DIAM, MESM, ANOM, HORAM, SEGUNDO, CODAC, POSIC, BLUEB, CODTT, END_IP,CODFNC, VEICULO  from #tmp_dam03 )
	OPEN NEWCURSOR
	DECLARE @sp_DIAM char(2)
	DECLARE @sp_MESM char(2)
	DECLARE @sp_ANOM char(2)
	DECLARE @sp_HORAM char(4)
	DECLARE @sp_SEGUNDO char(2)
	DECLARE @sp_CODAC char(2) 
	DECLARE @sp_POSIC char(1)
	DECLARE @sp_BLUEB char(2)
	DECLARE @sp_CODTT char(2)
	DECLARE @sp_CODFNC char(2)
	DECLARE @sp_VEICULO varchar(15)
	DECLARE @sp_icard char(12)
	DECLARE @sp_end_ip char(15)
	DECLARE @DATA char(20)
	DECLARE @DATA_FER char(20)
	
	fetch next from NEWCURSOR into @sp_icard,@sp_DIAM , @sp_MESM,@sp_ANOM,@sp_HORAM,@sp_SEGUNDO,@sp_CODAC,@sp_POSIC,@sp_BLUEB,@sp_CODTT,@sp_end_ip, @sp_CODFNC,@sp_VEICULO
	
	while @@fetch_status != -1
	begin
	SET @DATA = @sp_DIAM + '/' + @sp_MESM + '/' + @sp_ANOM + ' ' + SUBSTRING(@sp_HORAM,1,2) + ':'+SUBSTRING(@sp_HORAM,3,2)+':' + @sp_SEGUNDO
	set @DATA_FER = @sp_DIAM + '/' + @sp_MESM + '/' + @sp_ANOM
	set @sp_motivo = '01'

		set @sp_matricula = (select count(*)from controle where icard = @sp_icard)
		if @sp_matricula = 0  
		begin
			set @sp_motivo = '22'
			goto MAIN_LOOP
		end
		
		set @sp_grupo = (select grupo from controle where icard = @sp_icard)
		
		select @NumLaces = 0
		IF NOT EXISTS (select * from TABGRPSETFX WHERE END_IP = @sp_end_ip AND
			                   convert(int,GRUPO) = convert(int,@sp_grupo))
		begin
			set @sp_motivo = '47'
			goto MAIN_LOOP
		end
		else
		begin
			SELECT @NumLaces = convert(int, LACES),
				@cFaixa = FXPERM	
			FROM TABGRPSETFX
			WHERE 
			END_IP = @sp_end_ip AND
			convert(int,GRUPO) = convert(int,@sp_grupo)
		end 	
		
		set @sp_situa = (select situa from controle where icard = @sp_icard)
		if @sp_situa <> 0 
		begin
			set @sp_motivo = '24'
			goto MAIN_LOOP
		end
		
		declare @data_tab char(14)
		declare @dia_tab char(2)
		declare @mes_tab char(2)
		declare @ano_tab char(2)
		declare @hor_tab char(2)
		declare @min_tab char(2)
		set @sp_datahora = (select datahora from controle where icard = @sp_icard)		
		
		set @dia_tab = (substring(@sp_datahora,0,3))
		set @mes_tab = (substring(@sp_datahora,3,2))
		set @ano_tab = (substring(@sp_datahora,5,2))
		set @hor_tab = (substring(@sp_datahora,7,2))
		set @min_tab = (substring(@sp_datahora,9,2))
	
		set @data_tab = @dia_tab+'/'+@mes_tab+'/'+@ano_tab+' '+@hor_tab+':'+@min_tab
		
		declare @dia_Atu char(2)
		declare @mes_Atu char(2)
		declare @ano_Atu char(6)
		declare @hor_Atu char(2)
		declare @min_Atu char(2)
		declare @data_Atu char(20)
		
		set @dia_Atu = (Select DATEPART(day,getdate()))
		set @mes_Atu = (Select DATEPART(month,getdate()))
		set @ano_Atu = (Select DATEPART(year,getdate()))
		set @ano_Atu = substring(@ano_Atu,3,2)
		set @hor_Atu = (Select DATEPART(hour,getdate()))
		set @min_Atu = (Select DATEPART(minute,getdate()))
		
		if len(@dia_Atu) = 1 
		begin
			set @dia_Atu = '0' + @dia_Atu
		end

		if len(@mes_Atu) = 1 
		begin
			set @mes_Atu = '0' + @mes_Atu
		end

		set @data_Atu = @dia_Atu+'/'+@mes_Atu+'/'+@ano_Atu+' '+@hor_Atu+':'+@min_Atu
		
		if @data_Atu > @data_tab
		begin
			set @sp_motivo = '15'
			goto MAIN_LOOP
		end
			
		declare @Afastado int
		set @Afastado = (select count(*) from controle where icard = @sp_icard and @DATA between datini and datfim)
		if @Afastado > 0 
		begin
			set @sp_motivo = '17'
			goto MAIN_LOOP
		end
		
		
		DECLARE @DIA INT
		DECLARE @sp_grupo_SAB char(3)
		DECLARE @sp_grupo_DOM char(3)
		DECLARE @sp_grupo_FER char(3)
		declare @SP_quantidade_fer integer

		SELECT @DIA = (DATEPART(DW,@DATA ))
		
		set @SP_quantidade_fer = (select count(*) from feriado  where data_fer = convert(datetime,@DATA_FER))
		if  @SP_quantidade_fer > 0
		begin
			set @sp_grupo_FER = (select CONVERT(INT,grupo_fer) from controle where icard = @sp_icard)
			if @sp_grupo_FER = 0
			begin
				set @sp_motivo = '46'
				goto MAIN_LOOP
			end
		end
		else
		begin
			if @DIA IN (1,7)
			begin
				if @DIA = 1 
				begin
					set @sp_grupo_SAB = (select CONVERT(INT,grupo_sab) from controle where icard = @sp_icard)
					if @sp_grupo_SAB = 0
					begin
						set @sp_motivo = '46'
						goto MAIN_LOOP
					end
				end
				else
				if @DIA = 7
				begin
					set @sp_grupo_DOM = (select CONVERT(INT,grupo_dom) from controle where icard = @sp_icard)
					if @sp_grupo_DOM = 0
					begin
						set @sp_motivo = '46'
						goto MAIN_LOOP
					end
				end 
			end
		end

	MAIN_LOOP:		
		INSERT INTO DAM00 (ICARD, DIAM, MESM, ANOM, HORAM, SEGUNDO,CODAC, POSIC, BLUEB, CODTT, END_IP, CODFNC, ONOFF, VEICULO)	
			VALUES(@sp_icard,@sp_DIAM , @sp_MESM,@sp_ANOM,@sp_HORAM,@sp_SEGUNDO,@sp_motivo,@sp_POSIC,@sp_BLUEB,@sp_CODTT,@sp_end_ip, @sp_CODFNC,0,@sp_VEICULO)

	fetch next from NEWCURSOR into @sp_icard,@sp_DIAM , @sp_MESM,@sp_ANOM,@sp_HORAM,@sp_SEGUNDO,@sp_CODAC,@sp_POSIC,@sp_BLUEB,@sp_CODTT,@sp_end_ip, @sp_CODFNC,@sp_VEICULO
	end
	CLOSE NEWCURSOR
	DEALLOCATE NEWCURSOR
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlbloco_col_dam00_new2'))
	DROP PROCEDURE TELESSVR.sqlbloco_col_dam00_new2;
GO

CREATE PROCEDURE TELESSVR.sqlbloco_col_dam00_new2 @Registro CHAR(110), @cTipo char(1)
AS
DECLARE @ret int,
@C1 char(12), @C2 char(2), @C3 char(2), 
@C4 char(2), @C5 char(4), @C6 char(2), 
@C7 char(2), @C8 char(1), @C9 char(15), 
@C10 char(2), @C11 char(1), @C12 char(15), 
@C13 char(2),
@C14 char(10), @C15 char(10) ,
@C16 CHAR (6), @C17 char(7), @C18 char(7), @C19 char(2), @C20 CHAR(1)

set ansi_warnings on
set ansi_padding on
set ansi_nulls on
set concat_null_yields_null on

	SET @ret = 0
	SET @C1 = SUBSTRING(@Registro, 1, 12)  -- ICARD
	SET @C2 = SUBSTRING(@Registro, 13, 2)	--diam
	SET @C3 = SUBSTRING(@Registro, 15, 2)	--mesm
	SET @C4 = SUBSTRING(@Registro, 17, 2)	--anom
	SET @C5 = SUBSTRING(@Registro, 19, 4)	--horam
	SET @C6 = SUBSTRING(@Registro, 23, 2)	--segundo
	SET @C7 = SUBSTRING(@Registro, 25, 2)	--codac
	SET @C8 = SUBSTRING(@Registro, 27, 1)	--posic
	SET @C9 = SUBSTRING(@Registro, 28, 15)	--end_ip
	SET @C10 = SUBSTRING(@Registro, 43, 2) 	--codfnc
	SET @C11 = SUBSTRING(@Registro, 45, 1) 	--onoff
	SET @C12 = SUBSTRING(@Registro, 46, 15)	--veiculo
	SET @C13 = SUBSTRING(@Registro, 61, 2)	--tipodoc
	SET @C14 = SUBSTRING(@Registro, 63, 10)	--ns_icard
	SET @C15 = SUBSTRING(@Registro, 73, 10)	--ns_veic
	SET @C16 = SUBSTRING(@Registro, 83, 6)	--peso
	SET @C17 = SUBSTRING(@Registro, 89, 7)	--valkilo
	SET @C18 = SUBSTRING(@Registro, 96, 7)	--valor
	SET @C19 = SUBSTRING(@Registro, 103, 2)	--qtde
	SET @C20 = SUBSTRING(@Registro, 105, 1)	--BIO1N 


	INSERT INTO DAM00 (ICARD, DIAM, MESM, ANOM, HORAM, SEGUNDO,CODAC, POSIC, END_IP, CODFNC, 
						ONOFF, VEICULO, TIPODOC, ICARD_NS, VEICULO_NS, BIO1N)
			VALUES (@C1, @C2, @C3, @C4, @C5, @C6, @C7, @C8, @C9, @C10, 
					@C11, @C12, @C13, @C14, @C15, @C20)
   
	SELECT @ret
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlBusca_Omok_biomet'))
	DROP PROCEDURE TELESSVR.sqlBusca_Omok_biomet;
GO

CREATE PROCEDURE TELESSVR.sqlBusca_Omok_biomet  @cMatric char(12), @cTipBio char(1), @cEndIp char(15), @cTipoCons char(1),
@cTempl_tit1tot CHAR(160) OUTPUT, @cTempl_tit2tot CHAR(160) OUTPUT, 
@cTempl_tit3tot CHAR(160) OUTPUT, @cTempl_tit4tot CHAR(160) OUTPUT, 
@cTempl_Alt1tot CHAR(160) OUTPUT, @cTempl_Alt2tot CHAR(160) OUTPUT, 
@cTempl_Alt3tot CHAR(160) OUTPUT, @cTempl_Alt4tot CHAR(160) OUTPUT,
@cNivel CHAR(1) OUTPUT, 
@cTempl_tit5tot CHAR(160) OUTPUT, @cTempl_Alt5tot CHAR(160) OUTPUT,
@cTempl_tit6tot CHAR(26) OUTPUT, @cTempl_Alt6tot CHAR(26) OUTPUT

AS
DECLARE @cVDigit char(1)
DECLARE @RetFun int, @Pad int, @Alt int, @nAchou int

BEGIN
	select @RetFun = 3
	select @cTempl_tit1tot = NULL
	select @cTempl_tit2tot = NULL
	select @cTempl_tit3tot = NULL
	select @cTempl_tit4tot = NULL
	select @cTempl_tit5tot = NULL
	select @cTempl_tit6tot = NULL
	select @cTempl_Alt1tot = NULL
	select @cTempl_Alt2tot = NULL
	select @cTempl_Alt3tot = NULL
	select @cTempl_Alt4tot = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL

	set @cNivel = NULL
	set @cVDigit = '2'
	set @nAchou = 0;
	set @Pad = 0;
	set @Alt = 0;

	-- PARA VALIDAÇÃO ONLINE 
	IF (@cTipoCons = '1') 
	begin
		IF EXISTS (SELECT Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric) 
		begin
			SELECT @cVDigit = Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric

			-- procura por Templates da matricula
			IF EXISTS (SELECT * FROM CONTDIG_OMOK  WHERE ICARD = @cMatric)
			begin
				SELECT @cTempl_tit1tot = TEMPL_TIT1,
					   @cTempl_tit2tot = TEMPL_TIT2,
					   @cTempl_tit3tot = TEMPL_TIT3,
					   @cTempl_tit4tot = TEMPL_TIT4,
					   @cTempl_Alt1tot = TEMPL_ALT1,
					   @cTempl_Alt2tot = TEMPL_ALT2,
					   @cTempl_Alt3tot = TEMPL_ALT3,
					   @cTempl_Alt4tot = TEMPL_ALT4,
					   @cNivel = NIVEL,
					   @cTempl_tit5tot = TEMPL_TIT5,
					   @cTempl_Alt5tot = TEMPL_ALT5,
					   @cTempl_tit6tot = TEMPL_TIT6,
					   @cTempl_Alt6tot = TEMPL_ALT6
				FROM CONTDIG_OMOK
				WHERE ICARD = @cMatric
					
				set @nAchou = 1;
			end
			ELSE begin
				IF (CONVERT(INT,@cVDigit) = 2) 
					set @RetFun = -2;
				ELSE begin
					set @Pad = 0;
					set @Alt = 0;
				end
			end
		end
		ELSE
			set @RetFun = -2;
	end

	-- PARA COMANDO CARGA DIGITAIS 
	ELSE begin
		-- procura por Templates da matricula
		IF EXISTS (SELECT * FROM CONTDIG_OMOK  WHERE ICARD = @cMatric)
		begin
			SELECT @cTempl_tit1tot = TEMPL_TIT1,
				   @cTempl_tit2tot = TEMPL_TIT2,
				   @cTempl_tit3tot = TEMPL_TIT3,
				   @cTempl_tit4tot = TEMPL_TIT4,
				   @cTempl_Alt1tot = TEMPL_ALT1,
				   @cTempl_Alt2tot = TEMPL_ALT2,
				   @cTempl_Alt3tot = TEMPL_ALT3,
				   @cTempl_Alt4tot = TEMPL_ALT4,
				   @cNivel = NIVEL,
				   @cTempl_tit5tot = TEMPL_TIT5,
				   @cTempl_Alt5tot = TEMPL_ALT5,
				   @cTempl_tit6tot = TEMPL_TIT6,
				   @cTempl_Alt6tot = TEMPL_ALT6
			FROM CONTDIG_OMOK
				WHERE ICARD = @cMatric
							
			set @nAchou = 1;
		end

		ELSE begin
			set @Pad = 0;
			set @Alt = 0;
		end
	end	

	-- verifica o conteudo das digitais
	IF (@nAchou = 1) begin
		select @Pad = 1    -- assume que tem template padrao
		select @Alt = 1    -- assume que tem template alternativo

	    if ((@cTempl_tit1tot is Null) or (@cTempl_tit2tot is Null) or 
			(@cTempl_tit3tot is Null) or (@cTempl_tit4tot is Null) or
			(@cTempl_tit5tot is Null) or (@cTempl_tit6tot is Null) or 
			(datalength(@cTempl_tit1tot) < 160) or (datalength(@cTempl_tit2tot) < 160) or
			(datalength(@cTempl_tit3tot) < 160) or (datalength(@cTempl_tit4tot) < 160) or
			(datalength(@cTempl_tit5tot) < 160) or (datalength(@cTempl_tit6tot) < 26)) 
	    begin
			SELECT @Pad = 0
	    end 
	    if ((@cTempl_Alt1tot is Null) or (@cTempl_Alt2tot is Null) or
			(@cTempl_Alt3tot is Null) or (@cTempl_Alt4tot is Null) or
			(@cTempl_Alt5tot is Null) or (@cTempl_Alt6tot is Null) or
			(datalength(@cTempl_Alt1tot) < 160) or (datalength(@cTempl_Alt2tot) < 160) or
			(datalength(@cTempl_Alt3tot) < 160) or (datalength(@cTempl_Alt4tot) < 160) or
			(datalength(@cTempl_Alt5tot) < 160) or (datalength(@cTempl_Alt6tot) < 26)) 
	    begin 
			SELECT @Alt = 0
	    end

	end
	
	IF (@RetFun != -2) begin
		if (@Pad = 1) 
			if (@Alt = 1) 
				SET @RetFun = 0   -- tem padrao e tem alternativo
			else 
				SET @RetFun = 1   -- tem padrao e nao tem alternativo
		
		if (@Pad = 0) 
			if (@Alt = 1) 
				SET @RetFun = 2   -- nao tem padrao e tem alternativo
			else 
				SET @RetFun = 3   -- nao tem padrao e nao tem alternativo	
	end

	-- VERIFICA SE NAO ACHOU NENHUMA BIOMETRIA E É COMANDO DE ENVIO DE DIGITAIS, DEVERA GUARDAR INFORMACAO EM DIGLOAD001	
	IF ((@RetFun = 3) and (@cTipoCons != '1' )) 
		INSERT into DIGLOAD001 (END_IP, ICARD, BIO_TIPO) 		-- insere em tabela DIGLOAD001
						VALUES (@cEndIp, @cMatric, @cTipBio);
		
	return (@RetFun)

END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlcon_coacao_omokx'))
	DROP PROCEDURE TELESSVR.sqlcon_coacao_omokx;
GO

CREATE PROCEDURE TELESSVR.sqlcon_coacao_omokx @cMatric char(12),
@cTempl_Coa1tot CHAR(160) OUTPUT, @cTempl_Coa2tot CHAR(160) OUTPUT, 
@cTempl_Coa3tot CHAR(160) OUTPUT, @cTempl_Coa4tot CHAR(160) OUTPUT, 
@cTempl_Coa5tot CHAR(160) OUTPUT, @cTempl_Coa6tot CHAR(160) OUTPUT 

AS
DECLARE @RetFun int, @Coa int
BEGIN
	set @RetFun = 1
	set @Coa = 1
	select @cTempl_Coa1tot = NULL
	select @cTempl_Coa2tot = NULL
	select @cTempl_Coa3tot = NULL
	select @cTempl_Coa4tot = NULL
	select @cTempl_Coa5tot = NULL
	select @cTempl_Coa6tot = NULL
	
	-- procura por Templates da matricula
	IF EXISTS (SELECT * FROM CONTDIG_OMOK WITH (Index = CONTDIG_OMOK_IND1) WHERE ICARD = @cMatric)
	begin
	    SELECT @cTempl_Coa1tot = TEMPL_COA1,
		   @cTempl_Coa2tot = TEMPL_COA2,
		   @cTempl_Coa3tot = TEMPL_COA3,
		   @cTempl_Coa4tot = TEMPL_COA4,
		   @cTempl_Coa5tot = TEMPL_COA5,
		   @cTempl_Coa6tot = TEMPL_COA6
		FROM CONTDIG_OMOK
		WHERE ICARD = @cMatric

	    if ((@cTempl_Coa1tot is Null) or (@cTempl_Coa2tot is Null) or 
			(@cTempl_Coa3tot is Null) or (@cTempl_Coa4tot is Null) or
			(@cTempl_Coa5tot is Null) or (@cTempl_Coa6tot is Null) or 
			(datalength(@cTempl_Coa1tot) < 160) or (datalength(@cTempl_Coa2tot) < 160) or
			(datalength(@cTempl_Coa3tot) < 160) or (datalength(@cTempl_Coa4tot) < 160) or
			(datalength(@cTempl_Coa5tot) < 160) or (datalength(@cTempl_Coa6tot) < 26)) 
	    begin
			SET @Coa = 0
	    end 
	end
	IF (@Coa = 0) 
	begin
		Set @RetFun = 0
	end
	return (@RetFun)
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlbloco_pend_smart_tcp2'))
	DROP PROCEDURE TELESSVR.sqlbloco_pend_smart_tcp2;
GO

CREATE PROCEDURE TELESSVR.sqlbloco_pend_smart_tcp2 @Registro VARCHAR(120), @Tipo Int, @EndIp VARCHAR(15)  AS
DECLARE
  @Ret INT, @cIdentif char(14)



  set @Ret = 0  
  SET @cIdentif = SUBSTRING(@Registro, 11, 14)
  execute dbo.to_identif @fn_identif = @cIdentif output	


  IF (@Tipo = 0) 
	INSERT INTO PENDSMART (END_IP, NUMSERIAL, IDENTIF, NUMCPO, INFORM) 
      VALUES (@EndIp,
    	      SUBSTRING(@Registro, 1, 10),
    	      @cIdentif,
    	      SUBSTRING(@Registro, 25, 2),
    	      SUBSTRING(@Registro, 27, 56))
  ELSE
	INSERT INTO PENDSMART (END_IP, NUMSERIAL, IDENTIF) 
	  VALUES (@EndIp,
    	      SUBSTRING(@Registro, 1, 10),
    	      @cIdentif);
  
  SELECT @Ret
  GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqller_pendon003'))
	DROP PROCEDURE TELESSVR.sqller_pendon003;
GO

CREATE PROCEDURE TELESSVR.sqller_pendon003 @cEndIp CHAR(15) AS

DECLARE @cAux char(10), @cHorExp AS CHAR(2)


DECLARE @xCont smallint, @xNSerial CHAR(10), @xIdent CHAR(14), @cStOn002 CHAR(1), @nHoras int, @cHoras CHAR(3), @ERR INT, @ROWC smallint



	SET @xCont = 0
	SET @cHorExp = ''
	
	SET NOCOUNT ON
	SET LOCK_TIMEOUT 3000
	SELECT @cStOn002 = STATUS, @nHoras = QHOR_EXP 
		from PEND_ON002ON NOLOCK 
		where END_IP = @cEndIp;
	IF @@ROWCOUNT = 0 
		SET @xCont = 0

	ELSE
		IF (@cStOn002 = '1') begin
			SET @cHoras = convert(char(3), @nHoras)
			SET @cHorExp = substring(@cHoras,1,2)
			SELECT @cAux = NUMSERIAL 
	            FROM     PEND_ON003 NOLOCK 
	            WHERE    END_IP = @cEndIp 		
	        set @ROWC = @@ROWCOUNT
	        IF @ROWC = 0 begin
				-- indica em PEND_ON002 que a lista foi carregada 
				--begin transaction t1
				UPDATE	PEND_ON002ON  set STATUS = '3' where END_IP = @cEndIp
				set @ERR = @@ERROR
				print ' rowcount = 0,erro de pendon002 = ' + ltrim(str(@ERR))
				
			end
			else begin
				--begin transaction t1
				SET @xCont = @ROWC
				UPDATE PEND_ON002ON set STATUS = '2',
									    DATA_INI = GETDATE() 
				where END_IP = @cEndIp;
				set @ERR = @@ERROR
				print ' rowcount <> 0,erro de pendon002 = ' + ltrim(str(@ERR))

			end
				
		END
	
	SET LOCK_TIMEOUT -1
	SELECT @xCont, @cHorExp
	GO
	
	
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlver_tipobio'))
	DROP PROCEDURE TELESSVR.sqlver_tipobio;
GO

CREATE PROCEDURE TELESSVR.sqlver_tipobio @cEndIp CHAR(15) AS

DECLARE @ctipobio AS CHAR(1) 
		

DECLARE @ret int

	SET @ret = 0
	SET @ctipobio = '0'


	SELECT @ctipobio = BIO_TIPO	           
		FROM DAT07 (NOLOCK)
		  WHERE END_IP = @cEndIp and blueb = '00' and codin = '00'

	IF (@@ROWCOUNT <> 0)
	BEGIN
		SET @ret = 1
		if (@ctipobio is Null) 
			SET @ctipobio = '0'
	END

	SELECT @ret, @ctipobio
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO
	
IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlatu_veri_CNX'))
	DROP PROCEDURE TELESSVR.sqlatu_veri_CNX;
GO

CREATE PROCEDURE TELESSVR.sqlatu_veri_CNX  @matric char(12), @TipoChave char(1), @templ1 char(160), @templ2 char(160), 
@templ3 char(160), @templ4 char(160), @nTipo char(1), @cNumDedo char(2), @cNivel char(1), @templ5 char(56)
AS

DECLARE @cAuxMat char(15), @nRetorno int, @cAux char(1)
BEGIN

	select @nRetorno = 1
    SET @cAuxMat = @matric
    
	IF (@TipoChave = '1')	-- pesquisa por Numero Serial, para coletar valor de Icard
		begin
			IF EXISTS (SELECT icard FROM CONTROLE  WHERE NUMSERIAL = substring(@matric, 3, 10))
			begin
				SELECT @cAuxMat = ICARD 
					FROM CONTROLE
					WHERE NUMSERIAL = substring(@matric, 3, 10)
			END

		end
	ELSE IF (@TipoChave = '2')	-- pesquisa por CPF, para coletar valor de Icard
		begin
			IF EXISTS (SELECT icard FROM ContCPF  WHERE CPF = substring(@matric, 2, 11))
			begin
				SELECT @cAuxMat = ICARD 
					FROM ContCPF
					WHERE CPF = substring(@matric, 2, 11)
			END
		end
	

    IF (@nTipo = '0')
	BEGIN
	    UPDATE CONTDIG_VERI SET TEMPL_TIT1 = @templ1,
			       TEMPL_TIT2 = @templ2,
			       TEMPL_TIT3 = @templ3,
			       TEMPL_TIT4 = @templ4,
              		       NIVEL = @cNivel,
			       NUM_DEDO_PAD = @cNumDedo,
			       TEMPL_TIT5 = @templ5
	    WHERE ICARD = @cAuxMat
	END
	ELSE
	BEGIN
	    UPDATE CONTDIG_VERI SET TEMPL_ALT1 = @templ1,
			       TEMPL_ALT2 = @templ2,
			       TEMPL_ALT3 = @templ3,
			       TEMPL_ALT4 = @templ4,
              		       NIVEL = @cNivel,
			       NUM_DEDO_ALT = @cNumDedo,
			       TEMPL_ALT5 = @templ5
	    WHERE ICARD = @cAuxMat
	END

	if (@@ROWCOUNT = 0)
	BEGIN
	    IF (@nTipo= '0')
	    BEGIN
		INSERT INTO CONTDIG_VERI (ICARD, TEMPL_TIT1, TEMPL_TIT2, TEMPL_TIT3, TEMPL_TIT4,
			      NIVEL, NUM_DEDO_PAD,TEMPL_TIT5) 
		VALUES (@cAuxMat, @templ1, @templ2, @templ3, @templ4, @cNivel, @cNumDedo,@templ5)
	    END
	    ELSE
	    BEGIN
		INSERT INTO CONTDIG_VERI (ICARD, TEMPL_ALT1, TEMPL_ALT2, TEMPL_ALT3, TEMPL_ALT4,
			      NIVEL, NUM_DEDO_ALT,TEMPL_ALT5) 
		VALUES (@cAuxMat, @templ1, @templ2, @templ3, @templ4, @cNivel, @cNumDedo,@templ5)
	    END

	    SET @nRetorno = 0
	END
	ELSE
	    SET @nRetorno = 1

    return @nRetorno
END
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlBusca_Veri_biomet'))
	DROP PROCEDURE TELESSVR.sqlBusca_Veri_biomet;
GO

CREATE PROCEDURE TELESSVR.sqlBusca_Veri_biomet  @cMatric char(12), @cTipBio char(1), @cEndIp char(15), @cTipoCons char(1),
@cTempl_tit1tot CHAR(160) OUTPUT, @cTempl_tit2tot CHAR(160) OUTPUT, 
@cTempl_tit3tot CHAR(160) OUTPUT, @cTempl_tit4tot CHAR(160) OUTPUT, 
@cTempl_Alt1tot CHAR(160) OUTPUT, @cTempl_Alt2tot CHAR(160) OUTPUT, 
@cTempl_Alt3tot CHAR(160) OUTPUT, @cTempl_Alt4tot CHAR(160) OUTPUT,
@cNivel CHAR(1) OUTPUT,
@cTempl_tit5tot CHAR(56) OUTPUT, @cTempl_Alt5tot CHAR(56) OUTPUT
AS

DECLARE @cVDigit CHAR(1) 
DECLARE @RetFun int, @Pad int, @Alt int, @nAchou int


BEGIN
	--select @RetFun = -1
	select @RetFun = 3
	select @cTempl_tit1tot = NULL
	select @cTempl_tit2tot = NULL
	select @cTempl_tit3tot = NULL
	select @cTempl_tit4tot = NULL
	select @cTempl_tit5tot = NULL
	select @cTempl_Alt1tot = NULL
	select @cTempl_Alt2tot = NULL
	select @cTempl_Alt3tot = NULL
	select @cTempl_Alt4tot = NULL
	select @cTempl_Alt5tot = NULL
	
	set @cNivel = NULL
	set @cVDigit = '2'
	set @nAchou = 0;
	set @Pad = 0;
	set @Alt = 0;

	-- PARA VALIDAÇÃO ONLINE 
	IF (@cTipoCons = '1') 
	begin
		IF EXISTS (SELECT Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric) 
		begin
			SELECT @cVDigit = Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric

			-- procura por Templates da matricula
			IF EXISTS (SELECT * FROM CONTDIG_VERI  WHERE ICARD = @cMatric)
			begin
				SELECT @cTempl_tit1tot = TEMPL_TIT1,
					   @cTempl_tit2tot = TEMPL_TIT2,
					   @cTempl_tit3tot = TEMPL_TIT3,
					   @cTempl_tit4tot = TEMPL_TIT4,
					   @cTempl_Alt1tot = TEMPL_ALT1,
					   @cTempl_Alt2tot = TEMPL_ALT2,
					   @cTempl_Alt3tot = TEMPL_ALT3,
					   @cTempl_Alt4tot = TEMPL_ALT4,
					   @cTempl_tit5tot = TEMPL_TIT5,
					   @cTempl_Alt5tot = TEMPL_ALT5,
					   @cNivel = NIVEL
				FROM CONTDIG_VERI
				WHERE ICARD = @cMatric
				
				set @nAchou = 1;
			end
			ELSE begin
				IF (CONVERT(INT,@cVDigit) = 2) 
					set @RetFun = -2;
				ELSE begin
					set @Pad = 0;
					set @Alt = 0;
				end
			end
		end
		ELSE
			set @RetFun = -2;
	end

	-- PARA COMANDO CARGA DIGITAIS 
	ELSE begin
		-- procura por Templates da matricula
		IF EXISTS (SELECT * FROM CONTDIG_VERI  WHERE ICARD = @cMatric)
		begin
			SELECT @cTempl_tit1tot = TEMPL_TIT1,
				   @cTempl_tit2tot = TEMPL_TIT2,
				   @cTempl_tit3tot = TEMPL_TIT3,
				   @cTempl_tit4tot = TEMPL_TIT4,
				   @cTempl_Alt1tot = TEMPL_ALT1,
				   @cTempl_Alt2tot = TEMPL_ALT2,
				   @cTempl_Alt3tot = TEMPL_ALT3,
				   @cTempl_Alt4tot = TEMPL_ALT4,
				   @cTempl_tit5tot = TEMPL_TIT5,
				   @cTempl_Alt5tot = TEMPL_ALT5,
				   @cNivel = NIVEL
			FROM CONTDIG_VERI
			WHERE ICARD = @cMatric
				
			set @nAchou = 1;
		end
		ELSE begin
			set @Pad = 0;
			set @Alt = 0;
		end
	end

	-- verifica o conteudo das digitais
	IF (@nAchou = 1) begin
		select @Pad = 1    -- assume que tem template padrao
		select @Alt = 1    -- assume que tem template alternativo

	    if ((@cTempl_tit1tot is Null) or (@cTempl_tit2tot is Null) or 
			(@cTempl_tit3tot is Null) or (@cTempl_tit4tot is Null) or
			(@cTempl_tit5tot is Null) or 
			(datalength(@cTempl_tit1tot) < 160) or 		(datalength(@cTempl_tit2tot) < 160) or
			(datalength(@cTempl_tit3tot) < 160) or 		(datalength(@cTempl_tit4tot) < 160) or
			(datalength(@cTempl_tit5tot) < 56)) 
	    begin
			SELECT @Pad = 0
	    end 
	    
	    if ((@cTempl_Alt1tot is Null) or (@cTempl_Alt2tot is Null) or
			(@cTempl_Alt3tot is Null) or (@cTempl_Alt4tot is Null) or
			(@cTempl_Alt5tot is Null) or
			(datalength(@cTempl_Alt1tot) < 160) or 		(datalength(@cTempl_Alt2tot) < 160) or
			(datalength(@cTempl_Alt3tot) < 160) or 		(datalength(@cTempl_Alt4tot) < 160) or
			(datalength(@cTempl_Alt5tot) < 56)) 
	    begin 
			SELECT @Alt = 0
	    end
	end
	
	IF (@RetFun != -2) begin
		if (@Pad = 1) 
			if (@Alt = 1) 
				SET @RetFun = 0   -- tem padrao e tem alternativo
			else 
				SET @RetFun = 1   -- tem padrao e nao tem alternativo
		
		if (@Pad = 0) 
			if (@Alt = 1) 
				SET @RetFun = 2   -- nao tem padrao e tem alternativo
			else 
				SET @RetFun = 3   -- nao tem padrao e nao tem alternativo	
	end

	-- VERIFICA SE NAO ACHOU NENHUMA BIOMETRIA E É COMANDO DE ENVIO DE DIGITAIS, DEVERA GUARDAR INFORMACAO EM DIGLOAD001	
	IF ((@RetFun = 3) and (@cTipoCons != '1' )) 
		INSERT into DIGLOAD001 (END_IP, ICARD, BIO_TIPO) 		-- insere em tabela DIGLOAD001
						VALUES (@cEndIp, @cMatric, @cTipBio);
		
	return (@RetFun)
	
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlcon_coacao_sagemx'))
	DROP PROCEDURE TELESSVR.sqlcon_coacao_sagemx;
GO

CREATE PROCEDURE TELESSVR.sqlcon_coacao_sagemx @cMatric char(12),
@cTempl_Coa1tot CHAR(160) OUTPUT, @cTempl_Coa2tot CHAR(160) OUTPUT, 
@cTempl_Coa3tot CHAR(160) OUTPUT, @cTempl_Coa4tot CHAR(160) OUTPUT, 
@cTempl_Coa5tot CHAR(160) OUTPUT, @cTempl_Coa6tot CHAR(160) OUTPUT 

AS
DECLARE @RetFun int, @Coa int, @cTempl_Coa4aux AS CHAR(32)
BEGIN
	set @RetFun = 1
	set @Coa = 1
	select @cTempl_Coa1tot = NULL
	select @cTempl_Coa2tot = NULL
	select @cTempl_Coa3tot = NULL
	select @cTempl_Coa4tot = NULL
	select @cTempl_Coa4aux = NULL
	select @cTempl_Coa5tot = NULL
	select @cTempl_Coa6tot = NULL
	
	-- procura por Templates da matricula
	IF EXISTS (SELECT * FROM CONTDIG_SAGEM WITH (Index = CONTDIG_SAGEM_IND1) WHERE ICARD = @cMatric)
	begin
	    SELECT @cTempl_Coa1tot = TEMPL_COA1,
		   @cTempl_Coa2tot = TEMPL_COA2,
		   @cTempl_Coa3tot = TEMPL_COA3,
		   @cTempl_Coa4aux = TEMPL_COA4
		FROM CONTDIG_SAGEM
		WHERE ICARD = @cMatric

	    IF ((@cTempl_Coa1tot is Null) or (@cTempl_Coa2tot is Null) or 
			(@cTempl_Coa3tot is Null) or (@cTempl_Coa4tot is Null) or
			(datalength(@cTempl_Coa1tot) < 160) or (datalength(@cTempl_Coa2tot) < 160) or
			(datalength(@cTempl_Coa3tot) < 160) or (datalength(@cTempl_Coa4aux) < 32))
			SET @Coa = 0
	    ELSE 
	    begin
			SET @cTempl_Coa4tot = @cTempl_Coa4aux + REPLICATE('0',160-LEN(@cTempl_Coa4aux) )
			SET @cTempl_Coa5tot = REPLICATE('0', 160)
			SET @cTempl_Coa6tot = REPLICATE('0', 26)
	    end
	END

	IF (@Coa = 0) 
	begin
		Set @RetFun = 0
	end
	return (@RetFun)
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlBusca_Sagem_biomet'))
	DROP PROCEDURE TELESSVR.sqlBusca_Sagem_biomet;
GO

CREATE PROCEDURE TELESSVR.sqlBusca_Sagem_biomet  @cMatric char(12), @cTipBio char(1), @cEndIp char(15), @cTipoCons char(1),
@cTempl_tit1tot CHAR(160) OUTPUT, @cTempl_tit2tot CHAR(160) OUTPUT, 
@cTempl_tit3tot CHAR(160) OUTPUT, @cTempl_tit4tot CHAR(160) OUTPUT, 
@cTempl_Alt1tot CHAR(160) OUTPUT, @cTempl_Alt2tot CHAR(160) OUTPUT, 
@cTempl_Alt3tot CHAR(160) OUTPUT, @cTempl_Alt4tot CHAR(160) OUTPUT,
@cNivel CHAR(1) OUTPUT,
@cTempl_tit5tot CHAR(160) OUTPUT, @cTempl_Alt5tot CHAR(160) OUTPUT,
@cTempl_tit6tot CHAR(26)  OUTPUT, @cTempl_Alt6tot CHAR(26)  OUTPUT

AS
DECLARE @cTempl_tit4aux CHAR(32), @cTempl_Alt4aux CHAR(32), @cVDigit CHAR(1) 
DECLARE @RetFun int, @Pad int, @Alt int, @nAchou int

BEGIN

	select @RetFun = 3
	select @cTempl_tit1tot = NULL
	select @cTempl_tit2tot = NULL
	select @cTempl_tit3tot = NULL
	select @cTempl_tit4tot = NULL
	select @cTempl_tit4aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	select @cTempl_Alt1tot = NULL
	select @cTempl_Alt2tot = NULL
	select @cTempl_Alt3tot = NULL
	select @cTempl_Alt4tot = NULL
	select @cTempl_Alt4aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL

	set @cNivel = NULL
	set @cVDigit = '2'
	set @nAchou = 0;
	set @Pad = 0;
	set @Alt = 0;
	

	-- PARA VALIDAÇÃO ONLINE 
	IF (@cTipoCons = '1') 
	begin
		IF EXISTS (SELECT Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric) 
		begin
			SELECT @cVDigit = Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric

			-- procura por Templates da matricula
			IF EXISTS (SELECT * FROM CONTDIG_SAGEM  WHERE ICARD = @cMatric)
			begin
				SELECT @cTempl_tit1tot = TEMPL_TIT1,
				   @cTempl_tit2tot = TEMPL_TIT2,
				   @cTempl_tit3tot = TEMPL_TIT3,
				   @cTempl_tit4aux = TEMPL_TIT4,
				   @cTempl_Alt1tot = TEMPL_ALT1,
				   @cTempl_Alt2tot = TEMPL_ALT2,
				   @cTempl_Alt3tot = TEMPL_ALT3,
				   @cTempl_Alt4aux = TEMPL_ALT4,
				   @cNivel = NIVEL
				FROM CONTDIG_SAGEM
				WHERE ICARD = @cMatric
				
				set @nAchou = 1;
			end
			ELSE begin
				IF (CONVERT(INT,@cVDigit) = 2) 
					set @RetFun = -2;
				ELSE begin
					set @Pad = 0;
					set @Alt = 0;
				end
			end
		end
		ELSE
			set @RetFun = -2;
	end
	
	-- PARA COMANDO CARGA DIGITAIS 
	ELSE begin
		-- procura por Templates da matricula
		IF EXISTS (SELECT * FROM CONTDIG_SAGEM  WHERE ICARD = @cMatric)
		begin
			SELECT @cTempl_tit1tot = TEMPL_TIT1,
			   @cTempl_tit2tot = TEMPL_TIT2,
			   @cTempl_tit3tot = TEMPL_TIT3,
			   @cTempl_tit4aux = TEMPL_TIT4,
			   @cTempl_Alt1tot = TEMPL_ALT1,
			   @cTempl_Alt2tot = TEMPL_ALT2,
			   @cTempl_Alt3tot = TEMPL_ALT3,
			   @cTempl_Alt4aux = TEMPL_ALT4
			FROM CONTDIG_SAGEM
			WHERE ICARD = @cMatric
				
			set @nAchou = 1;
		end
		ELSE begin
			set @Pad = 0;
			set @Alt = 0;
		end
	end
	
	-- verifica o conteudo das digitais
	IF (@nAchou = 1) begin
		select @Pad = 1    -- assume que tem template padrao
		select @Alt = 1    -- assume que tem template alternativo
		if ((@cTempl_tit1tot is Null) or (@cTempl_tit2tot is Null) or 
			(@cTempl_tit3tot is Null) or (@cTempl_tit4aux is Null) or
			(datalength(@cTempl_tit1tot) < 160) or (datalength(@cTempl_tit2tot) < 160) or
			(datalength(@cTempl_tit3tot) < 160) or (datalength(@cTempl_tit4aux) < 32)) 
		begin
			SELECT @Pad = 0
		end 

		IF (datalength(@cTempl_tit4aux) = 32) BEGIN
			SET @cTempl_tit4tot = @cTempl_tit4aux + REPLICATE('0',160-LEN(@cTempl_tit4aux) )
			SET @cTempl_tit5tot = REPLICATE('0', 160)
			SET @cTempl_tit6tot = REPLICATE('0', 26)
		END

		if ((@cTempl_Alt1tot is Null) or (@cTempl_Alt2tot is Null) or
			(@cTempl_Alt3tot is Null) or (@cTempl_Alt4aux is Null) or
			(datalength(@cTempl_Alt1tot) < 160) or (datalength(@cTempl_Alt2tot) < 160) or
			(datalength(@cTempl_Alt3tot) < 160) or (datalength(@cTempl_Alt4aux) < 32)) 
		begin 
			SELECT @Alt = 0
		end

		IF (datalength(@cTempl_Alt4aux) = 32) BEGIN
			SET @cTempl_Alt4tot = @cTempl_Alt4aux + REPLICATE('0',160-LEN(@cTempl_Alt4aux) )
			SET @cTempl_Alt5tot = REPLICATE('0', 160)
			SET @cTempl_Alt6tot = REPLICATE('0', 26)
		END
	end
	
	IF (@RetFun != -2) begin
		if (@Pad = 1) 
			if (@Alt = 1) 
				SET @RetFun = 0   -- tem padrao e tem alternativo
			else 
				SET @RetFun = 1   -- tem padrao e nao tem alternativo
		
		if (@Pad = 0) 
			if (@Alt = 1) 
				SET @RetFun = 2   -- nao tem padrao e tem alternativo
			else 
				SET @RetFun = 3   -- nao tem padrao e nao tem alternativo	
	end

	-- VERIFICA SE NAO ACHOU NENHUMA BIOMETRIA E É COMANDO DE ENVIO DE DIGITAIS, DEVERA GUARDAR INFORMACAO EM DIGLOAD001	
	IF ((@RetFun = 3) and (@cTipoCons != '1' )) 
		INSERT into DIGLOAD001 (END_IP, ICARD, BIO_TIPO) 		-- insere em tabela DIGLOAD001
						VALUES (@cEndIp, @cMatric, @cTipBio);
		
	return (@RetFun)
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlcon_sagem_digitalit'))
	DROP PROCEDURE TELESSVR.sqlcon_sagem_digitalit;
GO

CREATE PROCEDURE TELESSVR.sqlcon_sagem_digitalit @cMatric char(12),
@cTempl_tit1tot CHAR(160) OUTPUT, @cTempl_tit2tot CHAR(160) OUTPUT, 
@cTempl_tit3tot CHAR(160) OUTPUT, @cTempl_tit4tot CHAR(160) OUTPUT, 
@cTempl_Alt1tot CHAR(160) OUTPUT, @cTempl_Alt2tot CHAR(160) OUTPUT, 
@cTempl_Alt3tot CHAR(160) OUTPUT, @cTempl_Alt4tot CHAR(160) OUTPUT,
@cNivel CHAR(2) OUTPUT, @cNivel2 CHAR(2) OUTPUT, 
@cTempl_tit5tot CHAR(160) OUTPUT, @cTempl_Alt5tot CHAR(160) OUTPUT,
@cTempl_tit6tot CHAR(26) OUTPUT, @cTempl_Alt6tot CHAR(26) OUTPUT


AS
DECLARE @RetFun int, @Pad int, @Alt int,@cTempl_tit4aux AS CHAR(32), @cTempl_Alt4aux AS CHAR(32), @cVDigit char(1)
DECLARE @cNivAux CHAR(2),@cNivAux2 CHAR(2);


BEGIN
--	select @RetFun = -1
	set @RetFun = 0;
	select @cTempl_tit1tot = NULL
	select @cTempl_tit2tot = NULL
	select @cTempl_tit3tot = NULL
	select @cTempl_tit4tot = NULL
	select @cTempl_tit4aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	select @cTempl_Alt1tot = NULL
	select @cTempl_Alt2tot = NULL
	select @cTempl_Alt3tot = NULL
	select @cTempl_Alt4tot = NULL
	select @cTempl_Alt4aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	--select @cNivel = NULL
	set @cNivel = '00'
	set @cNivel2 = '00'

	SET	@Pad = 0;
	SET @Alt = 0;
	set @cVDigit = '2';		
	
	IF EXISTS (SELECT Ver_Digit FROM CONTROLE WITH (Index = CONTROLE_IND1)
				WHERE ICARD = @cMatric) 
	begin
		SELECT @cVDigit = Ver_Digit FROM CONTROLE WITH (Index = CONTROLE_IND1)
			WHERE ICARD = @cMatric

		-- procura por Templates da matricula
		IF EXISTS (SELECT * FROM CONTDIG_SAGEM WITH (Index = CONTDIG_SAGEM_IND1) WHERE ICARD = @cMatric)
		begin
			SELECT @cTempl_tit1tot = TEMPL_TIT1,
			   @cTempl_tit2tot = TEMPL_TIT2,
			   @cTempl_tit3tot = TEMPL_TIT3,
			   @cTempl_tit4aux = TEMPL_TIT4,
			   @cTempl_Alt1tot = TEMPL_ALT1,
			   @cTempl_Alt2tot = TEMPL_ALT2,
			   @cTempl_Alt3tot = TEMPL_ALT3,
			   @cTempl_Alt4aux = TEMPL_ALT4,
			   --@cNivel = NIVEL
			   --@cNivAux = NIVEL,
			   @cNivAux = NUM_DEDO_PAD,
			   @cNivAux2 = NUM_DEDO_ALT 
			   
			FROM CONTDIG_SAGEM
			WHERE ICARD = @cMatric
			select @Pad = 1    -- assume que tem template padrao
			select @Alt = 1    -- assume que tem template alternativo
			if ((@cTempl_tit1tot is Null) or (@cTempl_tit2tot is Null) or 
				(@cTempl_tit3tot is Null) or (@cTempl_tit4aux is Null) or
				(datalength(@cTempl_tit1tot) < 160) or (datalength(@cTempl_tit2tot) < 160) or
				(datalength(@cTempl_tit3tot) < 160) or (datalength(@cTempl_tit4aux) < 32)) 
			begin
				SELECT @Pad = 0
			end 

			IF (datalength(@cTempl_tit4aux) = 32) BEGIN
				SET @cTempl_tit4tot = @cTempl_tit4aux + REPLICATE('0',160-LEN(@cTempl_tit4aux) )
				SET @cTempl_tit5tot = REPLICATE('0', 160)
				SET @cTempl_tit6tot = REPLICATE('0', 26)
			END

			if ((@cTempl_Alt1tot is Null) or (@cTempl_Alt2tot is Null) or
				(@cTempl_Alt3tot is Null) or (@cTempl_Alt4aux is Null) or
				(datalength(@cTempl_Alt1tot) < 160) or (datalength(@cTempl_Alt2tot) < 160) or
				(datalength(@cTempl_Alt3tot) < 160) or (datalength(@cTempl_Alt4aux) < 32)) 
			begin 
				SELECT @Alt = 0
			end

			IF (datalength(@cTempl_Alt4aux) = 32) BEGIN
				SET @cTempl_Alt4tot = @cTempl_Alt4aux + REPLICATE('0',160-LEN(@cTempl_Alt4aux) )
				SET @cTempl_Alt5tot = REPLICATE('0', 160)
				SET @cTempl_Alt6tot = REPLICATE('0', 26)
			END
			
					
			if (@cNivAux is not Null) begin
				SET @cNivel = @cNivAux
			end 

			if (@cNivAux2 is not Null) begin
				set @cNivel2 = @cNivAux2
			end 
		end
		ELSE BEGIN
			IF (convert(int,@cVDigit) = 2) 
				SET @RetFun = -2;
			ELSE begin
				SET	@Pad = 0;
				SET @Alt = 0;
			end
		END
		
	end

	if (@Pad = 1) begin
		if (@Alt = 1) 
			SET @RetFun = 0   -- tem padrao e tem alternativo
		else 
			SET @RetFun = 1   -- tem padrao e nao tem alternativo
	end
	
	if (@Pad = 0) begin
		if (@Alt = 1) 
			SET @RetFun = 2   -- nao tem padrao e tem alternativo
		else 
			SET @RetFun = 3   -- nao tem padrao e nao tem alternativo	
	end
	    
	return (@RetFun)
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlnivel_sagemit'))
	DROP PROCEDURE TELESSVR.sqlnivel_sagemit;
GO

CREATE PROCEDURE TELESSVR.sqlnivel_sagemit @cMatric char(12), @cNivel CHAR(2) OUTPUT, @cNivel2 CHAR(2) OUTPUT 

AS
DECLARE @RetFun int
DECLARE @cNivAux CHAR(2),@cNivAux2 CHAR(2);

BEGIN
	select @RetFun = 0
	set @cNivel = '00'
	set @cNivel2 = '00'

	
	-- procura por nivel conferencia digital da matricula
	IF EXISTS (SELECT * FROM CONTDIG_SAGEM WITH (Index = CONTDIG_SAGEM_IND1) WHERE ICARD = @cMatric)
	begin
		SELECT 
		   --@cNivAux = NIVEL,
		   @cNivAux = NUM_DEDO_PAD,
		   @cNivAux2 = NUM_DEDO_ALT 
			   
		FROM CONTDIG_SAGEM WHERE ICARD = @cMatric
			
					
		if (@cNivAux is not Null) begin
			SET @cNivel = @cNivAux
		end 

		if (@cNivAux2 is not Null) begin
			set @cNivel2 = @cNivAux2
		end 
	end
	ELSE BEGIN	
		SET @RetFun = -1;
	END
		
   
	return (@RetFun)
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlnivel_geomoksag2'))
	DROP PROCEDURE TELESSVR.sqlnivel_geomoksag2;
GO

CREATE PROCEDURE TELESSVR.sqlnivel_geomoksag2 @cEndIp CHAR(15), @cBlueb CHAR(2), @cCodin CHAR(2) AS

DECLARE @cBioTipo AS CHAR(1)

DECLARE @Retfun SMALLINT, @Pad int, @Alt int, @cNivel char(2)

	set @cBioTipo = '0'
	set @cNivel = '0'

	IF EXISTS (SELECT * FROM DAT07 WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
	begin
	   	SELECT @cBioTipo = BIO_TIPO 
		FROM DAT07
		WHERE END_IP = @cEndIp and 
			  BLUEB = @cBlueb and 
			  CODIN = @cCodin

		IF ((@cBioTipo = '4') or (@cBioTipo = '5')) begin
			IF EXISTS (SELECT *	FROM GEOMOK001 
						WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
				SELECT @cNivel = NIVEL
					FROM GEOMOK001
					WHERE END_IP = @cEndIp and 
						  BLUEB = @cBlueb and 
						  CODIN = @cCodin
			ELSE
				SET @cNivel = '4'
			end
		ELSE begin 
			IF ((@cBioTipo = '6') or (@cBioTipo = '7') or (@cBioTipo = '9')) begin
				IF EXISTS (SELECT *	FROM GEOMOK001 
							WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
					SELECT @cNivel = NIVELSAG
						FROM GEOMOK001
						WHERE END_IP = @cEndIp and 
							  BLUEB = @cBlueb and 
							  CODIN = @cCodin
				ELSE
					SET @cNivel = '5'
			end
			ELSE begin
				IF (@cBioTipo = '8') begin
					IF EXISTS (SELECT *	FROM GEOMOK001 
								WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
						SELECT @cNivel = NIVEL
							FROM GEOMOK001
							WHERE END_IP = @cEndIp and 
								  BLUEB = @cBlueb and 
								  CODIN = @cCodin
					ELSE
						SET @cNivel = '3'
				end
			end
		end
	end
	
	SET @Retfun = convert(int, @cNivel)
		
	SELECT @cBioTipo, @Retfun
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlatualiza_handkey_tcp'))
	DROP PROCEDURE TELESSVR.sqlatualiza_handkey_tcp;
GO

CREATE PROCEDURE TELESSVR.sqlatualiza_handkey_tcp @matric char(12), @templ1 char(18) AS

DECLARE @cAuxMat char(15), @nRetorno int, @cAux char(1)
BEGIN

	UPDATE CONTDIG SET 
		TEMPL_TIT1 = @templ1,
		TEMPL_TIT2 = null,
		TEMPL_TIT3 = null,
		TEMPL_TIT4 = null,
		
		TEMPL_ALT1 = @templ1,
		TEMPL_ALT2 = null,
		TEMPL_ALT3 = null,
		TEMPL_ALT4 = null,
		
		NIVEL = '1',
		NUM_DEDO_PAD = '1',
		NUM_DEDO_ALT = '1'
		
    WHERE ICARD = @matric


	if (@@ROWCOUNT = 0)
	BEGIN
		INSERT INTO CONTDIG (ICARD, TEMPL_TIT1, TEMPL_TIT2, TEMPL_TIT3, TEMPL_TIT4, 
				TEMPL_ALT1, TEMPL_ALT2, TEMPL_ALT3, TEMPL_ALT4, 
				NIVEL, NUM_DEDO_PAD, NUM_DEDO_ALT) 
		VALUES (@matric, @templ1, NULL, NULL, NULL,
				@templ1, NULL, NULL, NULL,
				'1', '1', '1')

	    SET @nRetorno = 0
	END
	ELSE
	    SET @nRetorno = 1

    return @nRetorno
END
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlBusca_Tsi1_biomet'))
	DROP PROCEDURE TELESSVR.sqlBusca_Tsi1_biomet;
GO

CREATE PROCEDURE TELESSVR.sqlBusca_Tsi1_biomet  @cMatric char(12), @cTipBio char(1), @cEndIp char(15), @cTipoCons char(1),
@cTempl_tit1tot CHAR(160) OUTPUT, @cTempl_tit2tot CHAR(160) OUTPUT, 
@cTempl_tit3tot CHAR(160) OUTPUT, @cTempl_tit4tot CHAR(160) OUTPUT, 
@cTempl_Alt1tot CHAR(160) OUTPUT, @cTempl_Alt2tot CHAR(160) OUTPUT, 
@cTempl_Alt3tot CHAR(160) OUTPUT, @cTempl_Alt4tot CHAR(160) OUTPUT,
@cNivel CHAR(1) OUTPUT,
@cTempl_tit5tot CHAR(160) OUTPUT, @cTempl_Alt5tot CHAR(160) OUTPUT,
@cTempl_tit6tot CHAR(26) OUTPUT, @cTempl_Alt6tot CHAR(26) OUTPUT
AS

DECLARE @cTempl_tit5aux AS CHAR(128), @cTempl_Alt5aux AS CHAR(128), @cVDigit char(1)
DECLARE @RetFun int, @Pad int, @Alt int, @nAchou int

BEGIN
	select @RetFun = 3
	select @cTempl_tit1tot = NULL
	select @cTempl_tit2tot = NULL
	select @cTempl_tit3tot = NULL
	select @cTempl_tit4tot = NULL
	select @cTempl_tit5aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	select @cTempl_Alt1tot = NULL
	select @cTempl_Alt2tot = NULL
	select @cTempl_Alt3tot = NULL
	select @cTempl_Alt4tot = NULL
	select @cTempl_Alt5aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	
	set @cNivel = NULL
	set @cVDigit = '2'
	set @nAchou = 0;
	set @Pad = 0;
	set @Alt = 0;
	
	-- PARA VALIDAÇÃO ONLINE 
	IF (@cTipoCons = '1') 
	begin
		IF EXISTS (SELECT Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric) 
		begin
			SELECT @cVDigit = Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric
			-- procura por Templates da matricula
			IF EXISTS (SELECT * FROM CONTDIG_TSI1  WHERE ICARD = @cMatric)
			begin
				SELECT @cTempl_tit1tot = TEMPL_TIT1,
				   @cTempl_tit2tot = TEMPL_TIT2,
				   @cTempl_tit3tot = TEMPL_TIT3,
				   @cTempl_tit4tot = TEMPL_TIT4,
		   		   @cTempl_tit5aux = TEMPL_TIT5,
				   @cTempl_Alt1tot = TEMPL_ALT1,
				   @cTempl_Alt2tot = TEMPL_ALT2,
				   @cTempl_Alt3tot = TEMPL_ALT3,
		   		   @cTempl_Alt4tot = TEMPL_ALT4,
		   		   @cTempl_Alt5aux = TEMPL_ALT5,
				   @cNivel = NIVEL
				FROM CONTDIG_TSI1
				WHERE ICARD = @cMatric
					
				set @nAchou = 1;
			end
			ELSE begin
				IF (CONVERT(INT,@cVDigit) = 2) 
					set @RetFun = -2;
				ELSE begin
					set @Pad = 0;
					set @Alt = 0;
				end
			end
		end
		ELSE
			set @RetFun = -2;
	end
	
	-- PARA COMANDO CARGA DIGITAIS 
	ELSE begin
		-- procura por Templates da matricula
		IF EXISTS (SELECT * FROM CONTDIG_TSI1  WHERE ICARD = @cMatric)
		begin
			SELECT @cTempl_tit1tot = TEMPL_TIT1,
				   @cTempl_tit2tot = TEMPL_TIT2,
				   @cTempl_tit3tot = TEMPL_TIT3,
				   @cTempl_tit4tot = TEMPL_TIT4,
		   		   @cTempl_tit5aux = TEMPL_TIT5,
				   @cTempl_Alt1tot = TEMPL_ALT1,
				   @cTempl_Alt2tot = TEMPL_ALT2,
				   @cTempl_Alt3tot = TEMPL_ALT3,
		   		   @cTempl_Alt4tot = TEMPL_ALT4,
		   		   @cTempl_Alt5aux = TEMPL_ALT5
			FROM CONTDIG_TSI1
			WHERE ICARD = @cMatric

			set @nAchou = 1;
		end

		ELSE begin
			set @Pad = 0;
			set @Alt = 0;
		end
	end	
	
	-- verifica o conteudo das digitais
	IF (@nAchou = 1) begin
		select @Pad = 1    -- assume que tem template padrao
		select @Alt = 1    -- assume que tem template alternativo
		if ((@cTempl_tit1tot is Null) or (@cTempl_tit2tot is Null) or 
			(@cTempl_tit3tot is Null) or (@cTempl_tit4tot is Null) or 
			(@cTempl_tit5aux is Null) or
			(datalength(@cTempl_tit1tot) < 160) or (datalength(@cTempl_tit2tot) < 160) or
			(datalength(@cTempl_tit3tot) < 160) or (datalength(@cTempl_tit4tot) < 160) or 
			(datalength(@cTempl_tit5aux) < 128)) 
		begin
			SELECT @Pad = 0
		end 
	
		IF (datalength(@cTempl_tit5aux) = 128) BEGIN
			SET @cTempl_tit5tot = @cTempl_tit5aux + REPLICATE('0',160-LEN(@cTempl_tit5aux) )
			SET @cTempl_tit6tot = REPLICATE('0', 26)
		END
	
		if ((@cTempl_Alt1tot is Null) or (@cTempl_Alt2tot is Null) or
			(@cTempl_Alt3tot is Null) or (@cTempl_Alt4tot is Null) or 
			(@cTempl_Alt5aux is Null) or
			(datalength(@cTempl_Alt1tot) < 160) or (datalength(@cTempl_Alt2tot) < 160) or
			(datalength(@cTempl_Alt3tot) < 160) or (datalength(@cTempl_Alt4tot) < 160) or 
			(datalength(@cTempl_Alt5aux) < 128)) 
		begin 
			SELECT @Alt = 0
		end
	
		IF (datalength(@cTempl_Alt5aux) = 128) BEGIN
			SET @cTempl_Alt5tot = @cTempl_Alt5aux + REPLICATE('0',160-LEN(@cTempl_Alt5aux) )
			SET @cTempl_Alt6tot = REPLICATE('0', 26)
		END
	end
	
	IF (@RetFun != -2) begin
		if (@Pad = 1) 
			if (@Alt = 1) 
				SET @RetFun = 0   -- tem padrao e tem alternativo
			else 
				SET @RetFun = 1   -- tem padrao e nao tem alternativo
		
		if (@Pad = 0) 
			if (@Alt = 1) 
				SET @RetFun = 2   -- nao tem padrao e tem alternativo
			else 
				SET @RetFun = 3   -- nao tem padrao e nao tem alternativo	
	end

	-- VERIFICA SE NAO ACHOU NENHUMA BIOMETRIA E É COMANDO DE ENVIO DE DIGITAIS, DEVERA GUARDAR INFORMACAO EM DIGLOAD001	
	IF ((@RetFun = 3) and (@cTipoCons != '1' )) 
		INSERT into DIGLOAD001 (END_IP, ICARD, BIO_TIPO) 		-- insere em tabela DIGLOAD001
						VALUES (@cEndIp, @cMatric, @cTipBio);
		
	return (@RetFun)

END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlcon_coacao_tsi1'))
	DROP PROCEDURE TELESSVR.sqlcon_coacao_tsi1;
GO

CREATE PROCEDURE TELESSVR.sqlcon_coacao_tsi1 @cMatric char(12),
@cTempl_Coa1tot CHAR(160) OUTPUT, @cTempl_Coa2tot CHAR(160) OUTPUT, 
@cTempl_Coa3tot CHAR(160) OUTPUT, @cTempl_Coa4tot CHAR(160) OUTPUT, 
@cTempl_Coa5tot CHAR(160) OUTPUT, @cTempl_Coa6tot CHAR(160) OUTPUT 

AS
DECLARE @RetFun int, @Coa int, @cTempl_Coa5aux AS CHAR(128)
BEGIN
	set @RetFun = 1
	set @Coa = 1
	select @cTempl_Coa1tot = NULL
	select @cTempl_Coa2tot = NULL
	select @cTempl_Coa3tot = NULL
	select @cTempl_Coa4tot = NULL
	select @cTempl_Coa5tot = NULL
	select @cTempl_Coa5aux = NULL
	select @cTempl_Coa6tot = NULL
	
	-- procura por Templates da matricula
	IF EXISTS (SELECT * FROM CONTDIG_TSI1 WHERE ICARD = @cMatric)
	begin
	    SELECT @cTempl_Coa1tot = TEMPL_COA1,
		   @cTempl_Coa2tot = TEMPL_COA2,
		   @cTempl_Coa3tot = TEMPL_COA3,
		   @cTempl_Coa4tot = TEMPL_COA4,
		   @cTempl_Coa5aux = TEMPL_COA5
		FROM CONTDIG_TSI1
		WHERE ICARD = @cMatric

	    IF ((@cTempl_Coa1tot is Null) or (@cTempl_Coa2tot is Null) or 
			(@cTempl_Coa3tot is Null) or (@cTempl_Coa4tot is Null) or 
			(@cTempl_Coa5aux is Null) or
			(datalength(@cTempl_Coa1tot) < 160) or (datalength(@cTempl_Coa2tot) < 160) or
			(datalength(@cTempl_Coa3tot) < 160) or (datalength(@cTempl_Coa4tot) < 160) or 
			(datalength(@cTempl_Coa5aux) < 128))
			SET @Coa = 0
	    else 
	    begin
			SET @cTempl_Coa5tot = @cTempl_Coa5aux + REPLICATE('0',160-LEN(@cTempl_Coa5aux) )
			SET @cTempl_Coa6tot = REPLICATE('0', 26)
	    end
	END

	IF (@Coa = 0) 
	begin
		Set @RetFun = 0
	end
	return (@RetFun)
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlatu_outrosbios_CNX'))
	DROP PROCEDURE TELESSVR.sqlatu_outrosbios_CNX;
GO

CREATE PROCEDURE TELESSVR.sqlatu_outrosbios_CNX @matric VARCHAR(12), @cBioTipo CHAR(1), @cTipo CHAR(1), @cTemplate VARCHAR(MAX)
AS
DECLARE  @nRetorno int
	

    set @nRetorno = 1
    IF NOT EXISTS (SELECT ICARD FROM CONTDIG_OUTROS WHERE ICARD = @matric and BIO_TIPO = @cBioTipo) BEGIN 			-- identificador  do biometrico 
		set @nRetorno = 0
	END
	
    IF (@nRetorno = 0) BEGIN		-- nao ha nenhum cadastro do ICARD+BIOTIPO
    	IF (@cTipo  = '0')		-- padrao
				INSERT INTO CONTDIG_OUTROS (ICARD, BIO_TIPO, DIGITAL_PAD, STATUS, STATUS_REP)  
					VALUES (@matric, @cBioTipo, @cTemplate, '1', '1')
		ELSE IF (@cTipo  = '1')
				INSERT INTO CONTDIG_OUTROS (ICARD, BIO_TIPO, DIGITAL_ALT, STATUS, STATUS_REP)  
					VALUES (@matric, @cBioTipo, @cTemplate,'1', '1')
		ELSE IF (@cTipo  = '2')
				INSERT INTO CONTDIG_OUTROS (ICARD, BIO_TIPO, DIGITAL_COA, STATUS, STATUS_REP)  
					VALUES (@matric, @cBioTipo, @cTemplate,'1', '1')

		IF (@@ROWCOUNT = 0)
			set @nRetorno = 0
	END
	
	ELSE begin
    	IF (@cTipo  = '0') 
				UPDATE CONTDIG_OUTROS 
					SET DIGITAL_PAD = @cTemplate, 
					Status = '1',
					Status_Rep = '1' 
				WHERE Icard = @matric AND 				-- matricula
			  	BIO_TIPO = @cBioTipo; 					-- identificador  do biometrico 
		ELSE IF (@cTipo  = '1')
				UPDATE CONTDIG_OUTROS 
					SET DIGITAL_ALT = @cTemplate, 
					Status = '1',
					Status_Rep = '1' 
				WHERE Icard = @matric AND 				-- matricula
				BIO_TIPO = @cBioTipo; 					-- identificador  do biometrico 
		ELSE IF (@cTipo  = '2')
				UPDATE CONTDIG_OUTROS 
					SET DIGITAL_COA = @cTemplate, 
					Status = '1',
					Status_Rep = '1' 
				WHERE Icard = @matric AND 				-- matricula
			  	BIO_TIPO = @cBioTipo; 					-- identificador  do biometrico 
		IF (@@ROWCOUNT = 0)
			set @nRetorno = 0
	end
	
    return @nRetorno


SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlBusca_Outros_biomet'))
	DROP PROCEDURE TELESSVR.sqlBusca_Outros_biomet;
GO

CREATE PROCEDURE TELESSVR.sqlBusca_Outros_biomet @cMatric char(12), @cBioTipo char(1), @cEndIp char(15), @cTipoCons char(1), @nQtdBytes INT

AS
DECLARE @Retfun int, @Pad int, @Alt int, @nTotal int, @i int, @tam int, @pos int 
DECLARE @cVDigit char(1), @cDigPadChar VARCHAR(MAX), @cDigAltChar VARCHAR(MAX)

DECLARE @Ret INT, @nTotalPad INT , @nTotalAlt INT , @nTamPad INT, @nTamAlt INT, @nAchou INT
DECLARE @cDigPadBin VARBINARY(MAX), @cDigAltBin VARBINARY(MAX)



BEGIN
	SET @Retfun = 3
	SET @Pad = 0
	SET @Alt = 0
	set @cVDigit = '2'
	set @nAchou = 0;

	SET @nTotalPad = 0
	SET @nTotalAlt = 0
	
	SET @nTamPad = 0
	SET @nTamAlt = 0

	-- PARA VALIDAÇÃO ONLINE 
	IF (@cTipoCons = '1') 
	begin
		IF EXISTS (SELECT Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric) 
		begin
			SELECT @cVDigit = Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric

			-- procura por Templates da matricula
			IF EXISTS (SELECT * FROM CONTDIG_OUTROS  WHERE ICARD = @cMatric AND BIO_TIPO = @cBioTipo)		
			begin
				SELECT @cDigPadBin = CONVERT(varbinary(max), DIGITAL_PAD, LEN(DIGITAL_PAD)), 
					   @cDigAltBin = CONVERT(varbinary(max), DIGITAL_ALT, LEN(DIGITAL_ALT)),
					   @nTamPad = LEN(DIGITAL_PAD),
					   @nTamAlt = LEN(DIGITAL_ALT)
					FROM CONTDIG_OUTROS  WHERE ICARD = @cMatric AND BIO_TIPO = @cBioTipo
					
			
				IF (@nTamPad IS NULL) 
					SET @nTotalPad = 0
				ELSE begin
					SET @nTotalPad = @nTamPad
					SET @Pad = 1
				end
					
				IF (@nTamAlt IS NULL) 
					SET @nTotalAlt = 0
				ELSE begin
					SET @nTotalAlt = @nTamAlt
					SET @Alt = 1				
				end
			end
		end
	end




	-- PROCURA PELO PADRAO
	IF EXISTS (SELECT * FROM CONTDIG_OUTROS  WHERE ICARD = @cMatric AND BIO_TIPO = @cBioTipo)		
	begin
		SELECT @cDigPadBin = CONVERT(varbinary(max), DIGITAL_PAD, LEN(DIGITAL_PAD)), 
			   @cDigAltBin = CONVERT(varbinary(max), DIGITAL_ALT, LEN(DIGITAL_ALT)),
			   @nTamPad = LEN(DIGITAL_PAD),
			   @nTamAlt = LEN(DIGITAL_ALT)
			FROM CONTDIG_OUTROS  WHERE ICARD = @cMatric AND BIO_TIPO = @cBioTipo
		

		IF (@nTamPad IS NULL) 
			SET @nTotalPad = 0
		ELSE begin
			SET @nTotalPad = @nTamPad
			SET @Pad = 1
		end
		
		IF (@nTamAlt IS NULL) 
			SET @nTotalAlt = 0
		ELSE begin
			SET @nTotalAlt = @nTamAlt
			SET @Alt = 1				
		end
	end
	-- PREPARA RESULTADO	
	if (@Pad = 1) begin
	    if (@Alt = 1) 
			SET @Retfun = 0;   -- tem padrao e tem alternativo
		else 
			SET @Retfun = 1;   -- tem padrao e nao tem alternativo
	end 
	if (@Pad = 0) begin
	    if (@Alt = 1) 
			SET @Retfun = 2;   -- nao tem padrao e tem alternativo
		else 
			SET @Retfun = 3;   -- nao tem padrao e nao tem alternativo
	end
	
    IF (@Retfun = 3)		-- digital nao cadastrado
    	INSERT into DIGLOAD001 (END_IP, ICARD, BIO_TIPO) 		-- insere em tabela DIGLOAD001
			VALUES (@cEndIp, @cMatric, @cBioTipo);
	
	
	SELECT @Retfun, @cDigPadBin, @cDigAltBin, @nTotalPad, @nTotalAlt	
	    	
END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('PREP_OUTROSBIOS'))
	DROP PROCEDURE TELESSVR.PREP_OUTROSBIOS;
GO

CREATE PROCEDURE TELESSVR.PREP_OUTROSBIOS AS

DECLARE @c_status CHAR(1)
DECLARE @c_biotipo CHAR(1)
DECLARE @c_icard CHAR(12)

DECLARE @xc_status CHAR(1)
DECLARE @xc_icard CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @xc_tipobio CHAR(1)
DECLARE @ret CHAR(1)

DECLARE @z_endip CHAR(15)
DECLARE @nCont SMALLINT
DECLARE @nAchouGrupo SMALLINT
DECLARE @aux_icard CHAR(12)          


SET DATEFORMAT YMD


	set @ret = 0

	-- cursor para matriculas cujas digitais foram alteradas
	DECLARE cur_stdigital CURSOR FOR (select ICARD, STATUS, BIO_TIPO from CONTDIG_OUTROS WHERE STATUS = '1' or STATUS = '3' or STATUS = '8')

	OPEN cur_stdigital
	FETCH NEXT FROM cur_stdigital INTO @c_icard, @c_status, @c_biotipo
	while @@fetch_status != -1
	begin
	
		SET @nAchouGrupo = 0		-- presupoe q nao tem icard x grupo correspondente em tab 
	
		-- *************************************************************************
		-- prepara os ids excluidos (controle.situa = invalido) ou grupos da controle alterados, retirando as digitais de todos os equipamentos 
		IF (@c_status = '3') or (@c_status = '8') BEGIN			-- alterados grupos (3) ou situa invalidos  (8)

			-- MONTA temporaria matricula x equipamentos cadastrados
			INSERT INTO TMP_DIG104 (ICARD, END_IP, STATUS, BIO_TIPO) 		
				SELECT distinct @c_icard, DAT07.END_IP, '0', @c_biotipo 
				FROM DAT07 
				WHERE BIO_TIPO = @c_biotipo and END_IP <> '000.000.000.000';

	
			-- *****************************************************************
			-- COMO ESTA EXCLUINDO O FUNCIONARIO DA EMPRESA (CONTROLE.SITUA = '1' INVALIDO), TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN
			-- COMO ALTEROU O GRUPO, TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN

			DELETE FROM DIG004 WHERE ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1') AND BIO_TIPO = @c_biotipo 
		
		END	

		IF (@c_status = '1') or (@c_status = '3')  BEGIN				-- alteracao na digital ou em grupo

			-- ******************************************************************
			-- para todos icards q alteraram digital, distribui nos equipamentos de acordo com o grupo cadastrado em 
			-- CONTROLE, DAT07,DAT08 
			-- MONTA temporaria matricula com codins com permissao acesso
					
			insert into TMP_DIG004 (ICARD, END_IP, STATUS, BIO_TIPO)
			SELECT distinct A.icard,  A.end_ip, A.st, A.bio_tipo
				FROM 
					-- seleciona os equipamentos que fazem parte dos grupos do usuário
					(SELECT distinct @c_icard as 'icard',  dat07.end_ip, '0' as 'st', dat07.bio_tipo
						from dat07, dat08 
						where 
							dat07.end_ip <> '000.000.000.000' and
							CONVERT(int,dat08.grupo) in (
								select CONVERT(int,grupo) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')  		-- antes era ((SITUA = '1') or (SITUA = '7'))
								  union
								select CONVERT(int,grupo1) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union	
								select CONVERT(int,grupo2) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo3) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_sab) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_dom) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_fer) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,A.grupo) from MATNGRUPOS A, CONTROLE B where A.ICARD = @c_icard  AND B.ICARD = @c_icard AND (B.SITUA <> '1') and (B.VER_DIGIT <> '1')
								) and
						  CONVERT(int,dat07.laces) = CONVERT(int,dat08.laces) and
						  CONVERT(int,dat07.planta) = CONVERT(int,dat08.planta) and
						  dat07.bio_tipo = @c_biotipo   
				UNION
					SELECT distinct @c_icard as 'icard',  dat07.end_ip, '0' as 'st', dat07.bio_tipo
						from dat07, MATCODIN 
						where 
							matcodin.icard = @c_icard and
							matcodin.end_ip <> '000.000.000.000' and 
							matcodin.end_ip = dat07.end_ip and 
							dat07.bio_tipo = @c_biotipo) as A
							
			IF (@c_status = '3') BEGIN
				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao temporaria os equipamentos que fazem parte do novo grupo

				DELETE FROM TMP_DIG104
					WHERE EXISTS
						(SELECT TMP_DIG004.icard 
							FROM 
								TMP_DIG004
							WHERE 
								TMP_DIG004.icard = TMP_DIG104.icard and
								TMP_DIG004.END_IP = TMP_DIG104.END_IP and
							  	TMP_DIG004.icard = @c_icard
						);

				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao final os equipamentos do ID em questão, para REFAZER a tabela
				DELETE from DIG104 where ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1') AND BIO_TIPO = @c_biotipo
			END
							
		END

		-- ******************************************************************
		-- PREPARA TABELA TEMPORARIA DE INCLUSAO COM OS ENDEREÇOS IP 
		SET @nCont = (SELECT COUNT(*) FROM TMP_DIG004)

		-- verifica se a matricula esta cadastrada em controle e se pertence a alguma codin. 
		-- Caso negativo, seu status ainda continua setado até que seja cadastrada e pertença a algum local de acesso
		IF (@nCont != 0) BEGIN

			-- insere icard-codin em tab. DIG004, se não existir em tab.
			DECLARE cur_tmpdigital CURSOR FOR (select ICARD, END_IP, STATUS, BIO_TIPO from TMP_DIG004)
			OPEN cur_tmpdigital
			FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio

			while @@fetch_status != -1
			begin
				UPDATE DIG004 SET STATUS = '1' 
					WHERE  ICARD = @xc_icard AND
						   END_IP = @xc_endip
				if @@rowcount = 0
				begin		
					INSERT INTO DIG004 (ICARD, END_IP, STATUS, BIO_TIPO) 
						values (@xc_icard, @xc_endip, '1', @xc_tipobio);
				end

				FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio
			end
			
			SET @nAchouGrupo = 1;
			
			-- coloca o codin na tab. DIG002 (CARGA LISTA) o codin não existir
			insert into DIG002 (END_IP, DATA_LOAD, STATUS, BIO_TIPO)
				select distinct end_ip, getdate(), '0', bio_tipo  
				from
					DIG004
				where
					end_ip not in ( select end_ip from DIG002 );
			
			CLOSE cur_tmpdigital
			DEALLOCATE cur_tmpdigital
		END

		-- ******************************************************************
		-- PREPARA TABELA TEMPORARIA DE EXCLUSAO COM OS ENDEREÇOS IP DOS EQUIPAMENTOS
		SET @nCont = (SELECT COUNT(*) FROM TMP_DIG104)
		IF (@nCont != 0) BEGIN

			-- insere na tabela final DIG104  os ID COM STATUS de carga (0 / 1= a excluir)
			DECLARE cur_tmpdigital CURSOR FOR (select ICARD, END_IP, STATUS, BIO_TIPO from TMP_DIG104)
			OPEN cur_tmpdigital
			FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio

			WHILE @@fetch_status != -1 BEGIN
				UPDATE DIG104 SET STATUS = '1' 
					WHERE  ICARD = @xc_icard AND
						   END_IP = @xc_endip AND 
						   BIO_TIPO = @xc_tipobio
				if @@rowcount = 0
				begin		
					INSERT INTO DIG104 (ICARD, END_IP, STATUS, BIO_TIPO) 
						values (@xc_icard, @xc_endip, '1', @xc_tipobio);
				end

				FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio
			end
			
			SET @nAchouGrupo = 1;

			-- coloca o equipamento na tab. DIG102 (CARGA LISTA) o equipamento q não existir
			insert into DIG102 (END_IP, DATA_LOAD, STATUS, BIO_TIPO)
				select distinct END_IP, GETDATE(), '0', BIO_TIPO
				from
					DIG104
				where
					END_IP not in ( select END_IP from DIG102 );
							
			CLOSE cur_tmpdigital
			DEALLOCATE cur_tmpdigital
		END	


		-- atualiza status da matricula, como tratado
		IF (@nAchouGrupo = 1) 	
			update CONTDIG_OUTROS SET STATUS = '0' 
				where ICARD = @c_icard  AND 
					  BIO_TIPO = @c_biotipo;
			
		DELETE TMP_DIG004
		DELETE TMP_DIG104

		FETCH NEXT FROM cur_stdigital INTO @c_icard, @c_status, @c_biotipo
	end
	CLOSE cur_stdigital
	deallocate cur_stdigital

GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlload_listadig3'))
	DROP PROCEDURE TELESSVR.sqlload_listadig3;
GO

CREATE PROCEDURE TELESSVR.sqlload_listadig3  @cMatric CHAR(12), @cEndIp CHAR(15), @cTipo CHAR(1), @cErro CHAR(1) AS

DECLARE @Ret smallint, @cStatus CHAR(1), @cBioTipo CHAR(1), @ERR INT  , @cAux char(12)

	SET @Ret = 0
	SET LOCK_TIMEOUT 2000
	SET @cBioTipo = '0'
	
	SELECT @cBioTipo = BIO_TIPO FROM DIG002
		WHERE END_IP = @cEndIp;
				  
	IF (@cBioTipo = '6' or @cBioTipo = '7') 		-- (SAGEM)
		UPDATE DIG001 SET STATUS = @cTipo 
			where ICARD = @cMatric and
				  END_IP = @cEndIp;
	ELSE  
		IF (@cBioTipo = '8')		--  (TSI1)
			UPDATE DIG003 SET STATUS = @cTipo 				  
				where ICARD = @cMatric and
				  	END_IP = @cEndIp;
		ELSE
			IF (@cBioTipo != '0')		--  VIRDI ('9') E OUTRAS BIOMETRIAS
				UPDATE DIG004 SET STATUS = @cTipo 				  
					where ICARD = @cMatric and
						END_IP = @cEndIp;
	
	
	-- NOVO
	IF (@cTipo = '0') 		-- NAOU HOUVE ERRO NA CARGA
		INSERT INTO HISTDIG (IFUNC, END_IP, BIO_TIPO, INSEXC, MODO) VALUES (@cMatric, @cEndIp, @cBioTipo, 'I', 'A')	-- TIPO:'I'= INCLUSAO, 'E'=EXCLUSAO; MODO:'A'=AUTOMATICO, 'M'=MANUAL

	ELSE begin	-- HOUVE ERRO NA CARGA, INSERE NA TABELA DE ERROS DIGLOAD001
		IF (@cTipo = '6') OR (@cTipo = '7') 	-- ERRO DE CARGA (devido a memoria cheiia, minucia errada: que nao adianta enviar a digital novamente ao equipamento )
			INSERT INTO DIGLOAD001 (END_IP, ICARD, BIO_TIPO, NERRO) VALUES (@cEndIp, @cMatric, @cBioTipo, @cErro);
	end
	-- FIM NOVO
	

	UPDATE DIG002 SET DATA_LOAD = getdate() where END_IP = @cEndIp
	
	
	SET LOCK_TIMEOUT -1
	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlfim_ExcAutoDigit2'))
	DROP PROCEDURE TELESSVR.sqlfim_ExcAutoDigit2;
GO

CREATE PROCEDURE TELESSVR.sqlfim_ExcAutoDigit2 @cEndIp CHAR(15), @cStat CHAR(1), @cBioTipo CHAR(1) AS

declare @nCont smallint
declare @nErr smallint
declare @Aux char(12)
declare @cIcard char(12)
declare @STATUS char(1)

	SET LOCK_TIMEOUT 5000
	SET @nCont = 0
	SET @nErr = 0
	
	IF (@cBioTipo =  '6' or @cBioTipo = '7') BEGIN		-- SAGEM
		DECLARE lexcldig_cur CURSOR FOR
			SELECT ICARD, STATUS FROM DIG101 
				WHERE END_IP = @cEndIp AND STATUS = '2'
				ORDER by ICARD;

		OPEN lexcldig_cur
		FETCH next from lexcldig_cur into @cIcard, @STATUS
		WHILE (@@fetch_status != -1)
		begin
			update DIG101 set STATUS = @cStat where current of lexcldig_cur 
			SET @nCont = @nCont+1

			fetch next from lexcldig_cur into @cIcard, @STATUS
		end
		close lexcldig_cur
		deallocate lexcldig_cur
	END

	ELSE	
	BEGIN
		IF (@cBioTipo = '8') BEGIN		-- TSI1
			DECLARE lexcldig_cur CURSOR FOR
				SELECT ICARD, STATUS FROM DIG103 
					WHERE END_IP = @cEndIp AND STATUS = '2'
					ORDER by ICARD;

			OPEN lexcldig_cur
			FETCH next from lexcldig_cur into @cIcard, @STATUS
			WHILE (@@fetch_status != -1)
			begin
				update DIG103 set STATUS = @cStat where current of lexcldig_cur 
				SET @nCont = @nCont+1

				fetch next from lexcldig_cur into @cIcard, @STATUS
			end
			close lexcldig_cur
			deallocate lexcldig_cur
		END
		ELSE
			--IF (@cBioTipo = '9') BEGIN		-- VIRDI
			IF (@cBioTipo != '0') BEGIN		-- VIRDI / OUTROS
				DECLARE lexcldig_cur CURSOR FOR
					SELECT ICARD, STATUS FROM DIG104 
						WHERE END_IP = @cEndIp AND STATUS = '2'
						ORDER by ICARD;

				OPEN lexcldig_cur
				FETCH next from lexcldig_cur into @cIcard, @STATUS
				WHILE (@@fetch_status != -1)
				begin
					update DIG104 set STATUS = @cStat where current of lexcldig_cur 
					SET @nCont = @nCont+1

					fetch next from lexcldig_cur into @cIcard, @STATUS
				end
				close lexcldig_cur
				deallocate lexcldig_cur
			END
	END
		

	UPDATE DIG102 SET STATUS = @cStat WHERE END_IP = @cEndIp;
	SET LOCK_TIMEOUT -1


	return @nCont	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqller_autoExclDigit2'))
	DROP PROCEDURE TELESSVR.sqller_autoExclDigit2;
GO

CREATE PROCEDURE TELESSVR.sqller_autoExclDigit2 @cEndIp VARCHAR(15) AS

declare @nCont smallint
declare @nBloco smallint
declare @nTotal smallint
declare @cStatus char(1)
declare @cBio_Tipo char(1)
declare @ICARD varchar(12)
declare @STATUS char(1)
declare @cListaId VARCHAR(250)
declare @cListaId_1 VARCHAR(250)
declare @cListaId_2 VARCHAR(250)
declare @cListaId_3 VARCHAR(250)
declare @cListaId_4 VARCHAR(250)
declare @cListaId_5 VARCHAR(250)

	SET @nCont = 0
	SET @nBloco = 1
	SET @nTotal = 0
	
	SET @cListaId = ''
	SET @cListaId_1 = ''
	SET @cListaId_2 = ''
	SET @cListaId_3 = ''
	SET @cListaId_4 = ''
	SET @cListaId_5 = ''

	SET LOCK_TIMEOUT 2000

	-- procura pelo equipamento
	IF EXISTS (SELECT * FROM DIG102  WHERE END_IP = @cEndIp AND STATUS = '1')
	BEGIN
	    SELECT @cStatus = STATUS, @cBio_Tipo = BIO_TIPO
			FROM DIG102 NOLOCK
			WHERE END_IP = @cEndIp

		IF (@cStatus = '1') BEGIN
			IF (@cBio_Tipo = '6' or @cBio_Tipo = '7') BEGIN		-- SAGEM
				DECLARE ldigit_cur CURSOR FOR
					SELECT ICARD, STATUS FROM DIG101 
						WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
							order by ICARD;

				open ldigit_cur
				fetch next from ldigit_cur into @ICARD, @STATUS
				while (@@fetch_status != -1) and (@nTotal < 32) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE DIG101 set STATUS = '2' where current of ldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					if (@nCont > 8) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from ldigit_cur into @ICARD, @STATUS
				end
				close ldigit_cur
				deallocate ldigit_cur
			END
			
			-- TSI1	
			ELSE IF (@cBio_Tipo = '8') BEGIN
				DECLARE ldigit_cur CURSOR FOR
					SELECT ICARD, STATUS FROM DIG103 
						WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
							order by ICARD;

				open ldigit_cur
				fetch next from ldigit_cur into @ICARD, @STATUS
				while (@@fetch_status != -1) and (@nTotal < 32) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE DIG103 set STATUS = '2' where current of ldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					if (@nCont > 8) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from ldigit_cur into @ICARD, @STATUS
				end
				close ldigit_cur
				deallocate ldigit_cur
			END
			
			-- VIRDI	
			ELSE 
				--IF (@cBio_Tipo = '9') BEGIN		
				IF (@cBio_Tipo != '0') BEGIN		
				DECLARE ldigit_cur CURSOR FOR
					SELECT ICARD, STATUS FROM DIG104 
						WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
							order by ICARD;

				open ldigit_cur
				fetch next from ldigit_cur into @ICARD, @STATUS
				while (@@fetch_status != -1) and (@nTotal < 32) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE DIG104 set STATUS = '2' where current of ldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					if (@nCont > 8) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from ldigit_cur into @ICARD, @STATUS
				end
				close ldigit_cur
				deallocate ldigit_cur
			END
			
			IF ((@nCont > 0) AND (@nCont <= 8))
				if (@nBloco = 1) 
					set @cListaId_1 = @cListaId
				else if (@nBloco = 2) 
					set @cListaId_2 = @cListaId
				else if (@nBloco = 3) 
					set @cListaId_3 = @cListaId
				else if (@nBloco = 4) 
					set @cListaId_4 = @cListaId
				else if (@nBloco = 5) 
					set @cListaId_5 = @cListaId

			IF (@nTotal = 0) 
				UPDATE DIG102 SET STATUS = '0' WHERE END_IP = @cEndIp;
			ELSE 
				UPDATE DIG102 SET 
					STATUS = '2',
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;

		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaId_1 as cListaId_1,
		   @cListaId_2 as cListaId_2,
		   @cListaId_3 as cListaId_3,
		   @cListaId_4 as cListaId_4,
		   @cListaId_5 as cListaId_5
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO
	
IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqller_autoLoadDigit2'))
	DROP PROCEDURE TELESSVR.sqller_autoLoadDigit2;
GO

CREATE PROCEDURE TELESSVR.sqller_autoLoadDigit2  @cEndIp VARCHAR(15) AS

declare @nCont smallint
declare @nBloco smallint
declare @nTotal smallint
declare @cStatus char(1)
declare @cBio_Tipo char(1)
declare @ICARD varchar(12)
declare @STATUS char(1)
declare @cListaId VARCHAR(250)
declare @cListaId_1 VARCHAR(250)
declare @cListaId_2 VARCHAR(250)
declare @cListaId_3 VARCHAR(250)
declare @cListaId_4 VARCHAR(250)
declare @cListaId_5 VARCHAR(250)

	SET @nCont = 0
	SET @nBloco = 1
	SET @nTotal = 0
	
	SET @cListaId = ''
	SET @cListaId_1 = ''
	SET @cListaId_2 = ''
	SET @cListaId_3 = ''
	SET @cListaId_4 = ''
	SET @cListaId_5 = ''

	SET LOCK_TIMEOUT 5000

	-- procura pelo equipamento
	IF EXISTS (SELECT * FROM DIG002  WHERE END_IP = @cEndIp and STATUS = '1')
	BEGIN
	    SELECT @cStatus = STATUS, @cBio_Tipo = BIO_TIPO
			FROM DIG002
			WHERE END_IP = @cEndIp

		IF (@cStatus = '1') BEGIN
			IF (@cBio_Tipo = '6' or @cBio_Tipo = '7') BEGIN		-- SAGEM
				DECLARE ldigit_cur CURSOR FOR
					SELECT ICARD, STATUS FROM DIG001 
						WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
							order by ICARD;

				open ldigit_cur
				fetch next from ldigit_cur into @ICARD, @STATUS
				while (@@fetch_status != -1) and (@nTotal < 24) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE DIG001 set STATUS = '2' where current of ldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					if (@nCont >= 5) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from ldigit_cur into @ICARD, @STATUS
				end
				close ldigit_cur
				deallocate ldigit_cur
			END
			
			ELSE 
				IF (@cBio_Tipo = '8') BEGIN		-- TSI1
					DECLARE ldigit_cur CURSOR FOR
						SELECT ICARD, STATUS FROM DIG003 
							WHERE (END_IP = @cEndIp) and (STATUS != '0') and (STATUS != '2')
						ORDER by ICARD;

					open ldigit_cur
					fetch next from ldigit_cur into @ICARD, @STATUS
					while (@@fetch_status != -1) and (@nTotal < 24) 
					begin
						SET @cListaId = @cListaId + @ICARD
						UPDATE DIG003 set STATUS = '2' where current of ldigit_cur
						SET @nCont = @nCont+1
						set @nTotal = @nTotal + 1

						if (@nCont >= 5) begin
							if (@nBloco = 1) 
								set @cListaId_1 = @cListaId
							else if (@nBloco = 2) 
								set @cListaId_2 = @cListaId
							else if (@nBloco = 3) 
								set @cListaId_3 = @cListaId
							else if (@nBloco = 4) 
								set @cListaId_4 = @cListaId
							else if (@nBloco = 5) 
								set @cListaId_5 = @cListaId
							set @cListaId = ''
							set @nBloco = @nBloco+1
							set @nCont = 0
						end
						fetch next from ldigit_cur into @ICARD, @STATUS
					end
					close ldigit_cur
					deallocate ldigit_cur
				END
						
				-- VIRDI E OUTROS
				--IF (@cBio_Tipo = '9') BEGIN		
				ELSE 
					IF (@cBio_Tipo != '0') BEGIN		
						DECLARE ldigit_cur CURSOR FOR
							SELECT ICARD, STATUS FROM DIG004 
								WHERE (END_IP = @cEndIp) and (STATUS != '0') and (STATUS != '2')
							ORDER by ICARD;

						open ldigit_cur
						fetch next from ldigit_cur into @ICARD, @STATUS
						while (@@fetch_status != -1) and (@nTotal < 24) 
						begin
							SET @cListaId = @cListaId + @ICARD
							UPDATE DIG004 set STATUS = '2' where current of ldigit_cur
							SET @nCont = @nCont+1
							set @nTotal = @nTotal + 1

							if (@nCont >= 5) begin
								if (@nBloco = 1) 
									set @cListaId_1 = @cListaId
								else if (@nBloco = 2) 
									set @cListaId_2 = @cListaId
								else if (@nBloco = 3) 
									set @cListaId_3 = @cListaId
								else if (@nBloco = 4) 
									set @cListaId_4 = @cListaId
								else if (@nBloco = 5) 
									set @cListaId_5 = @cListaId
								set @cListaId = ''
								set @nBloco = @nBloco+1
								set @nCont = 0
							end
							fetch next from ldigit_cur into @ICARD, @STATUS
						end
						close ldigit_cur
						deallocate ldigit_cur
					END

			IF ((@nCont > 0) AND (@nCont < 5))
				if (@nBloco = 1) 
					set @cListaId_1 = @cListaId
				else if (@nBloco = 2) 
					set @cListaId_2 = @cListaId
				else if (@nBloco = 3) 
					set @cListaId_3 = @cListaId
				else if (@nBloco = 4) 
					set @cListaId_4 = @cListaId
				else if (@nBloco = 5) 
					set @cListaId_5 = @cListaId

			IF (@nTotal = 0) 
				UPDATE DIG002 SET STATUS = '0' WHERE END_IP = @cEndIp;
			ELSE 
				UPDATE DIG002 SET 
					STATUS = '2',
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;
		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaId_1 as cListaId_1,
		   @cListaId_2 as cListaId_2,
		   @cListaId_3 as cListaId_3,
		   @cListaId_4 as cListaId_4,
		   @cListaId_5 as cListaId_5
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO
	
IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('trata3_tsi1'))
	DROP PROCEDURE TELESSVR.trata3_tsi1;
GO

CREATE PROCEDURE TELESSVR.trata3_tsi1 AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)

DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000


	-- ********************   ARRUMAR SITUAÇÕES PARA TSI1    -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA  (status '4')
	DECLARE cur_troubleIns1 CURSOR FOR 
		(SELECT distinct ICARD from DIG003 
			WHERE STATUS = '4'
		)
	OPEN cur_troubleIns1
	FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE cur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from DIG003 
				WHERE (ICARD = @z_mat and STATUS = '4')
			)
		OPEN cur_troubleIns2
		FETCH NEXT FROM cur_troubleIns2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			DELETE DIG003 WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '4')

			UPDATE DIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM cur_troubleIns2 INTO @z_endip
		END


		CLOSE cur_troubleIns2
		deallocate cur_troubleIns2

		FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	END
	
	CLOSE cur_troubleIns1
	deallocate cur_troubleIns1

	

	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS TSI1 (DA TAB.CONTDIG_TSI1 CADASTRO)
	-- delete registro de DIG003 se nao houver cadastro de BIO TSI1 desta matricula
	DECLARE cur_autoIns1 CURSOR FOR 
		(SELECT distinct ICARD from DIG003 
			WHERE STATUS = '3'
		)
	OPEN cur_autoIns1
	FETCH NEXT FROM cur_autoIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		-- VERIFICA SE HÁ CADASTRO DO BIO TSI1 DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_TSI1 WHERE ICARD = @z_mat;
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO TSI1 desta matricula
			DECLARE cur_autoIns2 CURSOR FOR 
				(SELECT END_IP from DIG003 
					WHERE (ICARD = @z_mat and STATUS = '3')
				)
			OPEN cur_autoIns2
			FETCH NEXT FROM cur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				--UPDATE DIG003 set status = '0' WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '3')
				DELETE DIG003 WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '3')

				UPDATE DIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM cur_autoIns2 INTO @z_endip
			END


			CLOSE cur_autoIns2
			deallocate cur_autoIns2
		END

		FETCH NEXT FROM cur_autoIns1 INTO @z_mat
	END
	
	CLOSE cur_autoIns1
	deallocate cur_autoIns1







	-- altera status de todos os codins para carga de digitais, se esses não estiverem com carga de digitais ou estiverem pendentes

	DECLARE cur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO from DIG003 
			WHERE (STATUS != '0' and STATUS != '2' AND BIO_TIPO = '8')		-- biometrias pendentes na carga
		)
	OPEN cur_endip
	FETCH NEXT FROM cur_endip INTO @z_endip, @z_biotipo
	
	while @@fetch_status != -1
	begin
		UPDATE DIG002 set status = '1'
			WHERE (END_IP = @z_endip and 
					(STATUS = '0' or STATUS= '3') and 
				  	BIO_TIPO = @z_biotipo)
		FETCH NEXT FROM cur_endip INTO @z_endip, @z_biotipo
	end
	CLOSE cur_endip
	deallocate cur_endip



	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos TSI1 q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos TSI1 q tiveram carga de aplicativo 
	DECLARE cur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from DIG002 
			WHERE ((BIO_TIPO = '8')
					and
				   (status = '5' or status = '6' OR			-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))
				  )
		)
	OPEN cur_dig02
	FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_biotipo, @z_status

	WHILE @@fetch_status != -1
	begin
		-- OBSERVACAO: PARA BIOMETRIA TSI1, A CARGA DE APLICATIVO NO EQUIPAMENTO NAO APAGA AS BIOMETRIAS, POIS BIOMETRIA TSI1 FICA NO LEITOR E NAO NO EQUIPAMENTO,
		-- LOGO NAO É NECESSARIO FAZER A RECARGA DE BIOMETRIA
		IF (@z_status = '2') begin		-- situação q estava fazendo a carga e deu problema

			UPDATE DIG003 set STATUS = '1'			-- status = 1 : a carregar
				WHERE (END_IP = @z_endip and STATUS = '2'  and BIO_TIPO = @z_biotipo) 

			UPDATE DIG002 set status = '1' 
				where (END_IP = @z_endip and BIO_TIPO = @z_biotipo)
		end

		ELSE begin
			IF (@z_status = '5' or @z_status = '6') begin		-- HOUVE CARGA DE APLICATIVO, MAS NAO VAI RECARREGAR AS BIOMETRIAS
				UPDATE DIG002 set status = '0' 
					WHERE (end_ip = @z_endip  and BIO_TIPO = @z_biotipo)
			end
		end
		
		FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end

	CLOSE cur_dig02
	DEALLOCATE cur_dig02
	


	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUAÇÃO
	-- para BIOMETRIAS  TSI1 DE DIG003 que ficaram em estado carregando '2', e o equipamento está em estado de repouso	, forca o equipamento a carrega-lo novamente

	DECLARE cur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.status from DIG002 A 
			INNER JOIN DIG003 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = '8')
	OPEN cur_dig02
	FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG003 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' AND BIO_TIPO = '8';
		UPDATE DIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip  and BIO_TIPO = '8';
			
		FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_status;
	END
	CLOSE cur_dig02
	deallocate cur_dig02
	


	-- ********************   ARRUMAR SITUAÇÕES PARA   TSI1   -  EXCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins Sagem para exclusao de biometria, se esses não estiverem com exclusao de biometria ou estiverem pendentes

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO from DIG103 
			WHERE (STATUS != '0' and STATUS != '2' and BIO_TIPO = '8')
		)
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG102 set STATUS = '1'
			WHERE (END_IP = @z_endip) and 
			  	  (STATUS = '0' or STATUS = '3') and 
				  (BIO_TIPO = '8')

		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE cur_autoExc1
	deallocate cur_autoExc1
	


	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from DIG102 
			WHERE ( (BIO_TIPO = '8')
					and
					(status = '5' or status = '6' or 													-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip,  @z_biotipo, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE DIG103 set status = '1'
				WHERE (END_IP = @z_endip) and (status = '2') and (BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')

			UPDATE DIG102 set status = '1' 
				WHERE (END_IP = @z_endip  and BIO_TIPO = @z_biotipo)
		end
				
		else if (@z_status = '5' or @z_status = '6') begin
			UPDATE DIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;
				
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE cur_autoExc1
	deallocate cur_autoExc1



	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUAÇÃO
	-- para digitais de DIG103 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.status from DIG102 A 
			INNER JOIN DIG103 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = '8')
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG103 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and BIO_TIPO = '8';
		UPDATE DIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip and BIO_TIPO = '8';
	
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status;
	END
	CLOSE cur_autoExc1
	deallocate cur_autoExc1

	SET LOCK_TIMEOUT -1
	
	GO


SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('trata3_sagem'))
	DROP PROCEDURE TELESSVR.trata3_sagem;
GO

CREATE PROCEDURE TELESSVR.trata3_sagem AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)
DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)
SET DATEFORMAT YMD
	SET LOCK_TIMEOUT 3000
	-- ********************   ARRUMAR SITUA??ES PARA SAGEM    -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA (status '4')
	DECLARE cur_troubleIns1 CURSOR FOR 
		(SELECT distinct ICARD from DIG001 
			WHERE STATUS = '4'
		)
	OPEN cur_troubleIns1
	FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE cur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from DIG001 
				WHERE (ICARD = @z_mat and STATUS = '4')
			)
		OPEN cur_troubleIns2
		FETCH NEXT FROM cur_troubleIns2 INTO @z_endip
		WHILE (@@fetch_status != -1) BEGIN
			DELETE DIG001 WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '4')	-- vai excluir registro porque nao adianta reenviar 
			UPDATE DIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;
			FETCH NEXT FROM cur_troubleIns2 INTO @z_endip
		END
		CLOSE cur_troubleIns2
		deallocate cur_troubleIns2
		FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	END
	
	CLOSE cur_troubleIns1
	deallocate cur_troubleIns1
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS SAGEM (DA TAB.CONTDIG_SAGEM CADASTRO)
	-- delete registro de DIG001 se nao houver cadastro de BIO SAGEM desta matricula
	DECLARE cur_autoIns1 CURSOR FOR 
		(SELECT distinct ICARD from DIG001 
			WHERE STATUS = '3'
		)
	OPEN cur_autoIns1
	FETCH NEXT FROM cur_autoIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		-- VERIFICA SE H? CADASTRO DO BIO SAGEM DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_SAGEM WHERE ICARD = @z_mat;
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO SAGEM desta matricula
			DECLARE cur_autoIns2 CURSOR FOR 
				(SELECT END_IP from DIG001 
					WHERE (ICARD = @z_mat and STATUS = '3')
				)
			OPEN cur_autoIns2
			FETCH NEXT FROM cur_autoIns2 INTO @z_endip
			WHILE (@@fetch_status != -1) BEGIN
				--UPDATE DIG001 set status = '0' WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '3')
				DELETE DIG001 WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '3')
				UPDATE DIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;
				FETCH NEXT FROM cur_autoIns2 INTO @z_endip
			END
			CLOSE cur_autoIns2
			deallocate cur_autoIns2
		END
		FETCH NEXT FROM cur_autoIns1 INTO @z_mat
	END
	
	CLOSE cur_autoIns1
	deallocate cur_autoIns1
	-- altera status de todos os codins para carga de digitais, se esses n?o estiverem com carga de digitais ou estiverem pendentes
	DECLARE cur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO from DIG001 
			WHERE ( status != '0' and status != '2' and			-- biometrias pendentes na carga
					(BIO_TIPO = '6' OR BIO_TIPO = '7')
				  )
		)
	OPEN cur_endip
	FETCH NEXT FROM cur_endip INTO @z_endip, @z_biotipo
	
	WHILE @@fetch_status != -1
	begin
		UPDATE DIG002 set status = '1'						-- FORCA RECARGA DAS BIOMETRIAS PENDENTES, ATIVANDO DIG002
			WHERE (END_IP = @z_endip and 
					(STATUS = '0' or STATUS = '3') and 
					BIO_TIPO = @z_biotipo)
		FETCH NEXT FROM cur_endip INTO @z_endip, @z_biotipo
	end
	CLOSE cur_endip
	deallocate cur_endip
	-- ********************   TRATA EQUIPAMENTOS SAGEM QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos SAGEM q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos SAGEM que tiveram carga de aplicativo ('5') de devem voltar ao estado de repouso. OBS: nao est? fazenda a recarga de biometria automaticamente.
	
	DECLARE cur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from DIG002 
			WHERE ((BIO_TIPO = '6' or BIO_TIPO = '7')
				   and
				   (status = '5' or status = '6' OR		-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())) 
				  )
		)
	OPEN cur_dig02
	FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_biotipo, @z_status
	
	WHILE @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE DIG001 set STATUS = '1'			-- status = 1 (A carregar)
				WHERE (end_ip = @z_endip and status = '2' and BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')
					
			UPDATE DIG002 set status = '1'  		-- FOR?A A RECARGA PARA AQUELS QUE DERAM PROBLEMA
				where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)
		end
		else if (@z_status = '5' or @z_status = '6') begin
			-- exec TELESSVR.recarga_sagem @z_endip							-- CHAMADA DE PROCEDURE QUE PREPARA DIG001 COM AS MATRICULAS A SEREM CARREGADAS NO EQUIPMENTO QUE TEVE CARGA DE APLICATIVO
			-- UPDATE DIG002 set status = '1' where (end_ip = @z_endip)		-- FAZ RECARGA DE BIOMETRIAS SAGEM APOS CARGA DE APLICATIVO, automaticamente
			UPDATE DIG002 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)		-- NAO FAZ RECARGA DE BIOMETRIAS SAGEM APOS CARGA DE APLICATIVO
		end;
		
		FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE cur_dig02
	DEALLOCATE cur_dig02
	
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUA??O
	-- para BIOMETRIAS  SAGEM DE DIG001 que ficaram em estado carregando '2', e o equipamento est? em estado de repouso	, forca o equipamento a carrega-lo novamente
	
	DECLARE cur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.STATUS from DIG002 A 
			INNER JOIN DIG001 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				(A.BIO_TIPO = '6') or (A.BIO_TIPO = '7')) 
	OPEN cur_dig02
	FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_status
	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG001 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and (BIO_TIPO = '6' or BIO_TIPO = '7');
		UPDATE DIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip and (BIO_TIPO = '6' or BIO_TIPO = '7');
		
		FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_status;
	END
	CLOSE cur_dig02
	deallocate cur_dig02
	
	
	-- ********************   ARRUMAR SITUA??ES PARA SAGEM    -  EXCLUSAO
	
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins Sagem para exclusao de biometria, se esses n?o estiverem com exclusao de biometria ou estiverem pendentes
	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO  from DIG101 
			WHERE ( STATUS != '0' and STATUS != '2' and  STATUS != '4' and 
					(BIO_TIPO = '6' or BIO_TIPO = '7')
				  )
		)
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo
	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG102 set status = '1'
			WHERE (END_IP = @z_endip) and 
				(STATUS = '0' or STATUS = '3') and 
				(BIO_TIPO = '6' or BIO_TIPO = '7')
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE cur_autoExc1
	deallocate cur_autoExc1
	
	
	-- ********************   TRATA EQUIPAMENTOS SAGEM QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 
	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from DIG102 
			WHERE ( (BIO_TIPO = '6' or BIO_TIPO = '7')
					and
					(status = '5' or status = '6' or 													-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE DIG101 set status = '1'
				WHERE (END_IP = @z_endip and STATUS = '2' and BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')
			UPDATE DIG102 set status = '1' 
					where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)
		end
		
		else if (@z_status = '5' or @z_status = '6') begin
			UPDATE DIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE cur_autoExc1
	deallocate cur_autoExc1
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUA??O
	-- para digitais de DIG101 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente
	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.status from DIG102 A 
			INNER JOIN DIG101 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				(A.BIO_TIPO = '6' or A.BIO_TIPO = '7'))
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status
	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG101 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and (BIO_TIPO = '6' or BIO_TIPO = '7');
		UPDATE DIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip AND (BIO_TIPO = '6' or BIO_TIPO = '7');
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status;
	END
	CLOSE cur_autoExc1
	deallocate cur_autoExc1
	SET LOCK_TIMEOUT -1
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('trata_OutrosBios'))
	DROP PROCEDURE TELESSVR.trata_OutrosBios;
GO

CREATE PROCEDURE TELESSVR.trata_OutrosBios AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)

DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000


	-- ********************   ARRUMAR SITUAÇÕES PARA outras bios    -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS  QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA  (status '4')
	DECLARE cur_troubleIns1 CURSOR FOR 
		(SELECT distinct ICARD from DIG004 
			WHERE STATUS = '4'
		)
	OPEN cur_troubleIns1
	FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE cur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from DIG004 
				WHERE (ICARD = @z_mat and STATUS = '4')
			)
		OPEN cur_troubleIns2
		FETCH NEXT FROM cur_troubleIns2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			DELETE DIG004 WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '4')

			UPDATE DIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM cur_troubleIns2 INTO @z_endip
		END


		CLOSE cur_troubleIns2
		deallocate cur_troubleIns2

		FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	END
	
	CLOSE cur_troubleIns1
	deallocate cur_troubleIns1

	

	-- ***********************  TRATA AS BIOMETRIAS  QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS bios (DA TAB.CONTDIG_OUTROS CADASTRO)
	-- delete registro de DIG004 se nao houver cadastro de BIO  desta matricula
	DECLARE cur_autoIns1 CURSOR FOR 
		(SELECT distinct ICARD, BIO_TIPO from DIG004 
			WHERE STATUS = '3'
		)
	OPEN cur_autoIns1
	FETCH NEXT FROM cur_autoIns1 INTO @z_mat, @z_biotipo
	WHILE (@@fetch_status != -1) BEGIN
		
		-- VERIFICA SE HÁ CADASTRO DO BIO  DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_OUTROS 
			WHERE ICARD = @z_mat AND BIO_TIPO = @z_biotipo
			
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO  desta matricula
			DECLARE cur_autoIns2 CURSOR FOR 
				(SELECT END_IP from DIG004 
					WHERE (ICARD = @z_mat 	and 
						   STATUS = '3' 	and 
						   BIO_TIPO = @z_biotipo)
				)
			OPEN cur_autoIns2
			FETCH NEXT FROM cur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				DELETE DIG004 WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '3')

				UPDATE DIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM cur_autoIns2 INTO @z_endip
			END


			CLOSE cur_autoIns2
			deallocate cur_autoIns2
		END

		FETCH NEXT FROM cur_autoIns1 INTO @z_mat, @z_biotipo
	END
	
	CLOSE cur_autoIns1
	deallocate cur_autoIns1

	-- ***********************  TRATA AS BIOMETRIAS  QUE FICARAM PENDENTES NA INCLUSAO
	-- altera status de todos os codins para carga de digitais, se esses não estiverem com carga de digitais ou estiverem pendentes

	DECLARE cur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from DIG004 
			WHERE (STATUS != '0' and STATUS != '2') 
		)
	OPEN cur_endip
	FETCH NEXT FROM cur_endip INTO @z_endip, @z_biotipo, @z_status
	
	while @@fetch_status != -1
	begin
		UPDATE DIG002 set status = '1'
			WHERE (END_IP = @z_endip and 
					(STATUS = '0' or STATUS= '3') and 
					BIO_TIPO = @z_biotipo)
		FETCH NEXT FROM cur_endip INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE cur_endip
	deallocate cur_endip



	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos  q tiveram carga de aplicativo 
	DECLARE cur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from DIG002 
			WHERE ((status = '5' or status = '6' or 		-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())) 
				   and 
				   ((BIO_TIPO = '8') and (BIO_TIPO != '6') and (BIO_TIPO != '7')) 
				  )
		)
	OPEN cur_dig02
	FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_biotipo, @z_status

	WHILE @@fetch_status != -1
	begin
		-- OBSERVACAO: PARA BIOMETRIA , A CARGA DE APLICATIVO NO EQUIPAMENTO NAO APAGA AS BIOMETRIAS, POIS BIOMETRIA  FICA NO LEITOR E NAO NO EQUIPAMENTO,
		-- LOGO NAO É NECESSARIO FAZER A RECARGA DE BIOMETRIA
		IF (@z_status = '2') begin		-- situação q estava fazendo a carga e deu problema

			UPDATE DIG004 set STATUS = '1'			-- status = 1 : a carregar
				WHERE (END_IP = @z_endip and STATUS = '2'  and BIO_TIPO = @z_biotipo) 

			UPDATE DIG002 set status = '1' 
				where (END_IP = @z_endip and BIO_TIPO = @z_biotipo)
		end

		ELSE begin
			IF (@z_status = '5' or @z_status = '6') begin		-- HOUVE CARGA DE APLICATIVO, MAS NAO VAI RECARREGAR AS BIOMETRIAS
				UPDATE DIG002 set status = '0' 
					WHERE (end_ip = @z_endip  and BIO_TIPO = @z_biotipo)
			end
		end
		
		FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end

	CLOSE cur_dig02
	DEALLOCATE cur_dig02
	


	-- ***********************  TRATA AS BIOMETRIAS QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUAÇÃO
	-- para BIOMETRIAS   DE DIG004 que ficaram em estado carregando '2', e o equipamento está em estado de repouso	, forca o equipamento a carrega-lo novamente

	DECLARE cur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.STATUS, A.BIO_TIPO from DIG002 A 
			INNER JOIN DIG004 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = B.BIO_TIPO)
	OPEN cur_dig02
	FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_status, @z_biotipo 

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG004 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' AND BIO_TIPO = @z_biotipo;
		UPDATE DIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip  and BIO_TIPO = @z_biotipo;
			
		FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_status, @z_biotipo;
	END
	CLOSE cur_dig02
	deallocate cur_dig02
	


	-- ********************   ARRUMAR SITUAÇÕES PARA   outras bios   -  EXCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS  QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins Sagem para exclusao de biometria, se esses não estiverem com exclusao de biometria ou estiverem pendentes

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO from DIG104 
			--WHERE (STATUS != '0' and STATUS != '2' and BIO_TIPO = '8')
			WHERE (STATUS != '0' and STATUS != '2' and STATUS != '4')		-- statys 4 indica resposta do rep de nao implementado
		)
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG102 set STATUS = '1'
			WHERE (END_IP = @z_endip) and 
			  	  --(STATUS = '0' or STATUS = '3') and 
			  	  (STATUS = '0' or STATUS = '3' or STATUS = '4') and 		-- statys 4 indica resposta do rep de nao implementado
				  (BIO_TIPO = @z_biotipo)

		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE cur_autoExc1
	deallocate cur_autoExc1
	


	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from DIG102 
			WHERE (((BIO_TIPO != '6') and (BIO_TIPO != '7') and (BIO_TIPO != '8')) 
					and
					(status = '5' or status = '6' or 													-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip,  @z_biotipo, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE DIG104 set status = '1'
				WHERE (END_IP = @z_endip) and (status = '2') and (BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')

			UPDATE DIG102 set status = '1' 
				WHERE (END_IP = @z_endip  and BIO_TIPO = @z_biotipo)
		end
				
		else if (@z_status = '5'  or @z_status = '6') begin
			UPDATE DIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;
				
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE cur_autoExc1
	deallocate cur_autoExc1



	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUAÇÃO
	-- para digitais de DIG104 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.STATUS, A.BIO_TIPO from DIG102 A 
			INNER JOIN DIG104 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = B.BIO_TIPO)
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG104 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and BIO_TIPO = @z_biotipo;
		UPDATE DIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip and BIO_TIPO = @z_biotipo;
	
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status, @z_biotipo;
	END
	CLOSE cur_autoExc1
	deallocate cur_autoExc1

	SET LOCK_TIMEOUT -1
	
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('G3G5_P_GERDIGITAL2'))
	DROP PROCEDURE TELESSVR.G3G5_P_GERDIGITAL2;
GO

CREATE PROCEDURE TELESSVR.G3G5_P_GERDIGITAL2 AS

DECLARE @ret CHAR(1)


	SET DATEFORMAT YMD


	set @ret = 0
	
	exec TELESSVR.G3G5_PREP_SAGEM	-- prepara automatico digitais sagem
	
	exec TELESSVR.G3G5_PREP_TSI1	-- prepara automatico digitais tsi1

	exec TELESSVR.G3G5_prep_Palmv	-- prepara PALMV014/PALMV004 (INCLUSAO)  e PALMV015/PALMV005 (EXCLUSAO)

	-- fazer
	--exec TELESSVR.prep_OutrosBios	-- prepara automatico Outras biometrias


	exec TELESSVR.trata3_sagem		-- trata biometria sagem

	exec TELESSVR.trata3_tsi1		-- trata biometria tsi1
	
	exec TELESSVR.trata_palmv		-- trata PALMVEIN

	-- fazer
	--exec TELESSVR.trata_OutrosBios		-- trata Outras Biometrias
	
	select @ret
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlhist_bio'))
	DROP PROCEDURE TELESSVR.sqlhist_bio;
GO

CREATE PROCEDURE TELESSVR.sqlhist_bio @LMat1 CHAR(255), @LMat2 CHAR(255), @LMat3 CHAR(255), @LMat4 CHAR(255), @cEndIp CHAR(15), @cInsDel CHAR(1), @cModo CHAR(1), @cBioTipo CHAR(1)
AS

DECLARE @Ret smallint , @Tam smallint, @Pos smallint, @cAcao CHAR(1), @cBio CHAR(1)


	SET @cBio = null
	SET @cBio = (SELECT BIO_TIPO FROM DAT07 WHERE END_IP = @cEndIp)
	IF (@cBio is null) BEGIN
		SET @cBio = ' ';
	END
	

	SET @Ret = 0
	
	IF (@cInsDel = '3')
		SET @cAcao = 'I'
	ELSE
		SET @cAcao = 'E'

	
	-- analise de LMat1
	SET @Tam = LEN (@LMat1) ;
	IF (@Tam > 0)
	BEGIN
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin
			INSERT INTO HISTDIG (IFUNC, END_IP, BIO_TIPO, INSEXC, MODO) 
				VALUES (SUBSTRING (@LMat1, @Pos, 12) , @cEndIp,  @cBio, @cAcao, @cModo);
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat2
	SET @Tam = LEN (@LMat2) ;
	IF (@Tam > 0)
	BEGIN
		SET @Pos = 0;
		WHILE (@Pos < @Tam) begin
			INSERT INTO HISTDIG (IFUNC, END_IP, BIO_TIPO, INSEXC, MODO) 
				VALUES (SUBSTRING (@LMat2, @Pos, 12) , @cEndIp,  @cBio, @cAcao, @cModo);
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat3
	SET @Tam = LEN (@LMat3) ;
	IF (@Tam > 0)
	BEGIN
		SET @Pos = 0;
		WHILE (@Pos < @Tam) begin
			INSERT INTO HISTDIG (IFUNC, END_IP, BIO_TIPO, INSEXC, MODO) 
				VALUES (SUBSTRING (@LMat3, @Pos, 12) , @cEndIp,  @cBio, @cAcao, @cModo);
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat4
	SET @Tam = LEN (@LMat4) ;
	IF (@Tam > 0)
	BEGIN
		SET @Pos = 0;
		WHILE (@Pos < @Tam) begin
			INSERT INTO HISTDIG (IFUNC, END_IP, BIO_TIPO, INSEXC, MODO) 
				VALUES (SUBSTRING (@LMat4, @Pos, 12) , @cEndIp,  @cBio, @cAcao, @cModo);
			SET @Pos = @Pos + 12;
		end
	END;


	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('trgmatcodD'))
	DROP TRIGGER TELESSVR.trgmatcodD;
GO

CREATE TRIGGER TELESSVR.trgmatcodD ON TELESSVR.MATCODIN FOR DELETE
AS

declare @cBio VARCHAR(1)
declare @cEndIp VARCHAR(15)
declare @cMat VARCHAR(12)
declare @cContSag tinyint;
declare @cContSup tinyint;
declare @cContPalmv tinyint;
declare @cContOutrosBios tinyint;

/* ESTE BLOCO A SEGUIR QUE ESTA EM COMENTARIO DEVE ESTAR ERRADO
	set @cContSag = 0;
	set @cContSup = 0;
	set @cContPalmv = 0;
	set @cContOutrosBios = 0;
	
	DECLARE cur_delmat CURSOR FOR (select ICARD, END_IP from DELETED)
	OPEN cur_delmat
	FETCH NEXT FROM cur_delmat INTO @cMat , @cEndIp
          
	WHILE @@fetch_status != -1
	BEGIN          
		SET @cBio = null
		SET @cBio = 
			(SELECT BIO_TIPO from DAT07 where END_IP = @cEndIp)

		if (@@ROWCOUNT != 0) begin
			if (@cBio = '6') or (@cBio = '7') begin 	-- biometria sagem
				set @cContSag = 1;
			end
			ELSE			
				if (@cBio = '8') begin 	-- biometria tsi1 suprema
					set @cContSup = 1;
				end
				ELSE
					if (@cBio = 'A') begin 	-- PALMVEIN
						set @cContPalmv = 1;
					end
					ELSE
						if (@cBio != '0') AND (@cBio != NULL) begin 	-- VIRDI E OUTRAS BIOS
							set @cContOutrosBios = 1;
						end
					
		end
		
		FETCH NEXT FROM cur_delmat INTO @cMat , @cEndIp
	END
	CLOSE cur_delmat		
	
	if @cContSag = 1 
		update CONTDIG_SAGEM set STATUS = '3' where ICARD = @cMat
		
	if @cContSup = 1 
		update CONTDIG_TSI1 set STATUS = '3' where ICARD = @cMat

	if @cContPalmv = 1 
		update PALMV001 set ST = '3' where ICARD = @cMat
		
	if @cContOutrosBios = 1 
		update CONTDIG_OUTROS set STATUS = '3' where ICARD = @cMat  and BIO_TIPO = @cBio
		
*/


	
	DECLARE cur_delmat CURSOR FOR (select ICARD, END_IP from DELETED)
	OPEN cur_delmat
	FETCH NEXT FROM cur_delmat INTO @cMat , @cEndIp
          
	WHILE @@fetch_status != -1
	BEGIN          
		set @cContSag = 0;
		set @cContSup = 0;
		set @cContPalmv = 0;
		set @cContOutrosBios = 0;

		SET @cBio = null
		SET @cBio = 
			(SELECT BIO_TIPO from DAT07 where END_IP = @cEndIp)

		if (@@ROWCOUNT != 0) begin
			if (@cBio = '6') or (@cBio = '7') begin 	-- biometria sagem
				set @cContSag = 1;
			end
			ELSE			
				if (@cBio = '8') begin 	-- biometria tsi1 suprema
					set @cContSup = 1;
				end
				ELSE
					if (@cBio = 'A') begin 	-- PALMVEIN
						set @cContPalmv = 1;
					end
					ELSE
						if (@cBio != '0') AND (@cBio != NULL) begin 	-- VIRDI E OUTRAS BIOS
							set @cContOutrosBios = 1;
						end
					
		end

		if @cContSag = 1 
			update CONTDIG_SAGEM set STATUS = '3' where ICARD = @cMat

		if @cContSup = 1 
			update CONTDIG_TSI1 set STATUS = '3' where ICARD = @cMat

		if @cContPalmv = 1 
			update PALMV001 set ST = '3' where ICARD = @cMat

		if @cContOutrosBios = 1 
			update CONTDIG_OUTROS set STATUS = '3' where ICARD = @cMat and BIO_TIPO = @cBio

	
		FETCH NEXT FROM cur_delmat INTO @cMat , @cEndIp
	END
	CLOSE cur_delmat	
	
GO	
	
IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('trgmatcodI'))
	DROP TRIGGER TELESSVR.trgmatcodI;
GO

CREATE TRIGGER TELESSVR.trgmatcodI ON TELESSVR.MATCODIN FOR INSERT
AS

declare @cBio VARCHAR(1)
declare @cSt VARCHAR(1)
declare @cEndIp VARCHAR(15)
declare @cMat VARCHAR(12)
declare @cSitua VARCHAR(1)
declare @cStNovo VARCHAR(1)


	DECLARE cur_delmat CURSOR FOR (select ICARD, END_IP from INSERTED)
	OPEN cur_delmat
	FETCH NEXT FROM cur_delmat INTO @cMat , @cEndIp
          
	WHILE @@fetch_status != -1
	BEGIN          
		SET @cStNovo = '3'
		SELECT @cSitua = SITUA FROM CONTROLE WHERE ICARD = @cMat
		IF (@@ROWCOUNT != 0)
			IF (@cSitua = '1') 
				SET @cStNovo = '8'

		SET @cBio = null
		
		SET @cBio = (SELECT BIO_TIPO from DAT07 where END_IP = @cEndIp)
		IF (@@ROWCOUNT != 0) begin
			if (@cBio = '6') or (@cBio = '7') begin 	-- biometria sagem
				update CONTDIG_SAGEM set STATUS = @cStNovo where ICARD = @cMat
			end
			ELSE 
				if (@cBio = '8') begin 	-- biometria tsi1 suprema
					update CONTDIG_TSI1 set STATUS = @cStNovo where ICARD = @cMat
				end
				ELSE
					if (@cBio = 'A') begin 	-- PALMVEIN
						update PALMV001 set ST = @cStNovo where ICARD = @cMat
					end
					ELSE
						if (@cBio != '0') begin 	-- biometria VIRDI E OUTRAS
							update CONTDIG_OUTROS set STATUS = @cStNovo where ICARD = @cMat and BIO_TIPO = @cBio
						end
		END			
		FETCH NEXT FROM cur_delmat INTO @cMat , @cEndIp
	END
	CLOSE cur_delmat		

go	

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('trgmatcodU'))
	DROP TRIGGER TELESSVR.trgmatcodU;
GO

CREATE TRIGGER TELESSVR.trgmatcodU ON TELESSVR.MATCODIN FOR UPDATE
AS

declare @cBio VARCHAR(1)
declare @cSt VARCHAR(1)
declare @cEndIp VARCHAR(15)
declare @cMat VARCHAR(12)


	IF UPDATE (ICARD) OR UPDATE(END_IP) 
	BEGIN

		DECLARE cur_delmat CURSOR FOR (select ICARD, END_IP from INSERTED)
		OPEN cur_delmat
		FETCH NEXT FROM cur_delmat INTO @cMat , @cEndIp

		WHILE @@fetch_status != -1
		BEGIN          
			select @cBio = BIO_TIPO from DAT07 where END_IP = @cEndIp
			if (@@ROWCOUNT != 0) begin
				if (@cBio = '6') or (@cBio = '7') begin 	-- biometria sagem
					update CONTDIG_SAGEM set STATUS = '3' where ICARD = @cMat
				end
				ELSE
					if (@cBio = '8') begin 	-- biometria tsi1 suprema
						update CONTDIG_TSI1 set STATUS = '3' where ICARD = @cMat
					end
					ELSE
						if (@cBio = 'A') begin 	-- PALMVEIN
							update PALMV001 set ST = '3' where ICARD = @cMat
						end
						ELSE
							if (@cBio != '0') and (@cBio != NULL) begin 	-- biometria VIRDI E OUTRAS
								update CONTDIG_OUTROS set STATUS = '3' where ICARD = @cMat and BIO_TIPO = @cBio
							end
						
			end			
			FETCH NEXT FROM cur_delmat INTO @cMat , @cEndIp
		END
		CLOSE cur_delmat		
	END

go	

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('TrgSitCont_D'))
	DROP TRIGGER TELESSVR.TrgSitCont_D;
GO

CREATE TRIGGER TELESSVR.TrgSitCont_D ON TELESSVR.CONTROLE AFTER DELETE
AS
DECLARE @ICARD VARCHAR(12)

DECLARE CURSOR_DEL CURSOR FOR SELECT ICARD FROM DELETED  ORDER BY ICARD
				
	OPEN CURSOR_DEL
	FETCH NEXT FROM CURSOR_DEL into @ICARD

	WHILE @@FETCH_STATUS = 0	
	BEGIN
		UPDATE CONTDIG_SAGEM 	SET STATUS = '8' WHERE ICARD = @ICARD;
		UPDATE CONTDIG_TSI1  	SET STATUS = '8' WHERE ICARD = @ICARD;
		UPDATE PALMV001      	SET ST = '8'     WHERE ICARD = @ICARD;
		UPDATE CONTDIG_OUTROS  	SET STATUS = '8' WHERE ICARD = @ICARD;
		
		FETCH NEXT FROM CURSOR_DEL into @ICARD
	END

	CLOSE CURSOR_DEL
	DEALLOCATE CURSOR_DEL
GO	

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('TrgSitCont_I'))
	DROP TRIGGER TELESSVR.TrgSitCont_I;
GO

CREATE TRIGGER TELESSVR.TrgSitCont_I ON TELESSVR.CONTROLE AFTER INSERT
AS
DECLARE @ICARD VARCHAR(12)
DECLARE @SITUA VARCHAR(1)
DECLARE @VER_DIGIT VARCHAR(1)

DECLARE CURSOR_INS CURSOR FOR SELECT ICARD, SITUA, VER_DIGIT FROM INSERTED  ORDER BY ICARD
				
	OPEN CURSOR_INS
	FETCH NEXT FROM CURSOR_INS into @ICARD,@SITUA, @VER_DIGIT

	WHILE @@FETCH_STATUS = 0	
	BEGIN
		IF (@SITUA = '1') OR (@VER_DIGIT = '1') BEGIN		-- SITUACAO INVALIDO, COMO SE FOSSE DEMITIDO  OU   NAO CONFERE DIGITAL
			UPDATE CONTDIG_SAGEM 	SET STATUS = '8' WHERE ICARD = @ICARD;
			UPDATE CONTDIG_TSI1  	SET STATUS = '8' WHERE ICARD = @ICARD;
			UPDATE PALMV001      	SET ST = '8'     WHERE ICARD = @ICARD;
			UPDATE CONTDIG_OUTROS  	SET STATUS = '8' WHERE ICARD = @ICARD;
		END
		ELSE  
			IF (@SITUA = '0' OR @SITUA = '7' OR @VER_DIGIT = '2')  
			BEGIN -- para todos outros valores de SITUA, carrega o palmvein somente nos equipamentos do grupo
				UPDATE CONTDIG_SAGEM 	SET STATUS = '3' WHERE ICARD = @ICARD;
				UPDATE CONTDIG_TSI1  	SET STATUS = '3' WHERE ICARD = @ICARD;
				UPDATE PALMV001      	SET ST = '3'     WHERE ICARD = @ICARD;
				UPDATE CONTDIG_OUTROS  	SET STATUS = '3' WHERE ICARD = @ICARD;
			END
			
		FeTCH NEXT FROM CURSOR_INS into @ICARD, @SITUA, @VER_DIGIT
	END

	CLOSE CURSOR_INS
	DEALLOCATE CURSOR_INS
GO	

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('TrgSitCont_U'))
	DROP TRIGGER TELESSVR.TrgSitCont_U;
GO

CREATE TRIGGER TELESSVR.TrgSitCont_U ON TELESSVR.CONTROLE AFTER UPDATE
AS
DECLARE @ICARD VARCHAR(12)

DECLARE @GRUPO VARCHAR(9), @GRUPO_OLD VARCHAR(9)
DECLARE @GRUPO1 VARCHAR(9), @GRUPO1_OLD VARCHAR(9)
DECLARE @GRUPO2 VARCHAR(9), @GRUPO2_OLD VARCHAR(9)
DECLARE @GRUPO3 VARCHAR(9), @GRUPO3_OLD VARCHAR(9)
DECLARE @GRUPO_SAB VARCHAR(9), @GRUPO_SAB_OLD VARCHAR(9)
DECLARE @GRUPO_DOM VARCHAR(9), @GRUPO_DOM_OLD VARCHAR(9)
DECLARE @GRUPO_FER VARCHAR(9), @GRUPO_FER_OLD VARCHAR(9)
DECLARE @SITUA VARCHAR(1), @SITUA_OLD VARCHAR(1)
DECLARE @VER_DIGIT VARCHAR(1), @VER_DIGIT_OLD VARCHAR(1)

DECLARE CURSOR_UPDT CURSOR FOR
			SELECT ICARD, SITUA, VER_DIGIT, GRUPO, GRUPO1, GRUPO2, GRUPO2, GRUPO_SAB, GRUPO_DOM, GRUPO_FER  
				FROM INSERTED  
				ORDER BY ICARD


				
	IF UPDATE (grupo) OR UPDATE(grupo1) OR UPDATE (grupo2) OR UPDATE(grupo3) OR 
		UPDATE (grupo_sab) OR UPDATE(grupo_dom) OR UPDATE (grupo_fer) OR 
		UPDATE(situa) OR
		UPDATE(ver_digit)

	BEGIN
		OPEN CURSOR_UPDT
		FETCH NEXT FROM CURSOR_UPDT into @ICARD,@SITUA, @VER_DIGIT, @GRUPO, @GRUPO1, @GRUPO2, @GRUPO3, @GRUPO_SAB, @GRUPO_DOM, @GRUPO_FER

		WHILE @@FETCH_STATUS = 0	
		BEGIN

			SET @GRUPO_OLD = (select GRUPO from DELETED where ICARD = @ICARD)
			SET @GRUPO1_OLD = (select GRUPO1 from DELETED where ICARD = @ICARD)
			SET @GRUPO2_OLD = (select GRUPO2 from DELETED where ICARD = @ICARD) 
			SET @GRUPO3_OLD = (select GRUPO3 from DELETED where ICARD = @ICARD) 
			SET @GRUPO_SAB_OLD = (select GRUPO_SAB from DELETED where ICARD = @ICARD)
			SET @GRUPO_DOM_OLD = (select GRUPO_DOM from DELETED where ICARD = @ICARD)
			SET @GRUPO_FER_OLD = (select GRUPO_FER from DELETED where ICARD = @ICARD)
			SET @SITUA_OLD = (select SITUA  from DELETED where ICARD = @ICARD)
			SET @VER_DIGIT_OLD = (select VER_DIGIT  from DELETED where ICARD = @ICARD)

			IF (@SITUA_OLD != @SITUA) OR (@VER_DIGIT_OLD != @VER_DIGIT) BEGIN
				IF (@SITUA = '1') OR (@VER_DIGIT = '1') BEGIN		-- para SITUA '1' INVALIDO  OU VER_DIGIT '1', leva ST '8' para excluir o TEMPLATE de todos os equipamentos
					UPDATE CONTDIG_SAGEM 	SET STATUS = '8' WHERE ICARD = @ICARD;
					UPDATE CONTDIG_TSI1  	SET STATUS = '8' WHERE ICARD = @ICARD;
					UPDATE PALMV001      	SET ST = '8'     WHERE ICARD = @ICARD;
					UPDATE CONTDIG_OUTROS  	SET STATUS = '8' WHERE ICARD = @ICARD;
				END

				ELSE BEGIN
					--IF (@SITUA = '0' OR @SITUA = '7') BEGIN		-- SITUA '0'E '7' VALIDOS
					IF (@SITUA = '0' OR @SITUA = '4' OR @SITUA = '7') AND (@VER_DIGIT = '2')  AND (@SITUA_OLD <> '8') BEGIN		-- SITUA '0'E '7' VALIDOS, '4' = PROVISÓRIO (NO CASO DE MULTITECNOLOGIA)
						UPDATE CONTDIG_SAGEM 	SET STATUS = '3' WHERE ICARD = @ICARD;
						UPDATE CONTDIG_TSI1  	SET STATUS = '3' WHERE ICARD = @ICARD;
						UPDATE PALMV001      	SET ST = '3'     WHERE ICARD = @ICARD;
						UPDATE CONTDIG_OUTROS  	SET STATUS = '3' WHERE ICARD = @ICARD;
					END
					
				END
			END

			ELSE BEGIN	-- houve alteracao no grupo, mesmo que o grupo continue o mesmo
				IF ((CONVERT(INT,@GRUPO_OLD) != CONVERT(INT,@GRUPO)) OR 
					(CONVERT(INT,@GRUPO1_OLD) != CONVERT(INT, @GRUPO1)) OR 
					(CONVERT(INT,@GRUPO2_OLD) != CONVERT(INT,@GRUPO2)) OR 
					(CONVERT(INT,@GRUPO3_OLD) != CONVERT(INT,@GRUPO3)) OR 
					(CONVERT(INT,@GRUPO_SAB_OLD) != CONVERT(INT,@GRUPO_SAB)) OR 
					(CONVERT(INT,@GRUPO_DOM_OLD) != CONVERT(INT,@GRUPO_DOM)) OR 
					(CONVERT(INT,@GRUPO_FER_OLD) != CONVERT(INT,@GRUPO_FER)) ) BEGIN
			
					UPDATE CONTDIG_SAGEM 	SET STATUS = '3' WHERE ICARD = @ICARD AND STATUS != '8';
					UPDATE CONTDIG_TSI1  	SET STATUS = '3' WHERE ICARD = @ICARD AND STATUS != '8';
					UPDATE PALMV001      	SET ST = '3'     WHERE ICARD = @ICARD AND ST != '8';
					UPDATE CONTDIG_OUTROS  	SET STATUS = '3' WHERE ICARD = @ICARD AND STATUS != '8';
				end;
			END
			
			FETCH NEXT FROM CURSOR_UPDT into @ICARD,@SITUA, @VER_DIGIT, @GRUPO, @GRUPO1, @GRUPO2, @GRUPO3, @GRUPO_SAB, @GRUPO_DOM, @GRUPO_FER
		END
		CLOSE CURSOR_UPDT
	END
	DEALLOCATE CURSOR_UPDT
	
GO	

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('TrgMatNGrupo_D'))
	DROP TRIGGER TELESSVR.TrgMatNGrupo_D;
GO

CREATE TRIGGER TELESSVR.TrgMatNGrupo_D ON TELESSVR.MATNGRUPOS AFTER DELETE
AS
DECLARE @ICARD VARCHAR(12)

DECLARE @GRUPO INT, @GRUPO_OLD INT

DECLARE @Qtde INT, @QtdeGr int


DECLARE CURSOR_DEL CURSOR FOR
			SELECT ICARD, CONVERT(INT,GRUPO)
				FROM DELETED  
				ORDER BY ICARD

				
		OPEN CURSOR_DEL
		FETCH NEXT FROM CURSOR_DEL into @ICARD, @GRUPO

		WHILE @@FETCH_STATUS = 0	
		BEGIN

			SET @Qtde = (SELECT COUNT (*) FROM MATNGRUPOS WHERE ICARD = @ICARD)
			
			IF (@Qtde = 0) begin
				UPDATE CONTDIG_SAGEM 	SET STATUS = '3' WHERE ICARD = @ICARD;
				UPDATE CONTDIG_TSI1  	SET STATUS = '3' WHERE ICARD = @ICARD;
				UPDATE PALMV001      	SET ST = '3'     WHERE ICARD = @ICARD;
				UPDATE CONTDIG_OUTROS	SET STATUS = '3' WHERE ICARD = @ICARD;
			end
			-- matricula ja existia, mas vai verificar se o grupo novo já existia também
			ELSE begin
				-- verifica se o grupo novo ja existia. Se existia, nada Faz. Se năo existia, atualiza status da biometria da matricula como '3'
				SET @QtdeGr = (SELECT COUNT (*) FROM MATNGRUPOS WHERE ICARD = @ICARD AND CONVERT(INT,GRUPO) = @GRUPO)
				IF (@QtdeGr = 0) begin
					UPDATE CONTDIG_SAGEM 	SET STATUS = '3' WHERE ICARD = @ICARD;
					UPDATE CONTDIG_TSI1  	SET STATUS = '3' WHERE ICARD = @ICARD;
					UPDATE PALMV001      	SET ST = '3'     WHERE ICARD = @ICARD;
					UPDATE CONTDIG_OUTROS	SET STATUS = '3' WHERE ICARD = @ICARD;
				end
			end
			FETCH NEXT FROM CURSOR_DEL into @ICARD, @GRUPO
		END
		CLOSE CURSOR_DEL
		DEALLOCATE CURSOR_DEL
GO	

IF EXISTS (SELECT name FROM sysobjects WHERE name = 'TrgMatNGrupo_U' AND type = 'TR')
    DROP TRIGGER TELESSVR.TrgMatNGrupo_U
GO

CREATE TRIGGER TELESSVR.TrgMatNGrupo_U ON TELESSVR.MATNGRUPOS AFTER UPDATE
AS
DECLARE @ICARD VARCHAR(12)

DECLARE @GRUPO INT, @GRUPO_OLD INT


DECLARE @QtdeOld INT, @QtdeNew INT 

DECLARE CURSOR_UPDT CURSOR FOR
			SELECT ICARD, CONVERT(INT,GRUPO)
				FROM INSERTED 
			ORDER BY ICARD, GRUPO


	-- alteracao de GRUPO		
	IF UPDATE (grupo) 
	BEGIN
		OPEN CURSOR_UPDT
		FETCH NEXT FROM CURSOR_UPDT into @ICARD, @GRUPO

		WHILE @@FETCH_STATUS = 0	
		BEGIN

			-- se apos a modificação, o grupo ANTIGO ainda existe na tabela para esta matricula, entao nao irá excluir deste grupo, mas irá verificar o NOVO Grupo para verificar se insere neste novo grupo. 
				-- Se NOVO grupo já existir na table, nada faz 
				-- Se NOVO grupo NÃO existir na table, entao STATUS das biometrias ficara '3' para esta matricula ( nao será '8', pois nao se quer excluir de nenhum grupo)
					
			-- se apos a modificação, o grupo ANTIGO NÃO existe na tabela, NÃO importa se o NOVO Grupo existe ou nao, será alterado com status '3', para exclusao e carga
				
			SET @GRUPO_OLD = (select CONVERT(INT,GRUPO) from DELETED where ICARD = @ICARD)
			SET @QtdeOld = (SELECT COUNT (*) FROM MATNGRUPOS WHERE (ICARD = @ICARD) AND (CONVERT(INT,GRUPO) = @GRUPO_OLD))
			IF (@QtdeOld > 0) begin
				SET @QtdeNew = (SELECT COUNT (*) FROM MATNGRUPOS WHERE (ICARD = @ICARD) AND (CONVERT(INT,GRUPO) = @GRUPO))
				IF (@QtdeNew = 1) begin
					UPDATE CONTDIG_SAGEM 	SET STATUS = '3' WHERE ICARD = @ICARD AND STATUS != '3';
					UPDATE CONTDIG_TSI1  	SET STATUS = '3' WHERE ICARD = @ICARD AND STATUS != '3';
					UPDATE PALMV001      	SET ST = '3'     WHERE ICARD = @ICARD AND ST != '3';
					UPDATE CONTDIG_OUTROS  	SET STATUS = '3' WHERE ICARD = @ICARD AND STATUS != '3';
				end
				-- ELSE NADA FAZ
			end
			ELSE begin
				-- vai excluir incluir
				UPDATE CONTDIG_SAGEM 	SET STATUS = '3' WHERE ICARD = @ICARD AND STATUS != '3';		
				UPDATE CONTDIG_TSI1  	SET STATUS = '3' WHERE ICARD = @ICARD AND STATUS != '3';
				UPDATE PALMV001      	SET ST = '3'     WHERE ICARD = @ICARD AND ST != '3';
				UPDATE CONTDIG_OUTROS  	SET STATUS = '3' WHERE ICARD = @ICARD AND STATUS != '3';
			end

			FETCH NEXT FROM CURSOR_UPDT into @ICARD, @GRUPO
		END
		CLOSE CURSOR_UPDT
	END
	DEALLOCATE CURSOR_UPDT
	
GO	

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('TrgMatNGrupo_I'))
	DROP TRIGGER TELESSVR.TrgMatNGrupo_I;
GO

CREATE TRIGGER TrgMatNGrupo_I ON TELESSVR.MATNGRUPOS AFTER INSERT
AS
DECLARE @ICARD VARCHAR(12)

--DECLARE @GRUPO VARCHAR(9), @GRUPO_OLD VARCHAR(9)
DECLARE @GRUPO INT, @GRUPO_OLD INT

DECLARE @Qtde INT, @QtdeGr int


DECLARE CURSOR_INS CURSOR FOR
			SELECT ICARD, CONVERT(INT, GRUPO)
				FROM INSERTED  
				ORDER BY ICARD

				
		OPEN CURSOR_INS
		FETCH NEXT FROM CURSOR_INS into @ICARD, @GRUPO

		WHILE @@FETCH_STATUS = 0	
		BEGIN
			-- verifica se o grupo novo ja existia. Se existia, nada Faz. Se não existia, atualiza status da biometria da matricula como '3'
			SET @QtdeGr = (SELECT COUNT (*) FROM MATNGRUPOS WHERE ICARD = @ICARD AND CONVERT(INT,GRUPO) = @GRUPO)
			IF (@QtdeGr = 1) begin
				UPDATE CONTDIG_SAGEM 	SET STATUS = '3' WHERE ICARD = @ICARD;
				UPDATE CONTDIG_TSI1  	SET STATUS = '3' WHERE ICARD = @ICARD;
				UPDATE PALMV001      	SET ST = '3'     WHERE ICARD = @ICARD;
				UPDATE CONTDIG_OUTROS  	SET STATUS = '3' WHERE ICARD = @ICARD;
			end
			FETCH NEXT FROM CURSOR_INS into @ICARD, @GRUPO
		END
		CLOSE CURSOR_INS
		DEALLOCATE CURSOR_INS
	
GO	

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlAtuVagas_Estac'))
	DROP PROCEDURE TELESSVR.sqlAtuVagas_Estac;
GO

CREATE PROCEDURE TELESSVR.sqlAtuVagas_Estac @cMatric char(12), @cGrEstac char(3), @cTipoVaga char(1), @nModoAlt INT
AS
DECLARE @Ret int, @nMaxFix int, @nMaxRot int, @nOcupFix int, @nOcupRot int, @nOcupados int, @nMaxVagas int
DECLARE @grAux VARCHAR(5), @cFlag char(1);

	SET @Ret = 1;
	
	
	SELECT @grAux = GREST 
		FROM ESTAC003 
		WHERE ICARD = @cMatric and GREST = @cGrEstac;

	IF (@@ROWCOUNT <> 0) begin 
		
		-- verifica se tipo de vaga é Fixa e é Entrada		
		IF (@cTipoVaga = 'F') and (@nModoAlt > 0) 
			SET @cFlag = '1';								-- para informar que houve ocupacao da vaga fixa
		ELSE
			SET @cFlag = '0';								-- para informar que não houve ocupação da vaga fixa
		
			
		UPDATE ESTAC003 SET EMFIXA = @cFlag 
			WHERE ICARD = @cMatric and GREST = @cGrEstac;
		
	END
	
	
	-- Procura pelo Grupo de Estacionamento para atualizar quantidade de vagas
	SELECT @nMaxFix = MAX_FIXO, 
		   @nOcupFix = CONT_FIXO, 
		   @nMaxRot =  MAX_ROT, 
		   @nOcupRot = CONT_ROT 
		FROM ESTAC002 WHERE GREST = @cGrEstac;

	IF (@@ROWCOUNT <> 0) begin 
		IF (@cTipoVaga = 'F') begin
			SET @nOcupados = @nOcupFix;					
			SET @nMaxVagas = @nMaxFix;
		end
		ELSE begin
			SET @nOcupados = @nOcupRot;
			SET @nMaxVagas = @nMaxRot;
		end

		-- nOcupados será incrementado ou decrementado dependendo do valor de nModoAlt (que pode ser:-1, 0, 1)	
		SET @nOcupados = @nOcupados + @nModoAlt;

		-- nao deixa qtde vagas ocupadas ficar negativo
		if (@nOcupados < 0) 
			SET @nOcupados = 0;
		
		-- nao deixa qtde vagas ocupadas ficar maior que o permitido
		IF (@nOcupados > @nMaxVagas)
			SET @nOcupados = @nMaxVagas;
		
		-- atualiza contador
		IF (@nModoAlt != 0) begin
			IF (@cTipoVaga = 'F') 
				UPDATE ESTAC002 SET CONT_FIXO = @nOcupados WHERE GREST = @cGrEstac;
			ELSE
				UPDATE ESTAC002 SET CONT_ROT = @nOcupados WHERE GREST = @cGrEstac;
		end
	end
	ELSE
		SET @Ret = 0;

	
	select @Ret ;
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlconsG3G5_term_fer_tcp'))
	DROP PROCEDURE TELESSVR.sqlconsG3G5_term_fer_tcp;
GO

CREATE PROCEDURE TELESSVR.sqlconsG3G5_term_fer_tcp @cEndIp CHAR(15), @cData varchar(6) AS

DECLARE @cTipo AS CHAR(1), --@cLocal AS CHAR(3), 
		@cLocal AS CHAR(5), --@cPlanta AS CHAR(3), 
		@cPlanta AS CHAR(5), 
		@ctipobio AS CHAR(1), 
		@cRastr AS CHAR(1), @cBuf AS VARCHAR(50), @cIniHA AS CHAR(1), @cFimHA AS CHAR(1), 
		@cValidR AS CHAR(1), @cValidSMax AS CHAR(1), @cTolAntes AS CHAR(2), @cTolApos AS CHAR(2),
		@cLeitSm AS CHAR(1), @cPosVPlaca AS CHAR(1), @cPosMensBloq  AS CHAR(1), @cValDiasSuc AS CHAR(1),
		@cParidRep AS CHAR(1), @cQtdMult AS CHAR(2),
		@cLMinimo AS CHAR(4), @cLMaximo AS CHAR(4), @cQtdAtual AS CHAR(4)
		
/*
OBS: SE USAR VARCHAR PARA ESTAS VARIAVEIS, DEVERÁ USAR O RECURSO DE COALESCE(ADBUF) para compor o resultado em cBuf.
SE USAR CHAR(5) como esta sendo usado, o select mesmo com local e planta com 3 digitos armazenara 2espacos em branco no final da variavel CHAR, portanto 
nao será necessario utilizar COALESCE 
DECLARE @cLocal AS VARCHAR(5), 
		@cPlanta AS VARCHAR(5)
*/
		

DECLARE @ret int, @DataAux varchar(10), @Descr varchar(31) 
DECLARE @nTamG int, @cAdBuf char(2)  --@cAdBuf varchar(2)			-- novo


--	SET LOCK_TIMEOUT 1000
	SET @ret = 0
	SET @cBuf = ' '
	set @DataAux = substring (@cData,1,2)+ '-'+ substring (@cData, 3,2)+ '-'+ substring (@cData, 5,2)
	SET DATEFORMAT DMY

	SET @cLocal = NULL;
	SET @cPlanta = NULL;
	SET @nTamG = 3 

	SELECT	@nTamG  = COLUNAS.LENGTH
		FROM 
			SYSOBJECTS AS TABELAS,
			SYSCOLUMNS AS COLUNAS
		WHERE 
			-- JOINS 
			TABELAS.ID = COLUNAS.ID
			AND TABELAS.NAME = 'DAT07'
			AND COLUNAS.NAME = 'LACES'


	IF (@nTamG = 3) 
		SET @cAdBuf = SPACE(2);		-- 2 espços
	ELSE
		SET @cAdBuf = null;


	SELECT @cTipo = TIP_TERM,
	       @cLocal = LACES,
	       @ctipobio = BIO_TIPO,
	       @cPlanta = PLANTA,
	       @cRastr = RASTREADOR,
	       @cIniHA = POS_INIHALM,
	       @cFimHA = POS_FIMHALM,
	       @cValidR = VALID_RET,
	       @cValidSMax = VALID_SAIDAMAX,
	       @cTolAntes = TOLER_ANTES,
	       @cTolApos = TOLER_APOS,
	       @cLeitSm = TIP_LEIT,
	       @cPosVPlaca = POSVALPLACA, 
	       @cPosMensBloq = POSMENSBLOQ,
	       @cValDiasSuc = VALID_NDIAS,
	       @cParidRep = PARIDREP,
	       @cQtdMult = QTDMULT,
		   @cLMinimo = REPLICATE('0', 4 - LEN(CAST (LMINIMO as varCHAR(4)))) + RTrim(LTRIM(STR(LMINIMO,4))),		-- insere 0's à esquerda para string final tamanho 4
		   @cLMaximo = REPLICATE('0', 4 - LEN(CAST (LMAXIMO as varCHAR(4)))) + RTrim(LTRIM(STR(LMAXIMO,4))),			-- insere 0's à esquerda para string final tamanho 4
		   @cQtdAtual = REPLICATE('0', 4 - LEN(CAST (QTDATUAL as varCHAR(4)))) + RTrim(LTRIM(STR(QTDATUAL,4)))			-- insere 0's à esquerda para string final tamanho 4
		       
	FROM DAT07 (NOLOCK)
		  WHERE END_IP = @cEndIp and blueb = '00' and codin = '00'

	IF (@@ROWCOUNT <> 0)
	BEGIN
		if (@cTipo is Null) 
			SET @cTipo = '1'
		
		if (@cLocal is Null) begin
			if (@nTamG = 3)	
				SET @cLocal = '000';
			else
				SET @cLocal = '00000';
		end
		
		if (@ctipobio is Null) 
			SET @ctipobio = '0'

		if (@cPlanta is Null) BEGIN
			if (@nTamG = 3)	
				SET @cPlanta = '000'
			else
				SET @cPlanta = '00000'
		end
		
		if (@cRastr is Null) 
			SET @cRastr = '0'
		if (@cIniHA is Null) 
			SET @cIniHA = '0'
		if (@cFimHA is Null) 
			SET @cFimHA = '0'
		if (@cValidR is Null) 
			SET @cValidR = '0'
		if (@cValidSMax is Null) 
			SET @cValidSMax = '0'
		if (@cLeitSm is Null) 
			SET @cLeitSm = '0'
		if (@cTolAntes is Null) 
			SET @cTolAntes = '00'
		if (@cTolApos is Null) 
			SET @cTolApos = '00'
		if (@cPosVPlaca is Null) 
			SET @cPosVPlaca = '0'
		if (@cPosMensBloq is Null) 
			SET @cPosMensBloq = '0'
		if (@cValDiasSuc is Null) 
			SET @cValDiasSuc = '0'
		if (@cParidRep is Null) 
			SET @cParidRep = '0'
		if (@cQtdMult is Null) 
			SET @cQtdMult = '00'
		if (@cLMinimo is Null) 
			SET @cLMinimo = '0000'
		if (@cLMaximo is Null) 
			SET @cLMaximo = '0000'
		if (@cQtdAtual is Null) 
			SET @cQtdAtual = '0000'

		SET @cBuf = @cTipo + @cLocal + 
					@ctipobio + @cPlanta + 
					@cRastr + @cIniHA + @cFimHA + @cValidR + @cValidSMax + @cTolAntes + @cTolApos + @cLeitSm + 
					@cPosVPlaca + @cPosMensBloq + @cValDiasSuc + @cParidRep + @cQtdMult +
					@cLMinimo + @cLMaximo + @cQtdAtual
		

		
		/*
		SET @cBuf = @cTipo + @cLocal + COALESCE(@cAdBuf, '') + 
					@ctipobio + @cPlanta + COALESCE(@cAdBuf, '') + 
					@cRastr + @cIniHA + @cFimHA + @cValidR + @cValidSMax + @cTolAntes + @cTolApos + @cLeitSm + 
					@cPosVPlaca + @cPosMensBloq + @cValDiasSuc + @cParidRep + @cQtdMult +
					@cLMinimo + @cLMaximo + @cQtdAtual
		
		*/
		SET @ret = 1

		IF (@cData != '000000')
		BEGIN
			-- verifica se data e´de Feriado
			IF EXISTS (SELECT DESC_FER FROM FERIADO (NOLOCK)
			   WHERE ((DATA_FER = @DataAux) and
					  (CONVERT(int, PLANTA_FER) = CONVERT(int, @cPlanta) or PLANTA_FER is null or CONVERT(int, PLANTA_FER) = 0)))
			BEGIN
				SET @ret = 2
			END
		END
	END

--	SET LOCK_TIMEOUT -1		

	SELECT @ret, @cBuf, @nTamG
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlconsG3G5_term_tcpoff'))
	DROP PROCEDURE TELESSVR.sqlconsG3G5_term_tcpoff;
GO

CREATE PROCEDURE TELESSVR.sqlconsG3G5_term_tcpoff @cEndIp CHAR(15) AS

DECLARE @cTipo AS CHAR(1), 
		--@cLocal AS VARCHAR(9), --@cLocal AS CHAR(3), 
		--@cPlanta AS VARCHAR(9),   --@cPlanta AS CHAR(3), 
		@cLocal AS CHAR(5), --@cLocal AS CHAR(3), 
		@cPlanta AS CHAR(5),   --@cPlanta AS CHAR(3), 
		@ctipobio AS CHAR(1), 
		@cRastr AS CHAR(1), @cBuf AS VARCHAR(29), @cIniHA AS CHAR(1), @cFimHA AS CHAR(1), 
		@cValidR AS CHAR(1), @cValidSMax AS CHAR(1), @cTolAntes AS CHAR(2), @cTolApos AS CHAR(2),
		@cLeitSm AS CHAR(1), @cPosVPlaca AS CHAR(1), @cPosMensBloq  AS CHAR(1), @cValDiasSuc AS CHAR(1)

DECLARE @ret int 
DECLARE @nTamG int, @cAdBuf CHAR(2) --@cAdBuf VARCHAR(2)  	-- novo

	
	--SET LOCK_TIMEOUT 1000
	SET @ret = 0
	SET @cBuf = ' '
	SET DATEFORMAT DMY

	SET @cLocal = null;
	SET @cPlanta = null;
	SET @nTamG = 3 

	SELECT	@nTamG  = COLUNAS.LENGTH
		FROM 
			SYSOBJECTS AS TABELAS,
			SYSCOLUMNS AS COLUNAS
		WHERE 
			-- JOINS 
			TABELAS.ID = COLUNAS.ID
			AND TABELAS.NAME = 'DAT07'
			AND COLUNAS.NAME = 'LACES'

	-- OBS: NAO ESTA SENDO UTILIZADO cAdBuf, pois variaveis cLocal e cPlanta são CHAR(5), OU SEJA, nao importa de G3 ou G5, sempre comportarao tamanho de 5
	IF (@nTamG = 3) 
		SET @cAdBuf = SPACE(2);		-- 2 espços
	ELSE
		SET @cAdBuf = null;

	SELECT @cTipo = TIP_TERM,
	       @cLocal = LACES,
	       @ctipobio = BIO_TIPO,
	       @cPlanta = PLANTA,
	       @cRastr = RASTREADOR,
	       @cIniHA = POS_INIHALM,
	       @cFimHA = POS_FIMHALM,
	       @cValidR = VALID_RET,
	       @cValidSMax = VALID_SAIDAMAX,
	       @cTolAntes = TOLER_ANTES,
	       @cTolApos = TOLER_APOS,
	       @cLeitSm = TIP_LEIT,
	       @cPosVPlaca = POSVALPLACA,
	       @cPosMensBloq = POSMENSBLOQ,
	       @cValDiasSuc = VALID_NDIAS
	       
		       
	FROM DAT07 (NOLOCK)
		  WHERE END_IP = @cEndIp and blueb = '00' and codin = '00'

	IF (@@ROWCOUNT <> 0)
	BEGIN
		if (@cTipo is Null) 
			SET @cTipo = '1'
		/*	
		if (@cLocal is Null) begin
			if (@nTamG = 3)	
				SET @cLocal = '000';
			else
				SET @cLocal = '00000';
		end
		*/
		if (@cLocal is Null) begin
			SET @cLocal = '00000';
		end
		
		
		if (@ctipobio is Null) 
			SET @ctipobio = '0'

		/*
		if (@cPlanta is Null) begin
			if (@nTamG = 3)	
				SET @cPlanta = '000';
			else
				SET @cPlanta = '00000';
		end
		*/
		if (@cPlanta is Null) 
			SET @cPlanta = '00000';
		
		
		if (@cRastr is Null) 
			SET @cRastr = '0'
		if (@cIniHA is Null) 
			SET @cIniHA = '0'
		if (@cFimHA is Null) 
			SET @cFimHA = '0'
		if (@cValidR is Null) 
			SET @cValidR = '0'
		if (@cValidSMax is Null) 
			SET @cValidSMax = '0'
		if (@cLeitSm is Null) 
			SET @cLeitSm = '0'
		if (@cTolAntes is Null) 
			SET @cTolAntes = '00'
		if (@cTolApos is Null) 
			SET @cTolApos = '00'
		if (@cPosVPlaca is Null) 
			SET @cPosVPlaca = '0'
		if (@cPosMensBloq is Null) 
			SET @cPosMensBloq = '0'
		if (@cValDiasSuc is Null) 
			SET @cValDiasSuc = '0'

		/*
		SET @cBuf = @cTipo + @cLocal + COALESCE(@cAdBuf, '') + 
					@ctipobio + @cPlanta + COALESCE(@cAdBuf, '') + 
					@cRastr + @cIniHA + @cFimHA + @cValidR + @cValidSMax + @cTolAntes + @cTolApos + @cLeitSm + @cPosVPlaca + @cPosMensBloq + @cValDiasSuc
		*/
		SET @cBuf = @cTipo + @cLocal + 
					@ctipobio + @cPlanta + 
					@cRastr + @cIniHA + @cFimHA + @cValidR + @cValidSMax + @cTolAntes + @cTolApos + @cLeitSm + @cPosVPlaca + @cPosMensBloq + @cValDiasSuc
		
		SET @ret = 1

	END

--	SET LOCK_TIMEOUT -1		

	SELECT @ret, @cBuf, @nTamG
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO
	
IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlconsG3G5_term_fer_tcp18'))
	DROP PROCEDURE TELESSVR.sqlconsG3G5_term_fer_tcp18;
GO

CREATE PROCEDURE TELESSVR.sqlconsG3G5_term_fer_tcp18 @cEndIp CHAR(15), @cData varchar(6) AS

DECLARE @cTipo AS CHAR(1), 
		--@cLocal AS VARCHAR(9), 	--@cLocal AS CHAR(3), 
		--@cPlanta AS VARCHAR(9), --@cPlanta AS CHAR(3), 
		@cLocal AS CHAR(5), 	--@cLocal AS CHAR(3), 
		@cPlanta AS CHAR(5), --@cPlanta AS CHAR(3), 
		
		@ctipobio AS CHAR(1), 
		@cRastr AS CHAR(1), @cBuf AS VARCHAR(50), @cIniHA AS CHAR(1), @cFimHA AS CHAR(1), 
		@cValidR AS CHAR(1), @cValidSMax AS CHAR(1), @cTolAntes AS CHAR(2), @cTolApos AS CHAR(2),
		@cLeitSm AS CHAR(1), @cPosVPlaca AS CHAR(1), @cPosMensBloq  AS CHAR(1), @cValDiasSuc AS CHAR(1),
		@cParidRep AS CHAR(1), @cQtdMult AS CHAR(2),
		@cLMinimo AS CHAR(4), @cLMaximo AS CHAR(4), @cQtdAtual AS CHAR(4)


DECLARE @ret int, @DataAux varchar(10), @Descr varchar(31) 
DECLARE @nTamG int, @cAdBuf CHAR(2) --@cAdBuf VARCHAR(2)			-- novo

--	SET LOCK_TIMEOUT 1000
	SET @ret = 0
	SET @cBuf = ' '
	set @DataAux = substring (@cData,1,2)+ '-'+ substring (@cData, 3,2)+ '-'+ substring (@cData, 5,2)
	SET DATEFORMAT DMY

	SET @cTolAntes = '00'
	SET @cTolApos = '00'

	SET @cLocal = null;
	SET @cPlanta = null;
	SET @nTamG = 3 

	SELECT	@nTamG  = COLUNAS.LENGTH
		FROM 
			SYSOBJECTS AS TABELAS,
			SYSCOLUMNS AS COLUNAS
		WHERE 
			-- JOINS 
			TABELAS.ID = COLUNAS.ID
			AND TABELAS.NAME = 'DAT07'
			AND COLUNAS.NAME = 'LACES'

	IF (@nTamG = 3) 
		SET @cAdBuf = SPACE(2);		-- 2 espços
	ELSE
		SET @cAdBuf = null;



	SELECT @cTipo = TIP_TERM,
	       @cLocal = LACES,
	       @ctipobio = BIO_TIPO,
	       @cPlanta = PLANTA,
	       @cRastr = RASTREADOR,
	       @cIniHA = POS_INIHALM,
	       @cFimHA = POS_FIMHALM,
	       @cValidR = VALID_RET,
	       @cValidSMax = VALID_SAIDAMAX,
	       @cLeitSm = TIP_LEIT,
	       @cPosVPlaca = POSVALPLACA,
	       @cPosMensBloq = POSMENSBLOQ,
	       @cValDiasSuc = VALID_NDIAS,
	       @cParidRep = PARIDREP,
	       @cQtdMult = QTDMULT,
		   @cLMinimo = REPLICATE('0', 4 - LEN(CAST (LMINIMO as varCHAR(4)))) + RTrim(LTRIM(STR(LMINIMO,4))),		-- insere 0's à esquerda para string final tamanho 4
		   @cLMaximo = REPLICATE('0', 4 - LEN(CAST (LMAXIMO as varCHAR(4)))) + RTrim(LTRIM(STR(LMAXIMO,4))),			-- insere 0's à esquerda para string final tamanho 4
		   @cQtdAtual = REPLICATE('0', 4 - LEN(CAST (QTDATUAL as varCHAR(4)))) + RTrim(LTRIM(STR(QTDATUAL,4)))			-- insere 0's à esquerda para string final tamanho 4
		       
	FROM DAT07 (NOLOCK)
		  WHERE END_IP = @cEndIp and blueb = '00' and codin = '00'

	IF (@@ROWCOUNT <> 0)
	BEGIN
		if (@cTipo is Null) 
			SET @cTipo = '1'

		/*			
		if (@cLocal is Null) begin
			if (@nTamG = 3)	
				SET @cLocal = '000';
			else
				SET @cLocal = '00000';
		end
		*/
		if (@cLocal is Null) begin
				SET @cLocal = '00000';
		end
		
		if (@ctipobio is Null) 
			SET @ctipobio = '0'

		/*
		if (@cPlanta is Null) begin
			if (@nTamG = 3)	
				SET @cPlanta = '000'
			else
				SET @cPlanta = '00000'
		end
		*/
		if (@cPlanta is Null) begin
			SET @cPlanta = '00000'
		end
		
			
		if (@cRastr is Null) 
			SET @cRastr = '0'
		if (@cIniHA is Null) 
			SET @cIniHA = '0'
		if (@cFimHA is Null) 
			SET @cFimHA = '0'
		if (@cValidR is Null) 
			SET @cValidR = '0'
		if (@cValidSMax is Null) 
			SET @cValidSMax = '0'
		if (@cLeitSm is Null) 
			SET @cLeitSm = '0'
		if (@cTolAntes is Null) 
			SET @cTolAntes = '00'
		if (@cTolApos is Null) 
			SET @cTolApos = '00'
		if (@cPosVPlaca is Null) 
			SET @cPosVPlaca = '0'
		if (@cPosMensBloq is Null) 
			SET @cPosMensBloq = '0'
		if (@cValDiasSuc is Null) 
			SET @cValDiasSuc = '0'
		if (@cParidRep is Null) 
			SET @cParidRep = '0'
		if (@cQtdMult is Null) 
			SET @cQtdMult = '00'
		if (@cLMinimo is Null) 
			SET @cLMinimo = '0000'
		if (@cLMaximo is Null) 
			SET @cLMaximo = '0000'
		if (@cQtdAtual is Null) 
			SET @cQtdAtual = '0000'

		/*
		SET @cBuf = @cTipo + @cLocal + COALESCE(@cAdBuf, '') + 
					@ctipobio + @cPlanta + COALESCE(@cAdBuf, '') + 
					@cRastr + @cIniHA + @cFimHA + @cValidR + @cValidSMax + @cTolAntes + @cTolApos + @cLeitSm + 
					@cPosVPlaca + @cPosMensBloq + @cValDiasSuc + @cParidRep + @cQtdMult + 
					@cLMinimo + @cLMaximo + @cQtdAtual					
		*/
		
		SET @cBuf = @cTipo + @cLocal + 
					@ctipobio + @cPlanta + 
					@cRastr + @cIniHA + @cFimHA + @cValidR + @cValidSMax + @cTolAntes + @cTolApos + @cLeitSm + 
					@cPosVPlaca + @cPosMensBloq + @cValDiasSuc + @cParidRep + @cQtdMult + 
					@cLMinimo + @cLMaximo + @cQtdAtual					
		
		SET @ret = 1

		IF (@cData != '000000')
		BEGIN
			-- verifica se data e´de Feriado
			IF EXISTS (SELECT DESC_FER FROM FERIADO (NOLOCK)
			   WHERE ((DATA_FER = @DataAux) and
					  (CONVERT(INT, PLANTA_FER) = CONVERT(INT, @cPlanta) or PLANTA_FER is null or CONVERT(INT, PLANTA_FER) = 0)))
			BEGIN
				SET @ret = 2
			END
		END
	END

--	SET LOCK_TIMEOUT -1		

	SELECT @ret, @cBuf
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO
	
IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('sqlconsG3G5_term_tcpoff18'))
	DROP PROCEDURE TELESSVR.sqlconsG3G5_term_tcpoff18;
GO

CREATE PROCEDURE TELESSVR.sqlconsG3G5_term_tcpoff18 @cEndIp CHAR(15) AS

DECLARE @cTipo AS CHAR(1), 
		--@cLocal AS VARCHAR(9), --@cLocal AS CHAR(3), 
		--@cPlanta AS VARCHAR(3),   --@cPlanta AS CHAR(3), 
		@cLocal AS CHAR(5), 
		@cPlanta AS CHAR(5), 
		@ctipobio AS CHAR(1), 
		@cRastr AS CHAR(1), @cBuf AS VARCHAR(29), @cIniHA AS CHAR(1), @cFimHA AS CHAR(1), 
		@cValidR AS CHAR(1), @cValidSMax AS CHAR(1), @cTolAntes AS CHAR(2), @cTolApos AS CHAR(2),
		@cLeitSm AS CHAR(1), @cPosVPlaca AS CHAR(1), @cPosMensBloq  AS CHAR(1), @cValDiasSuc AS CHAR(1)

DECLARE @ret int 
DECLARE @cAdBuf VARCHAR(2), @nTamG int 	-- novo

--	SET LOCK_TIMEOUT 1000
	SET @ret = 0
	SET @cBuf = ' '
	SET DATEFORMAT DMY

	SET @cTolAntes = '00'
	SET @cTolApos = '00'

	SET @cLocal = null;
	SET @cPlanta = null;
	SET @nTamG = 3 

	SELECT	@nTamG  = COLUNAS.LENGTH
		FROM 
			SYSOBJECTS AS TABELAS,
			SYSCOLUMNS AS COLUNAS
		WHERE 
			-- JOINS 
			TABELAS.ID = COLUNAS.ID
			AND TABELAS.NAME = 'DAT07'
			AND COLUNAS.NAME = 'LACES'

	-- OBS: NAO ESTA SENDO UTILIZADO cAdBuf, pois variaveis cLocal e cPlanta são CHAR(5), OU SEJA, nao importa de G3 ou G5, sempre comportarao tamanho de 5
	IF (@nTamG = 3) 
		SET @cAdBuf = SPACE(2);		-- 2 espços
	ELSE
		SET @cAdBuf = null;


	SELECT @cTipo = TIP_TERM,
	       @cLocal = LACES,
	       @ctipobio = BIO_TIPO,
	       @cPlanta = PLANTA,
	       @cRastr = RASTREADOR,
	       @cIniHA = POS_INIHALM,
	       @cFimHA = POS_FIMHALM,
	       @cValidR = VALID_RET,
	       @cValidSMax = VALID_SAIDAMAX,
	       @cLeitSm = TIP_LEIT,
	       @cPosVPlaca = POSVALPLACA,
	       @cPosMensBloq = POSMENSBLOQ,
	       @cValDiasSuc = VALID_NDIAS
		       
	FROM DAT07 (NOLOCK)
		  WHERE END_IP = @cEndIp and blueb = '00' and codin = '00'

	IF (@@ROWCOUNT <> 0)
	BEGIN
		if (@cTipo is Null) 
			SET @cTipo = '1'
		/*			
		if (@cLocal is Null) begin
			if (@nTamG = 3)	
				SET @cLocal = '000';
			else
				SET @cLocal = '00000';
		end
		*/
		if (@cLocal is Null) begin
			SET @cLocal = '00000';
		end
		
		
		if (@ctipobio is Null) 
			SET @ctipobio = '0'

		/*		
		if (@cPlanta is Null) begin
			if (@nTamG = 3)	
				SET @cPlanta = '000'
			else
				SET @cPlanta = '00000'
		end
		*/
		if (@cPlanta is Null) 
			SET @cPlanta = '00000';
		
		if (@cRastr is Null) 
			SET @cRastr = '0'
		if (@cIniHA is Null) 
			SET @cIniHA = '0'
		if (@cFimHA is Null) 
			SET @cFimHA = '0'
		if (@cValidR is Null) 
			SET @cValidR = '0'
		if (@cValidSMax is Null) 
			SET @cValidSMax = '0'
		if (@cLeitSm is Null) 
			SET @cLeitSm = '0'
		if (@cPosVPlaca is Null) 
			SET @cPosVPlaca = '0'
		if (@cPosMensBloq is Null) 
			SET @cPosMensBloq = '0'
		if (@cValDiasSuc is Null) 
			SET @cValDiasSuc = '0'

		/*
		SET @cBuf = @cTipo + @cLocal + COALESCE(@cAdBuf, '') + 
					@ctipobio + @cPlanta + COALESCE(@cAdBuf, '') + 
					@cRastr + @cIniHA + @cFimHA + @cValidR + @cValidSMax + @cTolAntes + @cTolApos + @cLeitSm + @cPosVPlaca + @cPosMensBloq + @cValDiasSuc
		*/		
		
		SET @cBuf = @cTipo + @cLocal + 
					@ctipobio + @cPlanta + 
					@cRastr + @cIniHA + @cFimHA + @cValidR + @cValidSMax + @cTolAntes + @cTolApos + @cLeitSm + @cPosVPlaca + @cPosMensBloq + @cValDiasSuc
		
		SET @ret = 1

	END

--	SET LOCK_TIMEOUT -1		

	SELECT @ret, @cBuf, @nTamG
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

-----------------------------------------------------------------------------
-- Create date:		26/09/2019 - 16:21
-- Changed:			26/09/2019 - 16:21
-- Redmine: 		@3587
-----------------------------------------------------------------------------

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('DAM00_EI'))
	DROP TRIGGER TELESSVR.DAM00_EI;
GO

CREATE TRIGGER TELESSVR.DAM00_EI on TELESSVR.DAM00 for update, insert as
declare
  @icard    char(12),
  @diam     char(2),
  @mesm     char(2),
  @anom     char(2),
  @horam    char(4),
  @segundo  char(2),
  @codac    char(2),
  @posic    char(1),
  @blueb    char(2),
  @codtt    char(2),
  @end_ip   char(15),
  @CodiFunc char(2),
  @onoff    char(1),
  @veiculo  varchar(15),
  @erro     int,
  @CodiPlan numeric(3),
  @CodiCole numeric(3),
  @CodiBene numeric(2),
  @UsoMarc  numeric(2),
  @deslog   varchar(254),
  @DataAces datetime,
  @HoraAces int,
  @SequColeAlar int,
  @idVeic int,
  @CodiEsta smallint,
  @IdEsVisit int,
  @TipoVisi int,
  @BloqAcesSaid varchar(1),
  @BaixAutoCrac varchar(1),
  @ICardReal    char(12),
  @AchouIcard   smallint,
  @ICardVeiculo numeric(12),
	
  @vIdColab numeric(9),
  @vIdVisi numeric(9),
  @vDataCP Date,
	@vHoraEntrCP DateTime,
  @vHoraSaidCP DateTime,
  @vHoraCP DateTime

  
  select @SequColeAlar = 0 ;

  declare cur_dam00_ins_new cursor for
    select icard, diam, mesm, anom, horam, segundo, codac, posic, blueb, codtt, end_ip, codfnc, onoff, veiculo
      from
        inserted for read only

  open cur_dam00_ins_new 
  
  fetch next from cur_dam00_ins_new into @icard, @diam, @mesm, @anom, @horam, @segundo, @codac, @posic, @blueb, @codtt, @end_ip, @CodiFunc, @onoff, @veiculo
  
  while ( @@fetch_status = 0 )
  begin
   
    select @erro = 0
    select @deslog = ''
    select @SequColeAlar = @SequColeAlar + 1 ;

    if (  @segundo = '99' )
        select @segundo = '00'
            

    if not ( @diam like '[0-9][0-9]' and @diam between '01' and '31' )
    begin
     
      select @erro = 1

      select @deslog = 'DAM00: Formato de Data Inválido: [telessvr][DAM00][DIAM] = ' + @diam
   
    end
    else
      if not ( @mesm like '[0-9][0-9]' and @mesm  between '01' and '12' )
      begin

        select @erro = 1

        select @deslog = 'DAM00: Formato de Data Inválido: [telessvr][DAM00][MESM] = ' + @mesm
          
      end
      else
        if not ( @anom  like '[0-9][0-9]'  and @anom  between '00' and '99'   )
        begin
             
          select @erro = 1
             
          select @deslog = 'DAM00: Formato de Data Inválido: [telessvr][DAM00][ANOM] = ' + @anom
             
        end
        else
          if not (  @horam like '[0-9][0-9][0-9][0-9]'  and @horam between '0000' and '2400'  )
          begin
           
            select @erro = 1
           
            select @deslog = 'DAM00: Formato de Data Inválido: [telessvr][DAM00]HORAM] = ' + @horam
         
          end
          else
            if not (  @segundo like '[0-9][0-9]' and @segundo between '00' and '60' )
            begin
             
              select @erro = 1
              
              select @deslog = 'DAM00: Formato de Data Inválido: [telessvr][DAM00]SEGUNDO] = ' + @segundo
           
            end
							else
                if ( suricato.isReallyNumeric( @icard ) = 0 )
                begin
                 
                  select @erro = 1		  
                 
                  select @deslog = 'DAM00: Formato de Icard inválido. ICARD = ' + @icard
                   
                  Set @icard = 0
               
                end
  
    if @erro = 0
    begin

      select @CodiPlan = CodiPlan, @CodiCole = CodiCole from suricato.TbCodin where NumeEndeCole = @end_ip 

      if ( @CodiPlan IS NULL OR @CodiCole IS NULL )
      begin
        select @erro = 1
			  select @deslog = 'DAM00: Codin não encontrado'
				GOTO FIM
      end
 
      select @CodiBene = CodiBene from suricato.TbCodinBenef where CodiPlan = @CodiPlan and CodiCole = @CodiCole

      select @UsoMarc = UsoMarc from suricato.TbMarcaReali where CodiPlan = @CodiPlan and CodiCole = @CodiCole and CodiFunc = convert( numeric(2) , CodiFunc )

      select @DataAces = convert( datetime,  @anom + @mesm + @diam, 112 )

      select @HoraAces = convert( int, substring( @horam, 1, 2 ) ) * 60 + convert( int, substring( @horam, 3, 2 ) )

      select @ICardReal = ICard from suricato.TbCrachFisic where NumeFisiCrac = convert( decimal, @icard )
  
      if @ICardReal is null
        select @ICardReal = @icard
        
      if exists( select 1 from suricato.TbMarcaAcess where ICard = @ICardReal and DataAces = @DataAces and HoraAces = @HoraAces and SequRegi = @segundo and CodiPlan = @CodiPlan and CodiCole = @CodiCole )
      begin
               
        select @erro = 1
               
        select @deslog = 'DAM00: Marcações Duplicadas para Crachá: ' + @ICardReal +
                         ', Data: ' + cast( @DataAces as varchar ) + 
                         ', Hora: ' + cast( @HoraAces as varchar ) + ':' + cast( @segundo as varchar ) +
                         ', Planta: ' + cast( @CodiPlan as varchar ) +
                         ', Codin ' + cast( @CodiCole as varchar )
             
      end
                    
      if @erro = 0
      begin

        select @ICardVeiculo = COALESCE( case when rtrim(ltrim(@veiculo)) = '' then 0 else convert( numeric, rtrim(ltrim(@veiculo ))) end, 0 )

        if ( @ICardVeiculo = 0 and exists ( select 1 from suricato.TbCadasCrach where ICard = @ICardReal and UsoFaixCrac = 8 ) )
        begin
          select @ICardVeiculo = @ICardReal
        end




        -- POC SENADO
		begin
					select 
							@vIdColab = isnull(IdColab,0) 
						from 
							suricato.TbHistoCrach 
						where 
							ICard = @ICardReal 
							and ( DataFina < @DataAces or ( DataFina = @DataAces and HoraFina < ( @HoraAces * 60 ) ) ) 
						order by 
							DataFina DESC, 
							HoraFina DESC			  

			select top 1 @ICardVeiculo = isnull(hv.IcardV,0) from suricato.TBHISTORESPVEICU hrv
			join suricato.TBHISTOVEICU hv
			on hrv.idveic = hv.idveic
			where 
			hrv.IDCOLAB = @vIdColab
			order by hv.datainic desc, hv.horainic desc
		end

        insert into suricato.TbMarcaAcess ( ICard, DataAces, HoraAces, SequRegi, TipoAces, CodiPlan, CodiCole, CodiFunc, DireAces, QuanAces, OrigMarc, UsoMarc, CodiBene, FlagAces, StatAtuaCole, NumeFisiCrac, ICardV )
          values ( @ICardReal, @DataAces, @HoraAces, @segundo, @codac, @CodiPlan, @CodiCole, convert( numeric(2), @CodiFunc ), case when @posic = '0' then 'E' when @posic = '1' then 'S' end, 0, 'E', isnull( @UsoMarc, 1 ), @CodiBene, 0, convert( smallint, @onoff  ), @icard, @ICardVeiculo )


					
        -- >>> Alarme
				if ( @codac = '15')
				begin
				
					select 
							@vIdColab = IdColab 
						from 
							suricato.TbHistoCrach 
						where 
							ICard = @ICardReal 
							and ( DataFina < @DataAces or ( DataFina = @DataAces and HoraFina < ( @HoraAces * 60 ) ) ) 
						order by 
							DataFina DESC, 
							HoraFina DESC			  
				
					insert into suricato.TbAlarSTrata ( DataColeAlar, HoraColeAlar, SequColeAlar, DataAlar, HoraAlar, CodiPlan, CodiCole, CodiSind, TipoAlar, StatAlar, DataRecoAlar, HoraRecoAlar, UsuaReceChav, DescRecoUsua, TipoRecoReal, EndeEntrCole, ICard, TipoAces, IdColab )
						select 
								convert( char(8), getdate(), 112 ),
								( datepart( hour, getdate() ) * 60 ) + ( datepart( minute, getdate() ) ),
								datepart( second, getdate() ) * 1000 + datepart( millisecond, getdate() ) + @SequColeAlar,
								@DataAces, @HoraAces * 60 + @segundo, @CodiPlan, @CodiCole, 2015, 1, 0 , '19001231', 0, null, '', null, null, @ICardReal, @codac, @vIdColab
							from
								suricato.TbTipoAcess
							where 
								TipoAces = @codac and  TipoAcesMoni = 'S'
							
				end
				else
				begin
				
					insert into suricato.TbAlarSTrata ( DataColeAlar, HoraColeAlar, SequColeAlar, DataAlar, HoraAlar, CodiPlan, CodiCole, CodiSind, TipoAlar, StatAlar, DataRecoAlar, HoraRecoAlar, UsuaReceChav, DescRecoUsua, TipoRecoReal, EndeEntrCole, ICard, TipoAces )
						select 
								convert( char(8), getdate(), 112 ),
								( datepart( hour, getdate() ) * 60 ) + ( datepart( minute, getdate() ) ),
								datepart( second, getdate() ) * 1000 + datepart( millisecond, getdate() ) + @SequColeAlar,
								@DataAces, @HoraAces * 60 + @segundo, @CodiPlan, @CodiCole, 9999, 0, 0 , '19001231', 0, null, '', null, null, @ICardReal, @codac
							from
								suricato.TbTipoAcess
							where 
								TipoAces = @codac and  TipoAcesMoni = 'S'				
				
				end
        -- <<< Alarme

				


        -- >>> Baixa de Provisório
        if @posic = '1' and @codac = '01'
        begin

            if exists ( select 1 from suricato.TbCadasCrach where icard = cast( replicate( 0, 12 - len( cast( @ICardReal as varchar ) ) ) + cast( @ICardReal as varchar ) as numeric) and UsoFaixCrac = 6 )
            begin

                if exists ( select 1 from suricato.TbCodin where NumeEndeCole = @end_ip and BaixaAutoProv  = 'S' )
                begin

                  update suricato.TbHistoCrach
                    set 
                      DataFina = @DataAces, 
                      HoraFina = @HoraAces - 1,
                      StatHist = 2,
                      StatAtuaCont = 2
                    where 
                      ICard = @ICardReal
							        and ( DataInic < @DataAces or ( DataInic = @DataAces and HoraInic <= @HoraAces ) ) 
							        and ( DataFina > @DataAces or ( DataFina = @DataAces and HoraFina >= @HoraAces ) or ( DataFina = '1900-12-31' ) ) 
                      and convert( datetime, convert( varchar(10), DataFina, 120 ) ) = convert( datetime, convert( varchar(10), getdate(), 120 ) ) 

                end

            end

        end
        -- <<< Baixa de Provisório


        -- >>> Baixa de Visitante
        if @posic = '1' and @codac = '01'
        begin
              if exists ( select 1 from telessvr.controle where icard = replicate( 0, 12 - len( cast( @ICardReal as varchar ) ) ) + cast( @ICardReal as varchar ) and tpfis = 4 )
              begin

                if exists ( select 1 from suricato.TbCodin where NumeEndeCole = @end_ip and BaixAutoCrac = 'S' )
                begin

                  select 
                      @IdEsVisit = IdEsVisit, 
                      @TipoVisi = suricato.TbTipoVisit.TipoVisi, 
                      @BloqAcesSaid = BloqAcesSaid, 
                      @BaixAutoCrac = BaixAutoCrac 
                    from 
                      suricato.TbTipoVisit
                    inner join suricato.TbESVisit
                      on suricato.TbTipoVisit.TipoVisi = suricato.TbESVisit.TipoVisi
                    where 
                      ICard = @ICardReal and
                      DataSaid = convert(datetime, '19001231', 112)

                  if upper( @BaixAutoCrac ) = 'S'
                  begin

                    update suricato.TbESVisit 
                      set 
                        DataSaid = @DataAces, 
                        HoraSaid = @HoraAces,
                        DataSaidLoca = @DataAces, 
                        HoraSaidLoca = @HoraAces
                      where 
                        IdEsVisit = @IdEsVisit

                    update suricato.TbHistoVisit
                      set 
                        DataFina = @DataAces, 
                        HoraFina = @HoraAces
                      where 
                        ICard = @ICardReal and 
                        DataFina = convert(datetime, '19001231', 112)

                    end

                    if upper( @BloqAcesSaid ) = 'S'
                      update telessvr.controle set situa = '1' where icard = replicate( 0, 12 - len( cast( @ICardReal as varchar ) ) ) + cast( @ICardReal as varchar ) and tpfis = 4

                  end
              end
        end
        -- <<< Baixa de Visitante



        -- >>> Suricato Risk Area Controller
        if ( @codac = '01' ) and
           exists ( select 1 from suricato.TbParamServi where Nome = 'USE_RISK_AREA_CONTROLLER' and Valo = 'S' ) and
           exists ( select 1 from suricato.TbCodinLocalAcess where CodiPlan = @CodiPlan and CodiCole = @CodiCole )
        begin

          declare @DataHora varchar(19)

          select @DataHora = '20' + @anom + '-' + @mesm + '-' + @diam + ' ' + substring( @horam, 1, 2 ) + ':' + substring( @horam, 3, 2 )  + ':' + @segundo

          if (@posic = '0')
          begin
            update suricato.TbContrLocalAcess set Entrada = CONVERT(Datetime, @DataHora, 120) where Icard = cast(@ICardReal as numeric) and NumeEndeCole = @end_ip
          end
          else
          begin
            update suricato.TbContrLocalAcess set Status = 0, Saida = CONVERT(Datetime, @DataHora, 120) where Icard = cast(@ICardReal as numeric) and NumeEndeCole = @end_ip
            delete TELESSVR.MATCODIN where ICard = @ICardReal and END_IP = @end_ip
          end

        end
        -- <<< Suricato Risk Area Controller


        -- >>> Suricato Message Controller
        if exists ( select 1 from suricato.TbParamServi where Nome = 'USE_MESSAGE_CONTROLLER' and Valo = 'S' )
        begin

          declare @vDataInic datetime;
          declare @vHoraInic integer;

          declare cur_MessageController cursor for select icard from inserted for read only

          open cur_MessageController fetch next from cur_MessageController into @icard

          while ( @@fetch_status = 0 )
          begin


            update
                suricato.TbMensaColab
              set
                StatAtuaCont = 2
              where
                IdColab = ( select IdColab from suricato.TbColab where IdPessoa = suricato.getIdPessoa( @icard ) ) and
                ( DataInic < convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataInic = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraInic <= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) ) and
                ( DataFina > convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataFina = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraFina >= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) or ( DataFina = '1900-12-31' ) ) and
                StatAtuaCont = 1;


            select 
                TOP 1 @vIdColab = IdColab, @vDataInic = DataInic, @vHoraInic = HoraInic 
              from 
	              suricato.TbMensaColab
              where
                IdColab = ( select IdColab from suricato.TbColab where IdPessoa = suricato.getIdPessoa( @icard ) ) and
                ( DataInic < convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataInic = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraInic <= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) ) and
                ( DataFina > convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataFina = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraFina >= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) or ( DataFina = '1900-12-31' ) ) and
                StatAtuaCont = 0
              order by
                DataInic, HoraInic

            if @vIdColab <> 0
	          begin

                update suricato.TbMensaColab set StatAtuaCont = 1 where IdColab = @vIdColab and DataInic = @vDataInic and HoraInic = @vHoraInic;   

	          end
	          else
	          begin

                update
                    suricato.TbMensaColab
                  set
                    StatAtuaCont = 0
                  where
                    IdColab = ( select IdColab from suricato.TbColab where IdPessoa = suricato.getIdPessoa( @icard ) ) and
                    ( DataInic < convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataInic = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraInic <= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) ) and
                    ( DataFina > convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataFina = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraFina >= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) or ( DataFina = '1900-12-31' ) ) and
                    StatAtuaCont = 2;

                select 
                    TOP 1 @vIdColab = IdColab, @vDataInic = DataInic, @vHoraInic = HoraInic 
		              from 
		                suricato.TbMensaColab
                  where
                    IdColab = ( select IdColab from suricato.TbColab where IdPessoa = suricato.getIdPessoa( @icard ) ) and
                    ( DataInic < convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataInic = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraInic <= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) ) and
                    ( DataFina > convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataFina = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraFina >= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) or ( DataFina = '1900-12-31' ) ) and
                    StatAtuaCont = 0
                  order by
                    DataInic, HoraInic
            
                update suricato.TbMensaColab set StatAtuaCont = 1 where IdColab = @vIdColab and DataInic = @vDataInic and HoraInic = @vHoraInic; 

	          end

            fetch next from cur_MessageController into @icard

          end

          close cur_MessageController
 
          deallocate cur_MessageController

        end
        -- <<< Suricato Message Controller


        -- >>> Baixa de Crédito de Refeitório de Colaborador
			  if  @codac = '01' 
			  begin

				  -- 

				  insert into suricato.TbCredCColab (IdColab, DataCons, HoraCons, SeguCons, ContCred, StatHist)
					  select HC.IdColab, @DataAces, @HoraAces, @segundo, AC.ContCredRefe, 1
						  from 
							  suricato.TbHistoCrach HC
						  inner join suricato.TbAcessColab AC
							  on HC.IdColab = AC.IdColab
						  where
							  HC.ICard = @ICardReal 
							  and ( HC.DataInic < @DataAces or ( HC.DataInic = @DataAces and HC.HoraInic <= ( @HoraAces * 60 ) ) ) 
							  and ( HC.DataFina > @DataAces or ( HC.DataFina = @DataAces and HC.HoraFina >= ( @HoraAces * 60 ) ) or ( HC.DataFina = '1900-12-31' ) ) 
							  and exists (select 1 from suricato.TbCodin where CodiPlan = @CodiPlan and CodiCole = @CodiCole and LocaCole = 2 )

			  end
        -- <<< Baixa de Crédito de Refeitório de Colaborador



        -- >>> Identificação de Pessoa Por Ambiente
        if exists ( select 1 from suricato.TbParamServi where Nome = 'PESSOA_AMBIENTE' and Valo = 'S' ) and @codac = '01' 
        begin

          declare @vIdPessoa numeric(9)

          declare @vCodiAmbi numeric(8) 

          select @vIdPessoa = suricato.getIdPessoa( @icard )

          select @vCodiAmbi = CodiAmbi from suricato.TbAmbieColet where CodiPlan = @CodiPlan and CodiCole = @CodiCole

          if (@vIdPessoa is not null) and (@vCodiAmbi is not null)
          begin

            delete from suricato.TbPessoaAmbie where IdPessoa = @vIdPessoa

            if (@posic = '0')
            begin
              insert into suricato.TbPessoaAmbie ( IdPessoa, CodiAmbi ) values ( @vIdPessoa, @vCodiAmbi )
            end
            else
            begin
              select @vCodiAmbi = CodiAmbiPai from suricato.TbAmbie where CodiAmbi = @vCodiAmbi
              if (@vCodiAmbi is not null)
              begin
                insert into suricato.TbPessoaAmbie ( IdPessoa, CodiAmbi ) values ( @vIdPessoa, @vCodiAmbi )
              end
            end

          end

        end
        -- <<< Identificação de Pessoa Por Ambiente



        -- >>> Contador de Presenca por Ambiente
        if @codac = '01' 
           and exists ( select 1 from suricato.TbParamServi 
                          where 
                            Nome = 'CONTADOR_PRESENCA_AMBIENTE' 
                            and Valo = 'S' )
        begin
          SELECT @vCodiAmbi = CODIAMBI FROM SURICATO.TBAMBIECOLET WHERE CODIPLAN = @CodiPlan AND CODICOLE = @CodiCole
          IF (@vCodiAmbi IS NOT NULL)
          BEGIN
            EXECUTE SURICATO.SP_CONTADOR_PRESENCA_AMBIENTE @ICardReal, @DataAces, @HoraAces, @segundo, @vCodiAmbi, @posic
          END
        end
        -- <<< Contador de Presenca por Ambiente



        -- >>> Contador de Presenca
        if @codac = '01' 
           and exists ( select 1 from suricato.TbParamServi 
                          where 
                            Nome = 'CONTADOR_PRESENCA' 
                            and Valo = 'S' 
                            and exists (select 1 from suricato.TbCodin where CodiPlan = @CodiPlan and CodiCole = @CodiCole and LocaCole = 1 ) ) 
        begin
          EXECUTE SURICATO.SP_CONTADOR_PRESENCA @ICardReal, @DataAces, @HoraAces, @segundo, @CodiPlan, @posic
        end
        -- <<< Contador de Presenca
        
				
				
        -- >>> Controlar 1 Entrada de Veículo por Pessoa
        if @codac = '01' 
           and exists ( select 1 from suricato.TbParamServi 
                          where 
                            Nome = 'CONTROLADUPLAENTRADAVEICULO' 
                            and Valo = 'S' 
                            and exists (select 1 from suricato.TbCodin where CodiPlan = @CodiPlan and CodiCole = @CodiCole and DuplEntrVeic = 'S' ) ) 
        begin

          if (@posic = '0')
          begin

						insert into suricato.TbBloquCrach ( ICard, DataBloq, HoraBloq, CodiMoti, DataLibe, HoraLibe, StatAtuaCont, NumeFisiCrac )
							select 
									HV.ICardV, @DataAces, @HoraAces, 1004, '1900-12-31', 0, 1, 0
								from 
									suricato.TbHistoRespVeicu HRV 
                inner join suricato.TbHistoVeicu HV
                  on HRV.IdVeic = HV.IdVeic
								where
									HRV.IdColab in (
									
										select 
												HRV.IdColab
											from 
												suricato.TbHistoRespVeicu HRV
											inner join suricato.TbHistoVeicu HV
												on HRV.IdVeic = HV.IdVeic
											where
												HV.ICardV = @ICardReal 
												and ( HRV.DataInic < @DataAces or ( HRV.DataInic = @DataAces and HRV.HoraInic <= @HoraAces ) ) 
												and ( HRV.DataFim > @DataAces or ( HRV.DataFim = @DataAces and HRV.HoraFina >= @HoraAces ) or ( HRV.DataFim = '1900-12-31' ) ) 
							
									)
									and HV.ICardV <> @ICardReal  
									and ( HRV.DataInic < @DataAces or ( HRV.DataInic = @DataAces and HRV.HoraInic <= @HoraAces ) ) 
									and ( HRV.DataFim > @DataAces or ( HRV.DataFim = @DataAces and HRV.HoraFina >= @HoraAces ) or ( HRV.DataFim = '1900-12-31' ) )
									and not exists (
									  select 1 from suricato.TbBloquCrach
										  where 
												ICard = HV.ICardV
												and ( DataBloq < @DataAces or ( DataBloq = @DataAces and HoraBloq <= @HoraAces ) ) 
												and ( DataLibe > @DataAces or ( DataLibe = @DataAces and HoraLibe >= @HoraAces ) or ( DataLibe = '1900-12-31' ) )												
                        and CodiMoti = 1004
									)

          end
          else
          begin

						update suricato.TbBloquCrach
							set DataLibe = @DataAces, HoraLibe = @HoraAces - 1, StatAtuaCont = 2
							where 
								exists
								(
										select 
													1
												from 
													suricato.TbHistoRespVeicu HRV
                        inner join suricato.TbHistoVeicu HV
                          on HRV.IdVeic = HV.IdVeic
												where
													HRV.IdColab in (
													
														select 
																HRV.IdColab
															from 
																suricato.TbHistoRespVeicu HRV
															inner join suricato.TbHistoVeicu HV
																on HRV.IdVeic = HV.IdVeic
															where
																HV.ICardV = @ICardReal 
																and ( HRV.DataInic < @DataAces or ( HRV.DataInic = @DataAces and HRV.HoraInic <= @HoraAces ) ) 
																and ( HRV.DataFim > @DataAces or ( HRV.DataFim = @DataAces and HRV.HoraFina >= @HoraAces ) or ( HRV.DataFim = '1900-12-31' ) )
																
													)
													and HV.ICardV <> @ICardReal  
													and HV.ICardV = ICard
													and ( HRV.DataInic < @DataAces or ( HRV.DataInic = @DataAces and HRV.HoraInic <= @HoraAces ) ) 
													and ( HRV.DataFim > @DataAces or ( HRV.DataFim = @DataAces and HRV.HoraFina >= @HoraAces ) or ( HRV.DataFim = '1900-12-31' ) )
								)
								and ( DataBloq < @DataAces or ( DataBloq = @DataAces and HoraBloq <= @HoraAces ) ) 
								and ( DataLibe > @DataAces or ( DataLibe = @DataAces and HoraLibe >= @HoraAces ) or ( DataLibe = '1900-12-31' ) )														
                and CodiMoti = 1004

          end

        end
        -- <<< Controlar 1 Entrada de Veículo por Pessoa	


        -- >>> Controlar Baixa de Saída de Veículo de Visitante
        if @codac = '01' 
           and @posic = '1'
           and @ICardVeiculo > 0
           and exists ( select 1 from suricato.TbParamServi 
                          where 
                            Nome = 'BAIXAR_VEICULO_VISITANTE' 
                            and Valo = 'S' 
                            and exists (select 1 from suricato.TbCodin where CodiPlan = @CodiPlan and CodiCole = @CodiCole and LocaCole = 1 and BaixAutoCrac = 'S') ) 
        begin

          update suricato.TbHistoVeicu set DataFim = @DataAces, HoraFina = @HoraAces - 1 
            where 
              ICardV = @ICardVeiculo
              and ( DataInic < @DataAces or ( DataInic = @DataAces and HoraInic <= @HoraAces ) ) 
							and ( DataFim > @DataAces or ( DataFim = @DataAces and HoraFina >= @HoraAces ) or ( DataFim = '1900-12-31' ) )
							and TipoPess = 'V'

        end
        -- <<< Controlar Baixa de Saída de Veículo de Visitante

      end

    end
   
   
    FIM:	 
    if @erro = 1
    begin
      insert into suricato.TbMarcaRejei ( DataLogProc, ICard, DiaMarc, MesMarc, AnoMarc, HoraMarc, TipoAces, DireAces, BLUEB, CodiColeAlfa, NumeEndeIP, CodiFunc, DescLog, NomeTabeTele, DataAlar, EntrAlar, OcorAlar, NomeListBene, StatDeveBene, SeguMarc, Veic, PesoRefe, ValoKiloRefe, ValoRefe, QuanSobr, NiveAces, FaixHoraRefe, QuanCred, SituCrac, QuanMens )
        values ( convert( numeric( 14, 6 ) , getdate() ), @icard, @diam, @mesm, @anom, @horam, @codac, @posic, @blueb, @codtt, @end_ip, @CodiFunc, @deslog, 'dam00', null, null, null, null, null, @segundo, @veiculo, null, null, null, null, null, null, null, null, null )
    end


    fetch next from cur_dam00_ins_new into @icard, @diam, @mesm, @anom, @horam, @segundo, @codac, @posic, @blueb, @codtt, @end_ip, @CodiFunc, @onoff, @veiculo


  end

  close cur_dam00_ins_new
 
  deallocate cur_dam00_ins_new


GO

-----------------------------------------------------------------------------
-- 2.10.8.0 || 2.10.8.0 || 2.10.8.0 || 2.10.8.0 || 2.10.8.0 || 2.10.8.0 || --
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------------
-- CONEX ACESSO V.38.03.01 || CONEX ACESSO V.38.03.01 || CONEX ACESSO V.38.03.01 ||
-----------------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Create date:		26/11/2019 - 09:29
-- Changed:			26/11/2019 - 09:29
-- Redmine: 		@4720, @4721, @4722, @5071
-----------------------------------------------------------------------------

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'OFFREPPONTO')
	BEGIN
		CREATE TABLE TELESSVR.OFFREPPONTO (
			IFUNC		CHAR(12)	NOT NULL CONSTRAINT acoffrep_ct01 CHECK (IFUNC not like '%[^0-9]%'),
			PIS			CHAR(12)	NOT NULL CONSTRAINT acoffrep_ct02 CHECK (PIS not like '%[^0-9]%'),
			DTAHORAREP	DATETIME  	NOT NULL
		)
		CREATE UNIQUE INDEX OFFREPPONTO_IND1 ON TELESSVR.OFFREPPONTO (IFUNC, PIS)
		CREATE UNIQUE INDEX OFFREPPONTO_IND2 ON TELESSVR.OFFREPPONTO (PIS, IFUNC)
	END
GO

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'DIGLOAD002')
	BEGIN
		CREATE TABLE TELESSVR.DIGLOAD002 (
			END_IP		VARCHAR(15)	DEFAULT '000.000.000.000' NOT NULL,	
			ICARD		CHAR(12)	NOT NULL,
			BIO_TIPO	CHAR(1)		NOT NULL,
			DATA_INS	DATETIME	DEFAULT GETDATE() NOT NULL ,
			NERRO		CHAR(1)		DEFAULT '0'  
		)
	END
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('TrgSitCont_U'))
	DROP TRIGGER TELESSVR.TrgSitCont_U;
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'CONTROLE_IND4')
    DROP INDEX TELESSVR.CONTROLE.CONTROLE_IND4
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'GRUPO')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN GRUPO CHAR(5) -- default '00000'
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'SUBNV')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN SUBNV CHAR(7) -- default '00     '
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'PLANTA')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN PLANTA CHAR(5) -- default '00000'
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'GRUPO1')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN GRUPO1 CHAR(5) -- default '00000'
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'GRUPO2')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN GRUPO2 CHAR(5) -- default '00000'
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'GRUPO3')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN GRUPO3 CHAR(5) -- default '00000'
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'GRUPO_SAB')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN GRUPO_SAB CHAR(5) -- default '00000'
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'GRUPO_DOM')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN GRUPO_DOM CHAR(5) -- default '00000'
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTROLE' AND UPPER(COLUMN_NAME) = 'GRUPO_FER')
	ALTER TABLE TELESSVR.CONTROLE ALTER COLUMN GRUPO_FER CHAR(5) -- default '00000'
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'CONTROLE_IND4')
    CREATE INDEX CONTROLE_IND4 ON TELESSVR.CONTROLE (GRUPO)
GO

CREATE TRIGGER TELESSVR.TrgSitCont_U ON TELESSVR.CONTROLE AFTER UPDATE
AS
DECLARE @ICARD VARCHAR(12)

DECLARE @GRUPO VARCHAR(9), @GRUPO_OLD VARCHAR(9)
DECLARE @GRUPO1 VARCHAR(9), @GRUPO1_OLD VARCHAR(9)
DECLARE @GRUPO2 VARCHAR(9), @GRUPO2_OLD VARCHAR(9)
DECLARE @GRUPO3 VARCHAR(9), @GRUPO3_OLD VARCHAR(9)
DECLARE @GRUPO_SAB VARCHAR(9), @GRUPO_SAB_OLD VARCHAR(9)
DECLARE @GRUPO_DOM VARCHAR(9), @GRUPO_DOM_OLD VARCHAR(9)
DECLARE @GRUPO_FER VARCHAR(9), @GRUPO_FER_OLD VARCHAR(9)
DECLARE @SITUA VARCHAR(1), @SITUA_OLD VARCHAR(1)
DECLARE @VER_DIGIT VARCHAR(1), @VER_DIGIT_OLD VARCHAR(1)

DECLARE CURSOR_UPDT CURSOR FOR
			SELECT ICARD, SITUA, VER_DIGIT, GRUPO, GRUPO1, GRUPO2, GRUPO2, GRUPO_SAB, GRUPO_DOM, GRUPO_FER  
				FROM INSERTED  
				ORDER BY ICARD


				
	IF UPDATE (grupo) OR UPDATE(grupo1) OR UPDATE (grupo2) OR UPDATE(grupo3) OR 
		UPDATE (grupo_sab) OR UPDATE(grupo_dom) OR UPDATE (grupo_fer) OR 
		UPDATE(situa) OR
		UPDATE(ver_digit)

	BEGIN
		OPEN CURSOR_UPDT
		FETCH NEXT FROM CURSOR_UPDT into @ICARD,@SITUA, @VER_DIGIT, @GRUPO, @GRUPO1, @GRUPO2, @GRUPO3, @GRUPO_SAB, @GRUPO_DOM, @GRUPO_FER

		WHILE @@FETCH_STATUS = 0	
		BEGIN

			SET @GRUPO_OLD = (select GRUPO from DELETED where ICARD = @ICARD)
			SET @GRUPO1_OLD = (select GRUPO1 from DELETED where ICARD = @ICARD)
			SET @GRUPO2_OLD = (select GRUPO2 from DELETED where ICARD = @ICARD) 
			SET @GRUPO3_OLD = (select GRUPO3 from DELETED where ICARD = @ICARD) 
			SET @GRUPO_SAB_OLD = (select GRUPO_SAB from DELETED where ICARD = @ICARD)
			SET @GRUPO_DOM_OLD = (select GRUPO_DOM from DELETED where ICARD = @ICARD)
			SET @GRUPO_FER_OLD = (select GRUPO_FER from DELETED where ICARD = @ICARD)
			SET @SITUA_OLD = (select SITUA  from DELETED where ICARD = @ICARD)
			SET @VER_DIGIT_OLD = (select VER_DIGIT  from DELETED where ICARD = @ICARD)

			IF (@SITUA_OLD != @SITUA) OR (@VER_DIGIT_OLD != @VER_DIGIT) BEGIN
				IF (@SITUA = '1') OR (@VER_DIGIT = '1') BEGIN		-- para SITUA '1' INVALIDO  OU VER_DIGIT '1', leva ST '8' para excluir o TEMPLATE de todos os equipamentos
					UPDATE CONTDIG_SAGEM 	SET STATUS = '8' WHERE ICARD = @ICARD;
					UPDATE CONTDIG_TSI1  	SET STATUS = '8' WHERE ICARD = @ICARD;
					UPDATE PALMV001      	SET ST = '8'     WHERE ICARD = @ICARD;
					UPDATE CONTDIG_OUTROS  	SET STATUS = '8' WHERE ICARD = @ICARD;
				END

				ELSE BEGIN
					--IF (@SITUA = '0' OR @SITUA = '7') BEGIN		-- SITUA '0'E '7' VALIDOS
					IF (@SITUA = '0' OR @SITUA = '4' OR @SITUA = '7') AND (@VER_DIGIT = '2')  AND (@SITUA_OLD <> '8') BEGIN		-- SITUA '0'E '7' VALIDOS, '4' = PROVISÓRIO (NO CASO DE MULTITECNOLOGIA)
						UPDATE CONTDIG_SAGEM 	SET STATUS = '3' WHERE ICARD = @ICARD;
						UPDATE CONTDIG_TSI1  	SET STATUS = '3' WHERE ICARD = @ICARD;
						UPDATE PALMV001      	SET ST = '3'     WHERE ICARD = @ICARD;
						UPDATE CONTDIG_OUTROS  	SET STATUS = '3' WHERE ICARD = @ICARD;
					END
					
				END
			END

			ELSE BEGIN	-- houve alteracao no grupo, mesmo que o grupo continue o mesmo
				IF ((CONVERT(INT,@GRUPO_OLD) != CONVERT(INT,@GRUPO)) OR 
					(CONVERT(INT,@GRUPO1_OLD) != CONVERT(INT, @GRUPO1)) OR 
					(CONVERT(INT,@GRUPO2_OLD) != CONVERT(INT,@GRUPO2)) OR 
					(CONVERT(INT,@GRUPO3_OLD) != CONVERT(INT,@GRUPO3)) OR 
					(CONVERT(INT,@GRUPO_SAB_OLD) != CONVERT(INT,@GRUPO_SAB)) OR 
					(CONVERT(INT,@GRUPO_DOM_OLD) != CONVERT(INT,@GRUPO_DOM)) OR 
					(CONVERT(INT,@GRUPO_FER_OLD) != CONVERT(INT,@GRUPO_FER)) ) BEGIN
			
					UPDATE CONTDIG_SAGEM 	SET STATUS = '3' WHERE ICARD = @ICARD AND STATUS != '8';
					UPDATE CONTDIG_TSI1  	SET STATUS = '3' WHERE ICARD = @ICARD AND STATUS != '8';
					UPDATE PALMV001      	SET ST = '3'     WHERE ICARD = @ICARD AND ST != '8';
					UPDATE CONTDIG_OUTROS  	SET STATUS = '3' WHERE ICARD = @ICARD AND STATUS != '8';
				end;
			END
			
			FETCH NEXT FROM CURSOR_UPDT into @ICARD,@SITUA, @VER_DIGIT, @GRUPO, @GRUPO1, @GRUPO2, @GRUPO3, @GRUPO_SAB, @GRUPO_DOM, @GRUPO_FER
		END
		CLOSE CURSOR_UPDT
	END
	DEALLOCATE CURSOR_UPDT
	
GO	

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DAT07_IND3')
    DROP INDEX TELESSVR.DAT07.DAT07_IND3;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'DAT07' AND UPPER(COLUMN_NAME) = 'LACES')
	ALTER TABLE TELESSVR.DAT07 ALTER COLUMN LACES CHAR(5);
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'DAT07' AND UPPER(COLUMN_NAME) = 'PLANTA')
	ALTER TABLE TELESSVR.DAT07 ALTER COLUMN PLANTA CHAR(5) -- DEFAULT '00000'
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DAT07_IND3')
    CREATE INDEX DAT07_IND3 ON TELESSVR.DAT07 (LACES, PLANTA);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DAT08_IND1')
    DROP INDEX TELESSVR.DAT08.DAT08_IND1;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'DAT08' AND UPPER(COLUMN_NAME) = 'GRUPO')
	ALTER TABLE TELESSVR.DAT08 ALTER COLUMN GRUPO CHAR(5);
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'DAT08' AND UPPER(COLUMN_NAME) = 'LACES')
	ALTER TABLE TELESSVR.DAT08 ALTER COLUMN LACES CHAR(5);
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'DAT08' AND UPPER(COLUMN_NAME) = 'PLANTA')
	ALTER TABLE TELESSVR.DAT08 ALTER COLUMN PLANTA CHAR(5); -- DEFAULT '00000'  
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DAT08_IND1')
    CREATE UNIQUE INDEX DAT08_IND1 ON TELESSVR.DAT08 (GRUPO, LACES, PLANTA);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'MATNGRUPOS_IND1')
    DROP INDEX TELESSVR.MATNGRUPOS.MATNGRUPOS_IND1;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'MATNGRUPOS' AND UPPER(COLUMN_NAME) = 'GRUPO')
	ALTER TABLE TELESSVR.MATNGRUPOS ALTER COLUMN GRUPO CHAR(5) -- default '00000'
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'MATNGRUPOS')
    CREATE UNIQUE INDEX MATNGRUPOS_IND1 ON TELESSVR.MATNGRUPOS (ICARD, GRUPO, DIA_TIPO);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'FERIADO_IND1')
    DROP INDEX TELESSVR.FERIADO.FERIADO_IND1;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'FERIADO' AND UPPER(COLUMN_NAME) = 'PLANTA_FER')
	ALTER TABLE TELESSVR.FERIADO ALTER COLUMN PLANTA_FER CHAR(5); -- default '00000'
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'FERIADO_IND1')
    CREATE UNIQUE INDEX FERIADO_IND1 ON TELESSVR.FERIADO (DATA_FER, PLANTA_FER);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'CONTPLANTA_IND1')
    DROP INDEX TELESSVR.CONTPLANTA.CONTPLANTA_IND1;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTPLANTA' AND UPPER(COLUMN_NAME) = 'PLANTACESSO')
	ALTER TABLE TELESSVR.CONTPLANTA ALTER COLUMN PLANTACESSO CHAR(5); -- DEFAULT '00000'
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'CONTPLANTA_IND1')
    CREATE INDEX CONTPLANTA_IND1 ON TELESSVR.CONTPLANTA (ICARD, PLANTACESSO);
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.TRGOFFREPPTOIU'))
	DROP TRIGGER TELESSVR.TRGOFFREPPTOIU
GO

CREATE TRIGGER TELESSVR.TRGOFFREPPTOIU ON TELESSVR.OFFREPPONTO FOR UPDATE, INSERT
AS

declare @NovoDHPto DATETIME;
declare @DHMenor DATETIME
declare @DHMaior DATETIME
declare @cMat VARCHAR(12)
declare @Qtde int

	-- ESTA TRIGGER FARÁ COM QUE A MARCACAO QUE FOI INSERIDA EM OFFREPPONTO SEJA ANALISADA PARA VER VIABILIDADE DE SER INSERIDA EM ULTREPPONTO.
	-- (OBS: A MARCACAO FOI INSERIDA EM OFFREPPONTO E NÃO EM REPPONTO, PORQUE ESTA 'NOVA' MARCACAO É ANTERIOR À QUE ESTÁ EM REPPONTO)
	
	set dateformat dmy
	set @cMat = (select IFUNC from inserted)				-- MATRICULA DO NOVA MARCACAO QUE FOI INSERIDA/ALTERADA EM OFFREPPONTO
	set @NovoDHPto = (select DTAHORAREP from inserted)		-- DATA/HORA DA NOVA MARCACAO QUE FOI INSERIDA/ALTERADA EM OFFREPPONTO

	IF NOT EXISTS (SELECT IFUNC FROM ULTREPPONTO WHERE IFUNC = @cMat) 
		-- insere esta nova marcação, pois ainda nao atingiu a qtde  maxima (8)
		INSERT INTO ULTREPPONTO (IFUNC, DTAHORAREP) VALUES (@cMat, @NovoDHPto);		
						
	ELSE BEGIN
		-- procura pela menor data/hora do usuario
		SET @DHMenor = 	(SELECT MIN(DTAHORAREP) FROM ULTREPPONTO 
							WHERE IFUNC = @cMat GROUP BY IFUNC)		
							
		-- procura pela maior data/hora do usuario
		SET @DHMaior = 	(SELECT MAX(DTAHORAREP) FROM ULTREPPONTO 
							WHERE IFUNC = @cMat GROUP BY IFUNC)		
							
		-- verifica as marcaoes existentes
		IF (@DHMenor = @DHMaior) begin
			-- verifica se é a mesma marcação
			IF (@NovoDHPto != @DHMenor) BEGIN
				-- insere esta nova marcacao de ponto 
				INSERT INTO ULTREPPONTO (IFUNC, DTAHORAREP) VALUES (@cMat, @NovoDHPto);		
			END;
		end
		ELSE begin	-- tem mais de 1 marcação para o usuario, verifica se esta nova marcação já existe ou precisa ser inserida na tabela apos analise de data
			-- procurar pela marcacao  em tabela ULTREPPONTO
			IF NOT EXISTS (SELECT IFUNC  FROM ULTREPPONTO WHERE IFUNC = @cMat AND DTAHORAREP = @NovoDHPto) 
			BEGIN 
				-- verifica quantas marcacoes tem para o mesmo icard
				SET @Qtde = (SELECT COUNT (*) FROM ULTREPPONTO WHERE IFUNC = @cMat)		
				-- verifica se ha 8 marcacoes ou mais
				IF (@Qtde >= 8) begin				-- VERIFICA SE TEM MAIS DE 8 MARCACOES		
					-- verifica se esta nova marcacao é maior do que a menor data para este usuario
					IF (@NovoDHPto > @DHMenor) begin 
						-- atualiza a data mais antiga com esta nova
						UPDATE ULTREPPONTO SET DTAHORAREP = @NovoDHPto 
							WHERE IFUNC = @cMat AND DTAHORAREP = @DHMenor;	
					end
					-- se for menor, nada faz pois já tem  a qtde.maxima (8)
				end
				ELSE
					-- insere esta nova marcação, pois ainda nao atingiu a qtde  maxima (8)
					INSERT INTO ULTREPPONTO (IFUNC, DTAHORAREP) VALUES (@cMat, @NovoDHPto);		
			END							

			-- tem qtde de marcações menor que o máximo (8)
			ELSE begin
				-- insere esta nova marcação, pois ainda nao atingiu a qtde  maxima (8)
				INSERT INTO ULTREPPONTO (IFUNC, DTAHORAREP) VALUES (@cMat, @NovoDHPto);		
			end
		END
	END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.request_lock'))
	DROP PROCEDURE TELESSVR.request_lock
GO

CREATE PROCEDURE TELESSVR.request_lock @cMatric char(12), @cUsuario char(15)
AS

--DECLARE @ret int, @dh_lock char(30), @difsecond int, @cUsuLock char(15)
DECLARE @ret int, @dh_lock datetime, @difsecond int, @cUsuLock char(15)

	set @ret = 0
	
	BEGIN TRAN
	
	-- locka matricula se esta nao estiver lockada
	if NOT EXISTS (SELECT * from TABLOCKS where ICARD = @cMatric) begin
		insert into TABLOCKS (ICARD, DATAHORA, USUARIO) values (@cMatric, getdate(), @cUsuario)
	end

	-- se matricula lockada, verifica se o lock tem validade (menos que 2 SEGUNDOS) (obs: era 10 segundos)
	else begin
		select @dh_lock = DATAHORA, @cUsuLock = USUARIO from TABLOCKS where ICARD = @cMatric
		-- verificar diferenca de minutos
		set @difsecond = DATEDIFF(second, @dh_lock, getdate())
		
		if (@difsecond > 2) begin			-- ERA 60 (SEGUNDOS), depois 10 e agora 2
			-- modifica data e hora do lock
			update TABLOCKS set DATAHORA = getdate(), USUARIO = @cUsuario 
			    where ICARD = @cMatric
		end
		else begin
			if (@cUsuario != @cUsuLock) begin		-- esta situação em que usuario passa ccartao em uma catracat e antes do giro , empresta o cartao a outro usuario para passar em outra catraca
				set @ret = -1     -- lock ativo
			end
		end
	end
	
	COMMIT TRAN
	return (@ret)
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlconG3G5_ace_usuario2'))
	DROP PROCEDURE TELESSVR.sqlconG3G5_ace_usuario2
GO

CREATE PROCEDURE TELESSVR.sqlconG3G5_ace_usuario2 @cMatricNS char(22), @cInform char(20), @cTipTerm char(1), @Usuario char(15), @cOwner char(30), @cDataOcorr char(10), @cVisita char(12) AS
DECLARE	@cReg1 as varchar(250), @cReg2 as varchar(250), @cReg3 as varchar(250), 
		@cReg4 as varchar(250), @RetFun SMALLINT,
		@cReg5 as varchar(250), @cReg6 as varchar(250), @cReg7 as varchar(250), @cReg8 as varchar(250),
		@cReg9 as varchar(250), @cReg10 as varchar(250), @cReg11 as varchar(250)
DECLARE @ret int, @cUsuLock char(15), @cFxDiaEsp char(28), @cFxCred char(4), @Result int, @cMatBusca char(12)
DECLARE	@cIniHalm char(12), @cFimHalm char(12), @cIniIntj char(12), @cFimIntj char(12), @cFimAntD char(12)
DECLARE	@cIniHalmAux char(16), @cFimHalmAux char(16), @cIniIntjAux char(16), @cFimIntjAux char(16), @cFimAntDAux char(16)
DECLARE @dDataBD DATETIME, @dDataOcor DATETIME;
DECLARE @pos int
DECLARE @cModo char(1), @cFazLock char(1), @cDesbloqRev char(1),@cVerNumS char(1)
DECLARE @cVarAux char(12)
DECLARE @nGrest int, @nGrestEquip int, @nCont int
DECLARE @nArea int, @nAreaEquip int
DECLARE	@cEmFixa char(1), @AuxGr char(3), @AuxGr2 varchar(3);
DECLARE @cEscoltado char(12), @cEscolta char(12), @cEndIP char(15), @cTemEsc char(1), @cEhEscolta char(1), @cProcurado char(12), @cSentido CHAR(1)
DECLARE @nContArea int, @cFinalSentido CHAR(1), @AuxSentido CHAR(1), @nAuxArea int
DECLARE @cSituaAux char(1)

DECLARE
        @cMatric   char(12),
        @cIcard    char(12),
        @cCPF	   char(11),
        @cNumSerial	   char(10),
		@cBloqBDCC char(1),
        --@cGrupo    char(3),
        @cCodig    char(6),
        @cTpFis    char(1),
        @cSitua    char(1),
        --@cSubNv    char(5),
        --@cPlanta   char(3),
        @cDataHora char(10),
        @cUltrs    char(25),
        @cDatIni   char(6),
        @cDatFim   char(6),
        @cTitular  char(12),
        @cFx_Flg   char(1), 
        @cFx_Dta   char(11), 
        @cFx_Alm   char(3),
        @cMensagem char(32), 
        @cDta_mens char(6),
        @cQtd_mens char(2),
        @cCred_Fx1 char(2), 
        @cCred_Fx2 char(2),
        @cCred_Fx3 char(2),
        @cCred_Fx4 char(2),
        @cCred_Fx5 char(2),
        @cCred_Fx6 char(2),
        @cFx1 char(8), 
        @cFx2 char(8), 
        @cFx3 char(8), 
        @cFx4 char(8), 
        @cFx5 char(8), 
        @cFx6 char(8), 
        @cUltPasR  char(10),
        --@cGrupo1   char(3),
        @cDatIniG1 char(10),
        @cDatFimG1 char(10),
        --@cGrupo2   char(3),
        @cDatIniG2 char(10),
        @cDatFimG2 char(10),
        --@cGrupo3   char(3),
        @cDatIniG3 char(10),
        @cDatFimG3 char(10),
        --@cGpoSab   char(3),
        --@cGpoDom   char(3),
        --@cGpoFer   char(3),
        @cAnti_D   char(1),
        @cBloq     char(1),
        @cVHora    char(1),
        @cVLocal   char(1),
        @cVValid   char(1),
        @cVAfast   char(1),
        @cVCred    char(1),
        @cVisEsp   char(1),
        @cVPonto   char(1),
        @cPonto    char(1),	
        @cVDigit   char(1),
      	@cTpoIntj  char(3), 
      	@cTolIntj  char(3), 
      	@cInterj   char(1),
      	@cTpoJorn  char(3), 
      	@cSaidaMax   char(1),
      	@cTipoDoc	char(1),
		@cVnDias   char(2),
		@cDiasSuc  char(2),
		@cPne    char(1),
		@cBloqRev    char(1),
		@cvViaRep char(1)

DECLARE
@cGrupo    char(5),	-- novo
@cSubNv    char(7),	-- novo
@cGrupo1   char(5),	-- novo
@cGrupo2   char(5),	-- novo
@cGrupo3   char(5),	-- novo
@cGpoSab   char(5),	-- novo
@cGpoDom   char(5),	-- novo
@cGpoFer   char(5),	-- novo
@cAdBuf VARCHAR(2),			-- novo
@nTamG int,
@cPlanta   char(5)

/*
DECLARE
@cGrupo    varchar(5),	-- novo
@cSubNv    varchar(7),	-- novo
@cGrupo1   varchar(5),	-- novo
@cGrupo2   varchar(5),	-- novo
@cGrupo3   varchar(5),	-- novo
@cGpoSab   varchar(5),	-- novo
@cGpoDom   varchar(5),	-- novo
@cGpoFer   varchar(5),	-- novo
@cAdBuf CHAR(2),			-- novo
@nTamG int,
@cPlanta   varchar(5)
*/


DECLARE @stmt1 nvarchar(4000)
DECLARE @ParmDefinition nvarchar(500);



	SET LOCK_TIMEOUT 1000	
	SET @RetFun = 0
	SET @cReg1  = ''
	SET @cReg2  = ''
	SET @cReg3  = ''
	SET @cReg4  = ''

	SET @cReg5  = ''
	SET @cReg6  = ''
	SET @cReg7  = ''
	SET @cReg8  = ''
	SET @cUsuLock = @Usuario

	SELECT @cAdBuf = null
	SELECT @nTamG = 3 
	SELECT	@nTamG  = COLUNAS.LENGTH
	FROM 
		SYSOBJECTS AS TABELAS,
		SYSCOLUMNS AS COLUNAS
	WHERE 
		-- JOINS 
		TABELAS.ID = COLUNAS.ID
		AND TABELAS.NAME = 'DAT07'
		AND COLUNAS.NAME = 'LACES'


	SET @Result = 1	
	SET @cMatric = substring(@cMatricNS, 1, 12);
	SET @cMatBusca = '000000000000'
	SET @cTipoDoc = '0'
	SET @cBloqBDCC = '0'
	SET @cFx1 = '24002400'
	SET @cFx2 = '24002400'
	SET @cFx3 = '24002400'
	SET @cFx4 = '24002400'
	SET @cFx5 = '24002400'
	SET @cFx6 = '24002400'

	set DATEFORMAT dmy
	SET @dDataOcor = CAST((substring(@cDataOcorr,5,2)+'-'+
							 substring(@cDataOcorr,7,2)+'-'+
							 substring(@cDataOcorr,9,2)+' '+
							 substring(@cDataOcorr,1,2)+':'+
							 substring(@cDataOcorr,3,2)+':'+
							 '00') AS datetime);

	SET @cModo = substring(@cInform, 1, 1);  -- TIPO DE PESQUISA
	-- cModo = 0 :icard; 
	-- cModo = 1 :numero serial
	-- cModo = 2 :cpf
	-- cModo = 3 :bdcc


	SET @cFazLock = 	substring(@cInform, 3, 1);  -- SE CONSULTA ONLINE
	SET @cDesbloqRev = 	substring(@cInform, 4, 1);  -- SE DESBLOQUEIO REVISTA
	SET @cVerNumS = 	substring(@cInform, 5, 1);  -- SE verifica NUMSERIAL
	SET @cEhEscolta =  	substring(@cInform, 6, 1);	-- SE É INDICADOR DE ESCOLTA

	-- *******************************************************
	-- verifica se modo de busca é por CPF
	IF (@cModo ='2') begin					-- CPF
		SELECT	@cIcard   = a.ICARD,
				@cCPF	  = c.CPF,
				@cTipoDoc = c.TIPODOC
				
			FROM ContCPF c 
				INNER JOIN Controle a
					ON c.CPF = substring(@cMatric, 2, 11) and c.icard = a.icard 

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end
	
	-- *******************************************************
	-- verifica se modo de busca é por ICARD
	ELSE IF (@cModo = '0') begin  			-- ICARD
		IF (@cVerNumS = '1') BEGIN
			SELECT	@cIcard   = a.ICARD,
					@cNumSerial  = a.NUMSERIAL
				FROM Controle a 
			WHERE a.ICARD = @cMatric and
   				  a.NumSerial = substring(@cMatricNS, 13, 10) 
				
			IF (@@ROWCOUNT = 0) begin
				-- SITUACAO SURICATO: VARIOS CARTOES SM COM MESMO ICARD, E NA CONTROLE ESTAO OS VALORES DE NUM.SERIAL NA COLUNA ICARD, TODOS COM O MESMO VALOR DO TITULAR
				-- A BUSCA PRIMEIRO SERA FEITA ICARD+NUMSERIAL. SE NÃO ACHOU, QUE É ONDE SE ENCONTRA AGORA, A BUSCA SERÁ SOBRE TITULAR+ICARD. QDO ENCONTRAR, O VALOR DE
				-- CMATBUSCA SERÁ O VALOR DO CAMPO ICARD

				SELECT	@cIcard   = a.TITULAR,
						@cVarAux  = a.ICARD,
						@cSituaAux  = a.SITUA
					FROM Controle a 
				WHERE a.TITULAR = @cMatric and
					  a.ICARD = '00'+substring(@cMatricNS, 13, 10) 

				IF (@@ROWCOUNT = 0) begin
					set @cIcard = '000000000000'	-- 12 zeros
					SET @RetFun = -2
					SET @Result = 0	
				end
				ELSE begin
					-- antes de atribuir @cMatBusca = @cIcard, deve-se verificar se a situação é invalida. 
					-- Se invalida, 	cMatBusca := VarAux, para que retorne situação invalida ao Conex										
					--	SET	@cMatBusca = @cIcard;
					IF (@cSituaAux = '1') 
						SET	@cMatBusca = @cVarAux;	
					ELSE
						SET	@cMatBusca = @cIcard;
				end
			end
			ELSE begin
				SET	@cMatBusca = @cIcard;
			end
		end	

		ELSE begin
			SET @cMatBusca = @cMatric;
		end
	end
				
	-- *******************************************************
	-- verifica se modo de busca é por NUMERO SERIAL
	ELSE IF (@cModo = '1') begin  			-- NUMERO SERIAL
		SELECT	@cIcard   = a.ICARD,
				@cNumSerial  = a.NUMSERIAL
				
			FROM Controle a 
				WHERE a.NumSerial = substring(@cMatric, 3, 10) 
	
		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end


	-- *******************************************************
	-- verifica se modo de busca é por BDCC
	ELSE IF (@cModo = '3') begin  		
		SELECT	@cIcard   = a.ICARD,
				@cBloqBDCC  = c.Bloqueado
				
			FROM bdcc_cracha c 
			INNER JOIN Controle a
				ON c.Cracha = @cMatric and 
				   c.Cracha = a.ICARD  

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end


	-- *******************************************************
	-- verifica se encontrou o usuario, entao coleta informacoes do usuario
	IF (@Result = 1) begin			
		
		-- COLETA faixa horaria do usuario de acordo com o tipo de terminal 
				
		IF (@cTipTerm = '3') begin		  -- TERMINAL TIPO PONTO
			-- colocar 'X' no final de cReg1,cReg2,cReg3 e cReg4 pois o SQL trunca   valores
			-- com campos que contem branco (se o campo for o ultimo a ser concatenado)
			SELECT @cIcard    = a.ICARD,
					   @cReg1 = b.FX_DOM_P + b.FX_SEG_P + b.FX_TER_P + 'X', 
					   @cReg2 = b.FX_QUA_P + b.FX_QUI_P + b.FX_SEX_P + 'X', 
					   @cReg3 = b.FX_SAB_P + b.FX_REF + 'X',
					   --@cReg4 = a.FX_1 + a.FX_2 + a.FX_3 + a.FX_4 + a.FX_5 + a.FX_6 + 'X'
					   @cFx1 = a.FX_1, @cFx2 = a.FX_2, @cFx3 = a.FX_3, @cFx4 = a.FX_4, @cFx5 = a.FX_5, @cFx6 = a.FX_6
					   
			FROM  Controle a
				INNER JOIN  FxHoraria b  
					ON a.ICard = @cMatBusca and b.ICard = a.ICard
		end  			
		
		ELSE begin						-- TERMINAL QUE NAO É PONTO (ACESSO)
			SELECT @cIcard    = a.ICARD,
				   @cReg1 = b.FX_DOM_A + b.FX_SEG_A + b.FX_TER_A + 'X', 
				   @cReg2 = b.FX_QUA_A + b.FX_QUI_A + b.FX_SEX_A + 'X', 
				   @cReg3 = b.FX_SAB_A + b.FX_REF + 'X',
				   --@cReg4 = a.FX_1 + a.FX_2 + a.FX_3 + a.FX_4 + a.FX_5 + a.FX_6 + 'X' 
				   @cFx1 = a.FX_1, @cFx2 = a.FX_2, @cFx3 = a.FX_3, @cFx4 = a.FX_4, @cFx5 = a.FX_5, @cFx6 = a.FX_6
			FROM  Controle a
				INNER JOIN  FxHoraria b  
					ON a.ICard = @cMatBusca and b.ICard = a.ICard
		end

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
		end

		-- *******************************************************
		-- COLETA outros dados do usuario
		ELSE begin
			SELECT	@cIcard   = a.ICARD,
					@cGrupo   = a.GRUPO,
					@cCodig   = a.CODIG,
					@cTpFis   = a.TPFIS, 
					@cSitua   = a.SITUA,
					@cSubNv   = a.SUBNV,
					@cPlanta  = a.PLANTA,
					@cDataHora = a.DATAHORA,
					@cUltrs    = a.ULTRS,
					@cDatIni   = a.DATINI,
					@cDatFim   = a.DATFIM,
					@cTitular  = a.TITULAR,
					@cFx_Flg   = a.FX_FLG,
					@cFx_Dta   = a.FX_DTA,
					@cFx_Alm   = a.TEMPO_ALM,
					@cMensagem = a.MENSAGEM,
					@cDta_mens = a.DTA_MENS, 
					@cQtd_mens = a.QTD_MENS,
					@cCred_Fx1 = a.CRED_FX1,
					@cCred_Fx2 = a.CRED_FX2,
					@cCred_Fx3 = a.CRED_FX3,
					@cCred_Fx4 = a.CRED_FX4,
					@cCred_Fx5 = a.CRED_FX5,
					@cCred_Fx6 = a.CRED_FX6,
					@cUltPasR  = a.ULTPAS_REF,
					@cGrupo1   = a.GRUPO1,
					@cDatIniG1 = a.DATINIG1,
					@cDatFimG1 = a.DATFIMG1,
					@cGrupo2   = a.GRUPO2,
					@cDatIniG2 = a.DATINIG2,
					@cDatFimG2 = a.DATFIMG2,
					@cGrupo3   = a.GRUPO3,
					@cDatIniG3 = a.DATINIG3,
					@cDatFimG3 = a.DATFIMG3,
					@cGpoSab   = a.GRUPO_SAB,
					@cGpoDom   = a.GRUPO_DOM,
					@cGpoFer   = a.GRUPO_FER,
					@cAnti_D   = a.ANTI_DUPLA,
					@cBloq     = a.BLOQ_FALTA,
					@cVHora    = a.VER_HORA,
					@cVLocal   = a.VER_LOCAL,
					@cVValid   = a.VER_VALID,
					@cVAfast   = a.VER_AFAST,
					@cVCred    = a.VER_CRED,
					@cVisEsp   = a.VIS_ESP,
					@cVDigit   = a.VER_DIGIT,

					@cTpoIntj = a.TEMPO_RET,				
					@cTolIntj = a.TOLER_RET,
					@cInterj  = a.VER_RET,

					@cTpoJorn  = a.TEMPO_JORNADA, 
					@cSaidaMax = a.VER_SAIDAMAX,
					@cVnDias   = a.VER_NDIAS,
					@cPne      = a.PNE,
					@cBloqRev  = a.BLOQREV,
					@cvViaRep  = a.VER_VIAREP

				FROM Controle a
					WHERE  a.icard = @cMatBusca

			IF (@@ROWCOUNT = 0) begin
				set @cIcard = '000000000000'	-- 12 zeros
				SET @RetFun = -2
			end

			-- *******************************************************
			-- locka usuario se necessario
			ELSE begin
				IF (@cSitua = '4') or (@cFazLock = '0') begin 	-- se Provisorio, não 'bloqueia'. Sera 'bloqueado' o Titular
					set @ret = 0
				end
				ELSE begin
					SET @stmt1 = 'execute @p1 = ' + @cOwner + '.request_lock @cMat, @cUsu'
					SET @ParmDefinition = N'@cMat nvarchar(30), @cUsu CHAR(15), @p1 int OUTPUT ';		
					EXEC sp_executesql @stmt1, 
									@ParmDefinition, 
									@cMat = @cMatric, 
									@cUsu = @Usuario,
									@p1 = @ret OUTPUT		
				end		
	
				-- *******************************************************
				-- verifica se dados são nulos para preencher com valores default
				IF (@ret = 0) begin
					SET @cFxDiaEsp = SPACE(28);
					SET @cFxCred   = SPACE(4);
					-- Armazena dados da matricula em Registro
					-- colocar 'X' no final de cReg1, cReg2 e cReg3 pois o SQL trunca            -- valores com campos que contem branco (se o campo for o ultimo a ser       -- concatenado)
					if (@cCodig is Null) 
						SET @cCodig = SPACE(6);
					if (@cTpFis is Null) 
						SET @cTpFis = SPACE(1);
					if (@cSubNv is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cSubNv = '00'+SPACE(3);	-- 3 espacos
						ELSE
							SET @cSubNv = '00'+SPACE(5);	-- 5 espacos
					END
						
					if (@cPlanta is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cPlanta = '000';		--3
						ELSE
							SET @cPlanta = '00000';		-- 5 
					END

					if (@cDataHora is Null) 
						SET @cDataHora = '3112202359';
					if (@cUltrs is Null) 
						SET @cUltrs = '0101902359'+SPACE(10);
					if (@cFx_Flg is Null)  
						SET @cFx_Flg = '0';		-- 1 
					if (@cFx_Dta is Null)  
						SET @cFx_Dta = SPACE(11);
					if (@cFx_Alm is Null)  
						SET @cFx_Alm = SPACE(3);
					if (@cDatIni is Null) 
						SET @cDatIni = SPACE(6);
					if (@cDatFim is Null) 
						SET @cDatFim = SPACE(6);
					if (@cTitular is Null) 
						SET @cTitular = SPACE(12);
					if (@cMensagem is Null)  
						SET @cMensagem = SPACE(32);
					if (@cDta_mens is Null)  
						SET @cDta_mens = SPACE(6);
					if (@cQtd_mens is Null)  
						SET @cQtd_mens = SPACE(2);
					if (@cCred_Fx1 is Null)  
						SET @cCred_Fx1 = '00';		-- 2
					if (@cCred_Fx2 is Null)  
						SET @cCred_Fx2 = '00';		-- 2
					if (@cCred_Fx3 is Null)  
						SET @cCred_Fx3 = '00';		-- 2
					if (@cCred_Fx4 is Null)  
						SET @cCred_Fx4 = '00';		-- 2
					if (@cCred_Fx5 is Null)  
						SET @cCred_Fx5 = '00';		-- 2
					if (@cCred_Fx6 is Null)  
						SET @cCred_Fx6 = '00';		-- 2
					if (@cUltPasR is Null)  
						SET @cUltPasR = SPACE(10);

					if (@cGrupo1 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo1 = '000';	-- 3 
						ELSE
							SET @cGrupo1 = '00000'	-- 5 
					END
					if (@cDatIniG1 is Null) 
						SET @cDatIniG1 = SPACE(10);
					if (@cDatFimG1 is Null) 
						SET @cDatFimG1 = SPACE(10);

					if (@cGrupo2 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo2 = '000';	-- 3 
						ELSE
							SET @cGrupo2 = '00000'	-- 5 
					END
					if (@cDatIniG2 is Null) 
						SET @cDatIniG2 = SPACE(10);
					if (@cDatFimG2 is Null) 
						SET @cDatFimG2 = SPACE(10);
					
					if (@cGrupo3 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo3 = '000';	-- 3 
						ELSE
							SET @cGrupo3 = '00000'	-- 5 
					END
					if (@cDatIniG3 is Null) 
						SET @cDatIniG3 = SPACE(10);
					if (@cDatFimG3 is Null) 
						SET @cDatFimG3 = SPACE(10);

					if (@cGpoSab is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoSab = '000';	-- 3 
						ELSE
							SET @cGpoSab = '00000'	-- 5 
					END

					if (@cGpoDom is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoDom = '000';	-- 3 
						ELSE
							SET @cGpoDom = '00000'	-- 5 
					END

					if (@cGpoFer is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoFer = '000';	-- 3 
						ELSE
							SET @cGpoFer = '00000'	-- 5 
					END

					if (@cVisEsp is Null) 
						SET @cVisEsp = '0';		-- 1
					if (@cVDigit is Null) 
						SET @cVDigit = '2';		-- 1
					if (@cTpoIntj is Null) 
						SET @cTpoIntj = '000';		-- 3
					if (@cTolIntj is Null)
						SET @cTolIntj = '000';		-- 3
					if (@cInterj is Null)
						SET @cInterj = '0';		-- 1 
					if (@cTpoJorn is Null)
						SET @cTpoJorn = '000';		-- 3
					if (@cSaidaMax is Null)
						SET @cSaidaMax = '0';		-- 1 
					if (@cTipoDoc is Null)
						SET @cTipoDoc = '2';		-- 1 

					if (@cVnDias is Null) 
						SET @cVnDias = '00';		-- 2

					if (@cPne is Null)
						SET @cPne = '0';		-- 1 
					if (@cBloqRev is Null)
						SET @cBloqRev = '0';		-- 1 
					if (@cvViaRep is Null)
						SET @cvViaRep = '0';		-- 1 

					if (@cFx1 is Null)
						SET @cFx1 = '24002400';		-- 8 
					if (@cFx2 is Null)
						SET @cFx2 = '24002400';		-- 8 
					if (@cFx3 is Null)
						SET @cFx3 = '24002400';		-- 8 
					if (@cFx4 is Null)
						SET @cFx4 = '24002400';		-- 8 
					if (@cFx5 is Null)
						SET @cFx5 = '24002400';		-- 8 
					if (@cFx6 is Null)
						SET @cFx6 = '24002400';		-- 8 


					IF (@nTamG = 3) 
						SELECT @cAdBuf = SPACE(2);		-- 2 espços
					ELSE
						SELECT @cAdBuf = null


					SET @cReg4 = @cFx1 + @cFx2 + @cFx3 + @cFx4 + @cFx5 + @cFx6 + 'X'
					
					SET @cReg5 = @cIcard + @cGrupo + 
								 @cCodig + @cTpFis + @cSitua + @cSubNv + 
								 @cPlanta + 
								 'X'
					
					/*
					SET @cReg5 = @cIcard + @cGrupo + COALESCE(@cAdBuf, '') + 
								 @cCodig + @cTpFis + @cSitua + @cSubNv + COALESCE(@cAdBuf, '') + 
								 @cPlanta + COALESCE(@cAdBuf, '') + 'X'
					*/
					

					SET @cReg6 = substring(@cDataHora,1,10) + @cUltrs + @cFx_Flg + @cFx_Dta + @cFx_Alm + 
								 @cFxDiaEsp + @cDatIni + @cDatFim + @cMensagem + @cDta_mens + @cQtd_mens  + 
								 @cCred_Fx1 + @cFxCred +
								 @cCred_Fx2 + @cFxCred +
								 @cCred_Fx3 + @cFxCred +
								 @cCred_Fx4 + @cFxCred +
								 @cCred_Fx5 + @cFxCred +
								 @cCred_Fx6 + @cFxCred +
								 @cUltPasR + @cTitular  + 'X'
								 
					SET @cReg7 = @cGrupo1 + @cDatIniG1 + @cDatFimG1 +
								 @cGrupo2 + @cDatIniG2 + @cDatFimG2 +
								 @cGrupo3 + @cDatIniG3 + @cDatFimG3 +
								 @cGpoSab + 
								 @cGpoDom + 
								 @cGpoFer + 
								 @cAnti_D + @cBloq + @cVHora + @cVLocal +
								 @cVValid + @cVAfast + @cVCred + @cVisEsp + 'X'


					/*
					SET @cReg7 = @cGrupo1 + COALESCE(@cAdBuf, '') + @cDatIniG1 + @cDatFimG1 +
								 @cGrupo2 + COALESCE(@cAdBuf, '') + @cDatIniG2 + @cDatFimG2 +
								 @cGrupo3 + COALESCE(@cAdBuf, '') + @cDatIniG3 + @cDatFimG3 +
								 @cGpoSab + COALESCE(@cAdBuf, '') + 
								 @cGpoDom + COALESCE(@cAdBuf, '') + 
								 @cGpoFer + COALESCE(@cAdBuf, '') + 
								 @cAnti_D + @cBloq + @cVHora + @cVLocal +
								 @cVValid + @cVAfast + @cVCred + @cVisEsp + 'X'
					*/					


					IF (@cDesbloqRev = '1')  
						SET @cBloqRev = '0'
					

					--SET @cReg8 = @cIcard + '0' + '0' + @cVDigit + 
					SET @cReg8 = @cIcard + @cvViaRep + '0' + @cVDigit + 
								 @cTpoIntj + @cTolIntj + @cInterj + 
								 @cTpoJorn + @cSaidaMax + 
								 @cTipoDoc + '00' + @cVnDias + 
								 --@cPne + @cBloqRev + 'X'
								 @cPne + @cBloqRev
				end
				-- matricula ja lockada
				ELSE
					SET @RetFun = -3
			end
		end
	END

	SET DATEFORMAT dmy
	SELECT @cIniHalmAux = CONVERT(char(8), a.Ini_Halm, 3)+ CONVERT(char(8), a.Ini_Halm, 8),
		   @cFimHalmAux = CONVERT(char(8), a.Fim_Halm, 3)+ CONVERT(char(8), a.Fim_Halm, 8),
		   @cIniIntjAux = CONVERT(char(8), a.Ini_Intj, 3)+ CONVERT(char(8), a.Ini_Intj, 8),
		   @cFimIntjAux = CONVERT(char(8), a.Fim_Intj, 3)+ CONVERT(char(8), a.Fim_Intj, 8),
		   @cFimAntDAux = CONVERT(char(8), a.Fim_AntiD, 3)+ CONVERT(char(8), a.Fim_AntiD, 8) ,
		   @cDiasSuc = a.Dias_Suc   
		   
	FROM DATAHORA a 
	WHERE a.ICARD = @cMatBusca
	
	IF (@@ROWCOUNT = 0) begin
  		SET @cIniHalm = '010106000000'	-- 01/01/06
		SET @cFimHalm = '010106000000'	-- 01/01/06
		SET @cIniIntj = '010106000000'	-- 01/01/06
		SET @cFimIntj = '010106000000'	-- 01/01/06
		SET @cFimAntD = '010106000000'	-- 01/01/06
		SET @cDiasSuc = '00';
	end
	ELSE begin
		SET @cIniHalm = substring (@cIniHalmAux,1,2)+substring (@cIniHalmAux, 4,2)+substring (@cIniHalmAux, 7,2)+
						substring (@cIniHalmAux,9,2)+substring (@cIniHalmAux,12,2)+substring (@cIniHalmAux,15,2)
		SET @cFimHalm = substring (@cFimHalmAux,1,2)+substring (@cFimHalmAux, 4,2)+substring (@cFimHalmAux, 7,2)+
						substring (@cFimHalmAux,9,2)+substring (@cFimHalmAux,12,2)+substring (@cFimHalmAux,15,2)
		SET @cIniIntj = substring (@cIniIntjAux,1,2)+substring (@cIniIntjAux, 4,2)+substring (@cIniIntjAux, 7,2)+
						substring (@cIniIntjAux,9,2)+substring (@cIniIntjAux,12,2)+substring (@cIniIntjAux,15,2)
		SET @cFimIntj = substring (@cFimIntjAux,1,2)+substring (@cFimIntjAux, 4,2)+substring (@cFimIntjAux, 7,2)+
						substring (@cFimIntjAux,9,2)+substring (@cFimIntjAux,12,2)+substring (@cFimIntjAux,15,2)
		SET @cFimAntD = substring (@cFimAntDAux,1,2)+substring (@cFimAntDAux, 4,2)+substring (@cFimAntDAux, 7,2)+
						substring (@cFimAntDAux,9,2)+substring (@cFimAntDAux,12,2)+substring (@cFimAntDAux,15,2)
	END
	
	SET @cReg9 = @cIcard + @cIniHalm + @cFimHalm + @cIniIntj + @cFimIntj + @cFimAntD + @cDiasSuc + 'X';

	--SET @cReg10 = @cBloqBDCC + 'X';
	SET @cReg10 = @cBloqBDCC;

	-- *******************************************************
	-- atualiza tab.CONTROLE se o usuario foi liberado pelo equipamento para revista
	IF (@RetFun = 0 AND 
		@Result = 1 AND 
		@cDesbloqRev = '1') begin
			IF (@cFazLock = '0') begin				-- marcacao offline
				SET @pos = CHARINDEX(' ', @cUltrs);  	-- VERIFICA SE data armazenada em BD tem valor em branco

				IF (@pos <= 10) and (@pos > 0) 
					SET @dDataBD = @dDataOcor;		-- assume temporariamente a mesma data de ocorrencia para que haja tualização
				ELSE begin
					set DATEFORMAT dmy
					SET @dDataBD = CAST((substring(@cUltrs,1,2)+'-'+substring(@cUltrs,3,2)+'-'+substring(@cUltrs,5,2)+' '+
							 			 substring(@cUltrs,7,2)+':'+substring(@cUltrs,9,2)+':'+'00') AS datetime);					
				end
				
				IF (@dDataOcor >= @dDataBD) 			-- atualiza BD porque a marcacao offline é mais recente que está em BD
					UPDATE CONTROLE SET BLOQREV = '0' WHERE ICARD = @cMatBusca;
			end
			ELSE
				UPDATE CONTROLE SET BLOQREV = '0' 
					WHERE ICARD = @cMatBusca
	end		
				
	-- *******************************************************
	-- verifica grupo do Estacionamento
	SET @nGrest = 0;
	SET @nGrestEquip = 0;
	SET @cEmFixa = '0';
	
	SELECT @nGrest = convert(int, GREST)  			-- VERIFICA SE O EQUIPAMENTO PERTENCE A ALGUM ESTACIONAMENTO
		FROM ESTAC001 
		WHERE END_IP = @Usuario;
	
	IF (@@ROWCOUNT = 0) begin
		SET @nGrest = 0;
		SET @nGrestEquip = 0;
	end			
	ELSE begin
		SET @nGrestEquip = @nGrest;
		
		SELECT @cEmFixa = EMFIXA   					-- VERIFICA SE A MATRICULA POSSUI VAGA FIXA NESTE ESTACIONAMENTO
			FROM ESTAC003 
			WHERE ICARD = @cMatBusca AND GREST = @nGrest;
			
		IF (@@ROWCOUNT = 0)			
			SET @nGrest = 0;
	END;


	SET @AuxGr2 = convert(char, @nGrest);
	SET @AuxGr = REPLICATE('0',3-LEN(@AuxGr2) ) + @AuxGr2;
	SET @cReg8 = @cReg8 + @AuxGr;								-- grupo de estacionamento do qual o usuario tem vaga fixa
	SET @cReg8 = @cReg8 + @cEmFixa + 'X';						-- indicador se estacionou em vaga fixa

	SET @AuxGr2 = convert(char, @nGrestEquip);
	SET @AuxGr = REPLICATE('0',3-LEN(@AuxGr2) ) + @AuxGr2;			-- grupo de estacionamento ao qual o equipamento faz parte
	SET @cReg10 = @cReg10 + @AuxGr + 'X'		-- posic 1 a 3		



	-- *******************************************************
	-- verifica Area de ESCOLTA
	SET @cTemEsc = '0'

	IF (@cEhEscolta = '0')		-- não é a escolta
	BEGIN
		SET @cProcurado = @cMatBusca
		SET @nContArea = 0
		SET @cFinalSentido = '0'
		
		SET @cEscoltado = @cMatBusca
		SET @cEscolta = '000000000000'
		SET @cTemEsc = '0'
		SET @cSentido = '0'
	
		
		DECLARE escolt_cur CURSOR FOR
			SELECT AREA, SENTIDO FROM ESCOLT002 
				WHERE END_IP = @Usuario
				ORDER by AREA;

		OPEN escolt_cur
		FETCH next from escolt_cur into @nAuxArea, @AuxSentido
		WHILE (@@fetch_status != -1)
		BEGIN
			SET @nContArea = @nContArea + 1
		
			-- localiza a AREA e MATRICULA NA TABELA DE PESSOAS A SEREM ESCOLTADAS
			IF EXISTS (
				SELECT ICARD_ESCOLTADO, AREA 
					FROM ESCOLT001 
					WHERE ICARD_ESCOLTADO = @cProcurado AND
						  AREA = @nAuxArea)

			BEGIN
				SET @cFinalSentido = 
				CASE 
					WHEN @cFinalSentido = '0' 
						THEN ( @AuxSentido)
					WHEN @cFinalSentido = '1' AND (@AuxSentido = '2' OR  @AuxSentido = '3') 
						THEN '3'
					WHEN @cFinalSentido = '2' AND (@AuxSentido = '1' OR  @AuxSentido = '3')
						THEN '3'
						ELSE @cFinalSentido
				END
					
				SET @cTemEsc = '1'
				SET @cSentido = @cFinalSentido
			END
			
			FETCH next from escolt_cur into @nAuxArea, @AuxSentido
		END
		
		CLOSE escolt_cur
		DEAllocate escolt_cur
	END


	-- É A ESCOLTA
	ELSE BEGIN
	
		SET @nContArea = 0
		SET @cEscoltado = @cVisita
		SET @cEscolta = '000000000000'
		SET @cTemEsc = '0'
		SET @cSentido = '0'
	
		DECLARE escolt_cur CURSOR FOR
			SELECT AREA FROM ESCOLT002 
				WHERE END_IP = @Usuario
				ORDER by AREA;

	
		OPEN escolt_cur
		FETCH next from escolt_cur into @nAuxArea
		WHILE (@@fetch_status != -1)
		BEGIN
			SET @nContArea = @nContArea + 1
		
			-- VERIFICA SE A MATRICULA É AUTORIZADA A SER  ESCOLTA 

			IF EXISTS (
				SELECT ICARD_ESCOLTADO, AREA 
					FROM ESCOLT001 
					WHERE ICARD_ESCOLTADO = @cVisita AND
					   	  ICARD_GUARDA = @cMatBusca AND 
					      AREA = @nAuxArea)
			BEGIN
				SET @cEscoltado = @cVisita;
				SET @cEscolta = @cMatBusca;
				SET @cTemEsc = '0'	
				--SET @@fetch_status  = -1
				BREAK
			END
			ELSE
				FETCH next from escolt_cur into @nAuxArea
		END
		CLOSE escolt_cur
		DEAllocate escolt_cur
	END

	
	SET @cReg11 = @cEscoltado + @cEscolta + @cTemEsc + @cSentido + 'X';

	


	SET LOCK_TIMEOUT -1		
	
	SELECT @RetFun, 
		@cReg1, 
		@cReg2, 
		@cReg3, 
		@cReg4, 
		@cReg5, 
		@cReg6, 
		@cReg7, 
		@cReg8, 
		@cReg9,
		@cReg10,
		@cReg11,
		@nTamG		
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqldig_rejeit'))
	DROP PROCEDURE TELESSVR.sqldig_rejeit
GO

CREATE PROCEDURE TELESSVR.sqldig_rejeit @cDigRejeit CHAR(255)
AS

DECLARE @Ret smallint 
DECLARE @cEndIP CHAR(15), @cMat CHAR(12), @dDataHora DATETIME, @cDtHora char(12), @cBioTipo char(1), @cErro char(1)


	SET @Ret = 0
	SET @cEndIP 	= SUBSTRING (@cDigRejeit, 1, 15);
	SET @cMat 		= SUBSTRING (@cDigRejeit, 16, 12);
	SET @cDtHora	= SUBSTRING (@cDigRejeit, 28, 12);
	SET @cBioTipo 	= SUBSTRING (@cDigRejeit, 40, 1);
	SET @cErro 		= SUBSTRING (@cDigRejeit, 41, 1);
	
	SET @dDataHora = CAST((substring(@cDtHora,1,2)+'-'+substring(@cDtHora,3,2)+'-'+substring(@cDtHora,5,2)+' '+
			 			 substring(@cDtHora,7,2)+':'+substring(@cDtHora,9,2)+':'+substring(@cDtHora,11,2)) 
			 			 AS datetime);					


	INSERT INTO DIGLOAD002 (END_IP, ICARD, BIO_TIPO, DATA_INS, NERRO) 
					VALUES (@cEndIP , @cMat, @cBioTipo, @dDataHora, @cErro);

	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlresp_autopalmv'))
	DROP PROCEDURE TELESSVR.sqlresp_autopalmv
GO

CREATE PROCEDURE TELESSVR.sqlresp_autopalmv  @cMatric CHAR(12), @cEndIp CHAR(15), @cStatus CHAR(1), @cErro CHAR(1) AS

DECLARE @Ret smallint, @cBioTipo CHAR(1), @ERR INT  , @cAux char(12)

	SET @Ret = 0
	SET LOCK_TIMEOUT 2000
	SET @cBioTipo = 'A';	
	
				  
	UPDATE PALMV014	 SET STATUS = @cStatus 
			where ICARD = @cMatric and
				  END_CTRLPALMV = @cEndIp;
	
	IF (@cStatus = '0') 		-- NAOU HOUVE ERRO NA CARGA
		INSERT INTO HISTDIG (IFUNC, END_IP, BIO_TIPO, INSEXC, MODO) VALUES (@cMatric, @cEndIp, @cBioTipo, 'I', 'A')	-- TIPO:'I'= INCLUSAO, 'E'=EXCLUSAO; MODO:'A'=AUTOMATICO, 'M'=MANUAL

	ELSE begin	-- HOUVE ERRO NA CARGA, INSERE NA TABELA DE ERROS DIGLOAD001
		IF (@cStatus = '4')
			INSERT INTO DIGLOAD001 (END_IP, ICARD, BIO_TIPO, NERRO) VALUES (@cEndIp, @cMatric, @cBioTipo, @cErro);
	end
		

	UPDATE PALMV004 SET DATA_LOAD = getdate() where END_CTRLPALMV = @cEndIp
	
	
	SET LOCK_TIMEOUT -1
	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlfim_LdigPalmv'))
	DROP PROCEDURE TELESSVR.sqlfim_LdigPalmv
GO

CREATE PROCEDURE TELESSVR.sqlfim_LdigPalmv  @cEndIp CHAR(15), @cStatus CHAR(1) AS

DECLARE @Ret smallint, @ERR INT  , @cAux char(12)

	SET @Ret = 0
	SET LOCK_TIMEOUT 2000

	UPDATE PALMV004 set STATUS = @cStatus
			where END_CTRLPALMV = @cEndIp;
				  
	SET LOCK_TIMEOUT -1
	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.G3G5_PREP2_SAGEM'))
	DROP PROCEDURE TELESSVR.G3G5_PREP2_SAGEM
GO

CREATE PROCEDURE TELESSVR.G3G5_PREP2_SAGEM AS

DECLARE @c_status CHAR(1)
DECLARE @c_icard CHAR(12)

DECLARE @xc_status CHAR(1)
DECLARE @xc_icard CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @xc_tipobio CHAR(1)
DECLARE @ret CHAR(1)

DECLARE @z_endip CHAR(15)
DECLARE @nCont SMALLINT
DECLARE @nAchouGrupo SMALLINT

SET DATEFORMAT YMD


	set @ret = 0

	-- cursor para matriculas cujas digitais foram alteradas
	DECLARE cur_stdigital CURSOR FOR (select ICARD, STATUS from CONTDIG_SAGEM WHERE STATUS = '1' or STATUS = '3' or STATUS = '8')

	OPEN cur_stdigital
	FETCH NEXT FROM cur_stdigital INTO @c_icard, @c_status
	while @@fetch_status != -1
	begin
	
		SET @nAchouGrupo = 0		-- presupoe q nao tem icard x grupo correspondente em tab 
	
		-- *************************************************************************
		-- prepara os ids excluidos (controle.situa = invalido) ou grupos da controle alterados, retirando as digitais de todos os equipamentos 
		IF (@c_status = '3') or (@c_status = '8') BEGIN			-- alterados grupos (3) ou (situa invalidos ou  ver_digit nao confere)  (8)

			-- MONTA temporaria matricula x equipamentos cadastrados
			INSERT INTO TMP_DIG101 (ICARD, END_IP, STATUS, BIO_TIPO) 		
				SELECT distinct @c_icard, DAT07.END_IP, '0', DAT07.BIO_TIPO 
				FROM DAT07 
				WHERE BIO_TIPO = '6' or BIO_TIPO = '7';

	
			-- *****************************************************************
			-- COMO ESTA EXCLUINDO O FUNCIONARIO DA EMPRESA (CONTROLE.SITUA = '1' INVALIDO), TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN
			-- COMO ALTEROU O GRUPO, TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN

			--DELETE FROM DIG001 WHERE ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1')

			-- VAI DELETAR A MATRICULA DE QUALQUER STATUS PORQUE PODE CAIR NA SITUACAO EM QUE HA INCLUSAO DA MATRICULA, MAS NAO VAI PORQUE O EQUIPAMENTO 'ESTA OCUPADO' (nova resposta do microdimarms).
			-- SE HOUVER POSTERIORMENTE EXCLUSAO DESSA MESMA MATRICULA, DEVE=-SE EXCLUIR A INCLUSAO DESSA MATRICULA DA TABELA
			DELETE FROM DIG001 WHERE ICARD = @c_icard
			
		
		END	

		IF (@c_status = '1') or (@c_status = '3') BEGIN		-- incluido/alterado BIOMETRIA (1)   ou   alterados grupos (3) 

			-- ******************************************************************
			-- para todos icards q alteraram digital, distribui nos equipamentos de acordo com o grupo cadastrado em 
			-- CONTROLE, DAT07,DAT08 
			-- MONTA temporaria matricula com codins com permissao acesso
			
			insert into TMP_DIG001 (ICARD, END_IP, STATUS, BIO_TIPO)
			SELECT distinct A.icard,  A.end_ip, A.st, A.bio_tipo
				FROM 
					-- seleciona os equipamentos que fazem parte dos grupos do usuário
					(SELECT distinct @c_icard as 'icard',  dat07.end_ip, '0' as 'st', dat07.bio_tipo
						from dat07, dat08 
						where
							dat07.end_ip <> '000.000.000.000' and
							CONVERT(int,dat08.grupo) in (
								select CONVERT(int,grupo) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1') 		-- equipamentos do grupo , situa diferente de invalido, e verifica digital
								  union
								select CONVERT(int,grupo1) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union	
								select CONVERT(int,grupo2) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo3) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_sab) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_dom) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_fer) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,A.grupo) from MATNGRUPOS A, CONTROLE B where A.ICARD = @c_icard  AND B.ICARD = @c_icard AND (B.SITUA <> '1') and (B.VER_DIGIT <> '1')
								) and
							CONVERT(int,dat07.laces) = CONVERT(int,dat08.laces) and
							CONVERT(int,dat07.planta) = CONVERT(int,dat08.planta) and
							(dat07.bio_tipo = '6' or dat07.bio_tipo = '7')  
				UNION
					SELECT distinct @c_icard as 'icard',  dat07.end_ip, '0' as 'st', dat07.bio_tipo
						from dat07, MATCODIN 
						where
							matcodin.icard = @c_icard and
							matcodin.end_ip <> '000.000.000.000' and 
							matcodin.end_ip = dat07.end_ip and 
							(dat07.bio_tipo = '6' or dat07.bio_tipo = '7') ) as A

			-- para quem incluiu/alterou digital (status 1) ou mudou de grupo (status 3)
			--IF (@c_status = '3') BEGIN
			IF (@c_status = '1') OR (@c_status = '3') BEGIN
			
				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao temporaria os equipamentos que fazem parte do novo grupo

				DELETE FROM TMP_DIG101
					WHERE EXISTS
						(SELECT TMP_DIG001.icard 
							FROM 
								TMP_DIG001
							WHERE 
								TMP_DIG001.icard = TMP_DIG101.icard and
								TMP_DIG001.END_IP = TMP_DIG101.END_IP and
							  	TMP_DIG001.icard = @c_icard
					);

				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao final os equipamentos do ID em questão, para REFAZER a tabela
				--DELETE from DIG101 where ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1')
				
				-- VAI DELETAR A MATRICULA DE QUALQUER STATUS PORQUE PODE CAIR NA SITUACAO EM QUE HA EXCLUSAO DA MATRICULA, MAS NAO VAI PORQUE O EQUIPAMENTO ESTA OCUPADO.
				-- SE HOUVER POSTERIORMENTE INCLUSAO DESSA MESMA MATRICULA, DEVE=-SE EXCLUIR A EXCLUSAO DESSA MATRICULA DA TABELA
				DELETE from DIG101 where ICARD = @c_icard 
			END

		END


		-- ******************************************************************
		-- PREPARA TABELA TEMPORARIA DE INCLUSAO COM OS ENDEREÇOS IP 
		SET @nCont = (SELECT COUNT(*) FROM TMP_DIG001)

		-- verifica se a matricula esta cadastrada em controle e se pertence a alguma codin. 
		-- Caso negativo, seu status ainda continua setado até que seja cadastrada e pertença a algum local de acesso
		if (@nCont != 0) begin

			-- insere icard-codin em tab. DIG001, se não existir em tab.
			DECLARE cur_tmpdigital CURSOR FOR (select ICARD, END_IP, STATUS, BIO_TIPO from TMP_DIG001)
			OPEN cur_tmpdigital
			FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio

			WHILE @@fetch_status != -1 BEGIN
				UPDATE DIG001 SET STATUS = '1' 
					WHERE  ICARD = @xc_icard AND
						   END_IP = @xc_endip
				if @@rowcount = 0
				begin		
					INSERT INTO DIG001 (ICARD, END_IP, STATUS, BIO_TIPO) 
						values (@xc_icard, @xc_endip, '1', @xc_tipobio);
				end

				FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio
			end
			
			
			SET @nAchouGrupo = 1;
			
			-- coloca o codin na tab. DIG002 (CARGA LISTA) o codin não existir
			insert into DIG002 (END_IP, DATA_LOAD, STATUS, BIO_TIPO)
				select distinct end_ip, getdate(), '0', bio_tipo  
				from
					-- tmp_dig001
					DIG001
				where
					end_ip not in ( select end_ip from DIG002 );
			
			
			CLOSE cur_tmpdigital
			DEALLOCATE cur_tmpdigital
		end

		-- ******************************************************************
		-- PREPARA TABELA TEMPORARIA DE EXCLUSAO COM OS ENDEREÇOS IP DOS EQUIPAMENTOS
		SET @nCont = (SELECT COUNT(*) FROM TMP_DIG101)
		IF (@nCont != 0) BEGIN

			-- insere na tabela final DIG101  os ID COM STATUS de carga (0 / 1= a excluir)
			DECLARE cur_tmpdigital CURSOR FOR (select ICARD, END_IP, STATUS, BIO_TIPO from TMP_DIG101)
			OPEN cur_tmpdigital
			FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio

			WHILE @@fetch_status != -1 BEGIN
				UPDATE DIG101 SET STATUS = '1' 
					WHERE  ICARD = @xc_icard AND
						   END_IP = @xc_endip
				if @@rowcount = 0
				begin		
					INSERT INTO DIG101 (ICARD, END_IP, STATUS, BIO_TIPO) 
						values (@xc_icard, @xc_endip, '1', @xc_tipobio);
				end

				FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio
			end
			
			SET @nAchouGrupo = 1;

			-- coloca o equipamento na tab. DIG102 (CARGA LISTA) o equipamento q não existir
			insert into DIG102 (END_IP, DATA_LOAD, STATUS, BIO_TIPO)
				select distinct END_IP, GETDATE(), '0', BIO_TIPO
				from
					DIG101
				where
					END_IP not in ( select END_IP from DIG102 );
							
			CLOSE cur_tmpdigital
			DEALLOCATE cur_tmpdigital
		END	

		-- atualiza status da matricula, como tratado
		IF (@nAchouGrupo = 1) 	
			update CONTDIG_SAGEM SET STATUS = '0' 
				where ICARD = @c_icard;
			
		DELETE TMP_DIG001
		DELETE TMP_DIG101

		
		FETCH NEXT FROM cur_stdigital INTO @c_icard, @c_status
	end
	CLOSE cur_stdigital
	deallocate cur_stdigital

GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.G3G5_PREP2_TSI1'))
	DROP PROCEDURE TELESSVR.G3G5_PREP2_TSI1
GO

CREATE PROCEDURE TELESSVR.G3G5_PREP2_TSI1 AS

DECLARE @c_status CHAR(1)
DECLARE @c_icard CHAR(12)

DECLARE @xc_status CHAR(1)
DECLARE @xc_icard CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @xc_tipobio CHAR(1)
DECLARE @ret CHAR(1)

DECLARE @z_endip CHAR(15)
DECLARE @nCont SMALLINT
DECLARE @nAchouGrupo SMALLINT
DECLARE @aux_icard CHAR(12)          


SET DATEFORMAT YMD


	set @ret = 0

	-- cursor para matriculas cujas digitais foram alteradas
	DECLARE cur_stdigital CURSOR FOR (select ICARD, STATUS from CONTDIG_TSI1 WHERE STATUS = '1' or STATUS = '3' or STATUS = '8')

	OPEN cur_stdigital
	FETCH NEXT FROM cur_stdigital INTO @c_icard, @c_status
	while @@fetch_status != -1
	begin
	
		SET @nAchouGrupo = 0		-- presupoe q nao tem icard x grupo correspondente em tab 
	
		-- *************************************************************************
		-- prepara os ids excluidos (controle.situa = invalido) ou grupos da controle alterados, retirando as digitais de todos os equipamentos 
		IF (@c_status = '3') or (@c_status = '8') BEGIN			-- alterados grupos (3) ou situa invalidos  (8)

			-- MONTA temporaria matricula x equipamentos cadastrados
			INSERT INTO TMP_DIG103 (ICARD, END_IP, STATUS, BIO_TIPO) 		
				SELECT distinct @c_icard, DAT07.END_IP, '0', DAT07.BIO_TIPO 
				FROM DAT07 
				WHERE BIO_TIPO = '8';

	
			-- *****************************************************************
			-- COMO ESTA EXCLUINDO O FUNCIONARIO DA EMPRESA (CONTROLE.SITUA = '1' INVALIDO), TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN
			-- COMO ALTEROU O GRUPO, TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN

			--DELETE FROM DIG003 WHERE ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1')
			
			-- VAI DELETAR A MATRICULA DE QUALQUER STATUS PORQUE PODE CAIR NA SITUACAO EM QUE HA INCLUSAO DA MATRICULA, MAS NAO VAI PORQUE O EQUIPAMENTO 'ESTA OCUPADO' (nova resposta do microdimarms).
			-- SE HOUVER POSTERIORMENTE EXCLUSAO DESSA MESMA MATRICULA, DEVE=-SE EXCLUIR A INCLUSAO DESSA MATRICULA DA TABELA
			DELETE FROM DIG003 WHERE ICARD = @c_icard 
		
		END	

		IF (@c_status = '1') or (@c_status = '3')  BEGIN				-- alteracao na digital ou em grupo

			-- ******************************************************************
			-- para todos icards q alteraram digital, distribui nos equipamentos de acordo com o grupo cadastrado em 
			-- CONTROLE, DAT07,DAT08 
			-- MONTA temporaria matricula com codins com permissao acesso
					
			insert into TMP_DIG003 (ICARD, END_IP, STATUS, BIO_TIPO)
			SELECT distinct A.icard,  A.end_ip, A.st, A.bio_tipo
				FROM 
					-- seleciona os equipamentos que fazem parte dos grupos do usuário
					(SELECT distinct @c_icard as 'icard',  dat07.end_ip, '0' as 'st', dat07.bio_tipo
						from dat07, dat08 
						where 
							dat07.end_ip <> '000.000.000.000' and
							CONVERT(int,dat08.grupo) in (
								select CONVERT(int,grupo) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')  		-- antes era ((SITUA = '1') or (SITUA = '7'))
								  union
								select CONVERT(int,grupo1) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union	
								select CONVERT(int,grupo2) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo3) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_sab) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_dom) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_fer) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,A.grupo) from MATNGRUPOS A, CONTROLE B where A.ICARD = @c_icard  AND B.ICARD = @c_icard AND (B.SITUA <> '1') and (B.VER_DIGIT <> '1')
								) and
						  CONVERT(int,dat07.laces) = CONVERT(int,dat08.laces) and
						  CONVERT(int,dat07.planta) = CONVERT(int,dat08.planta) and
						  dat07.bio_tipo = '8'  
				UNION
					SELECT distinct @c_icard as 'icard',  dat07.end_ip, '0' as 'st', dat07.bio_tipo
						from dat07, MATCODIN 
						where 
							matcodin.icard = @c_icard and
							matcodin.end_ip <> '000.000.000.000' and 
							matcodin.end_ip = dat07.end_ip and 
							dat07.bio_tipo = '8') as A
							
			-- para quem incluiu/alterou digital (status 1) ou mudou de grupo (status 3)				
			-- IF (@c_status = '3') BEGIN
			IF (@c_status = '1') OR (@c_status = '3') BEGIN
				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao temporaria os equipamentos que fazem parte do novo grupo

				DELETE FROM TMP_DIG103
					WHERE EXISTS
						(SELECT TMP_DIG003.icard 
							FROM 
								TMP_DIG003
							WHERE 
								TMP_DIG003.icard = TMP_DIG103.icard and
								TMP_DIG003.END_IP = TMP_DIG103.END_IP and
							  	TMP_DIG003.icard = @c_icard
						);

				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao final os equipamentos do ID em questão, para REFAZER a tabela
				
				--DELETE from DIG103 where ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1')
				-- VAI DELETAR A MATRICULA DE QUALQUER STATUS PORQUE PODE CAIR NA SITUACAO EM QUE HA EXCLUSAO DA MATRICULA, MAS NAO VAI PORQUE O EQUIPAMENTO ESTA OCUPADO.
				-- SE HOUVER POSTERIORMENTE INCLUSAO DESSA MESMA MATRICULA, DEVE=-SE EXCLUIR A EXCLUSAO DESSA MATRICULA DA TABELA
				DELETE from DIG103 where ICARD = @c_icard 
				
			END
							
		END

		-- ******************************************************************
		-- PREPARA TABELA TEMPORARIA DE INCLUSAO COM OS ENDEREÇOS IP 
		SET @nCont = (SELECT COUNT(*) FROM TMP_DIG003)

		-- verifica se a matricula esta cadastrada em controle e se pertence a alguma codin. 
		-- Caso negativo, seu status ainda continua setado até que seja cadastrada e pertença a algum local de acesso
		IF (@nCont != 0) BEGIN

			-- insere icard-codin em tab. DIG003, se não existir em tab.
			DECLARE cur_tmpdigital CURSOR FOR (select ICARD, END_IP, STATUS, BIO_TIPO from TMP_DIG003)
			OPEN cur_tmpdigital
			FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio

			while @@fetch_status != -1
			begin
				UPDATE DIG003 SET STATUS = '1' 
					WHERE  ICARD = @xc_icard AND
						   END_IP = @xc_endip
				if @@rowcount = 0
				begin		
					INSERT INTO DIG003 (ICARD, END_IP, STATUS, BIO_TIPO) 
						values (@xc_icard, @xc_endip, '1', @xc_tipobio);
				end

				FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio
			end
			
			SET @nAchouGrupo = 1;
			
			-- coloca o codin na tab. DIG002 (CARGA LISTA) o codin não existir
			insert into DIG002 (END_IP, DATA_LOAD, STATUS, BIO_TIPO)
				select distinct end_ip, getdate(), '0', bio_tipo  
				from
					DIG003
				where
					end_ip not in ( select end_ip from DIG002 );
			
			CLOSE cur_tmpdigital
			DEALLOCATE cur_tmpdigital
		END

		-- ******************************************************************
		-- PREPARA TABELA TEMPORARIA DE EXCLUSAO COM OS ENDEREÇOS IP DOS EQUIPAMENTOS
		SET @nCont = (SELECT COUNT(*) FROM TMP_DIG103)
		IF (@nCont != 0) BEGIN

			-- insere na tabela final DIG103  os ID COM STATUS de carga (0 / 1= a excluir)
			DECLARE cur_tmpdigital CURSOR FOR (select ICARD, END_IP, STATUS, BIO_TIPO from TMP_DIG103)
			OPEN cur_tmpdigital
			FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio

			WHILE @@fetch_status != -1 BEGIN
				UPDATE DIG103 SET STATUS = '1' 
					WHERE  ICARD = @xc_icard AND
						   END_IP = @xc_endip
				if @@rowcount = 0
				begin		
					INSERT INTO DIG103 (ICARD, END_IP, STATUS, BIO_TIPO) 
						values (@xc_icard, @xc_endip, '1', @xc_tipobio);
				end

				FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio
			end
			
			SET @nAchouGrupo = 1;

			-- coloca o equipamento na tab. DIG102 (CARGA LISTA) o equipamento q não existir
			insert into DIG102 (END_IP, DATA_LOAD, STATUS, BIO_TIPO)
				select distinct END_IP, GETDATE(), '0', BIO_TIPO
				from
					DIG103
				where
					END_IP not in ( select END_IP from DIG102 );
							
			CLOSE cur_tmpdigital
			DEALLOCATE cur_tmpdigital
		END	


		-- atualiza status da matricula, como tratado
		IF (@nAchouGrupo = 1) 	
			update CONTDIG_TSI1 SET STATUS = '0' 
				where ICARD = @c_icard;
			
		DELETE TMP_DIG003
		DELETE TMP_DIG103

		FETCH NEXT FROM cur_stdigital INTO @c_icard, @c_status
	end
	CLOSE cur_stdigital
	deallocate cur_stdigital

GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.G3G5_prep2_Palmv'))
	DROP PROCEDURE TELESSVR.G3G5_prep2_Palmv
GO

CREATE PROCEDURE TELESSVR.G3G5_prep2_Palmv AS

DECLARE @nCont SMALLINT
DECLARE @nAchouGrupo SMALLINT
DECLARE @aux_icard CHAR(12)          

DECLARE @c_status CHAR(1)
DECLARE @c_icard CHAR(12)

DECLARE @xc_status CHAR(1)
DECLARE @xc_icard CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @ret CHAR(1)


SET DATEFORMAT YMD


	set @ret = 0

	SET LOCK_TIMEOUT 5000
	
	
	--begin TRAN

	-- cursor para matriculas cujas digitais foram alteradas
	DECLARE cur_autopalmv CURSOR FOR (select ICARD, ST from PALMV001 WHERE ST = '1' or ST = '3' or ST = '8')
	OPEN cur_autopalmv
	FETCH NEXT FROM cur_autopalmv INTO @c_icard, @c_status
	WHILE (@@fetch_status != -1)
	BEGIN          
		SET @nAchouGrupo = 0		-- presupoe q nao tem icard x grupo correspondente em tab 
		
		-- *************************************************************************
		-- prepara os ids excluidos (controle.situa = invalido) ou grupos da controle alterados, retirando os faces de todos os equipamentos SENSOBOXs
		IF (@c_status = '3') or (@c_status = '8') BEGIN			-- alterados grupos (3) ou situa invalidos  (8)
		
			-- MONTA temporaria matricula x SENSOBOXs cadastrados
			INSERT INTO TMP2_PALMV015 (ICARD, END_CTRLPALMV) 		
				SELECT distinct @c_icard, DAT07.END_IP
				FROM DAT07 
				WHERE BIO_TIPO = 'A';

			-- ******************************************************************
			-- COMO ESTA EXCLUINDO O FUNCIONARIO DA EMPRESA (CONTROLE.SITUA = '1' INVALIDO), TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN
			-- COMO ALTEROU O GRUPO, TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN

			--DELETE PALMV014 WHERE ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1')
			
			-- VAI DELETAR A MATRICULA DE QUALQUER STATUS PORQUE PODE CAIR NA SITUACAO EM QUE HA INCLUSAO DA MATRICULA, MAS NAO VAI PORQUE O EQUIPAMENTO 'ESTA OCUPADO' (nova resposta do microdimarms).
			-- SE HOUVER POSTERIORMENTE EXCLUSAO DESSA MESMA MATRICULA, DEVE=-SE EXCLUIR A INCLUSAO DESSA MATRICULA DA TABELA
			DELETE PALMV014 WHERE ICARD = @c_icard
				

--			DECLARE cur_tmpauto CURSOR FOR (SELECT ICARD, END_CTRLPALMV, STATUS from PALMV014 --WITH (UPDLOCK, NOWAIT)
--				where ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1'))
--			OPEN cur_tmpauto
--			FETCH NEXT FROM cur_tmpauto into @xc_icard, @xc_endip, @xc_status
			
--			WHILE @@fetch_status != -1
--			begin
--				DELETE PALMV014 WHERE ICARD = @xc_icard and END_CTRLPALMV = @xc_endip
--				FETCH NEXT FROM cur_tmpauto into @xc_icard, @xc_endip, @xc_status
--			end
			
--			CLOSE cur_tmpauto
--			DEALLOCATE cur_tmpauto
			
		END
		
		IF (@c_status = '1') or (@c_status = '3') BEGIN		-- incluido/alterado face (1)   ou   alterados grupos (3) 

			-- ******************************************************************
			-- para todos icards q alteraram face, distribui nos SENSOBOXs de acordo como grupo cadastrado em 
			-- CONTROLE, DAT07,DAT08
			-- MONTA temporaria matricula com codins com permissao acesso
			
			INSERT INTO TMP2_PALMV014 (ICARD, END_CTRLPALMV) 		
				SELECT distinct tA.icard, tA.END_IP
					FROM 
						-- seleciona os equipamentos que fazem parte dos grupos do usuário
						(SELECT distinct @c_icard as 'icard',  dat07.end_ip
							from dat07, dat08
							where
							  dat07.end_ip <> '000.000.000.000' and
							  CONVERT(int,dat08.grupo) in (
								select CONVERT(int,grupo) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1')		-- era (SITUA = '0' OR SITUA = '7')
								  union
								select CONVERT(int,grupo1) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1')
								  union	
								select CONVERT(int,grupo2) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1')
								  union
								select CONVERT(int,grupo3) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1')
								  union
								select CONVERT(int,grupo_sab) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1')
								  union
								select CONVERT(int,grupo_dom) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1')
								  union
								select CONVERT(int,grupo_fer) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1')
								  union
								select CONVERT(int,A.grupo) from MATNGRUPOS A, CONTROLE B where A.ICARD = @c_icard  AND B.ICARD = @c_icard AND (B.SITUA <> '1')
								) and
							  CONVERT(int,dat07.laces) = CONVERT(int,dat08.laces) and
							  CONVERT(int,dat07.planta) = CONVERT(int,dat08.planta) and
							  dat07.bio_tipo = 'A'
				UNION
					SELECT distinct @c_icard as 'icard',  dat07.end_ip
						from dat07, MATCODIN 
						where
							matcodin.icard = @c_icard and
							matcodin.end_ip <> '000.000.000.000' and 
							matcodin.end_ip = dat07.end_ip and 
							dat07.bio_tipo = 'A') as tA
			
			
			-- para quem incluiu/alterou digital (status 1) ou mudou de grupo (status 3)
			--IF (@c_status = '3') BEGIN
			IF (@c_status = '1') OR (@c_status = '3') BEGIN
				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao temporaria os SENSOBOX que fazem parte do novo grupo

				DELETE FROM TMP2_PALMV015
				WHERE EXISTS
				  ( SELECT TMP2_PALMV014.icard 
					FROM TMP2_PALMV014
						WHERE TMP2_PALMV014.icard = TMP2_PALMV015.icard AND
							  TMP2_PALMV014.END_CTRLPALMV = TMP2_PALMV015.END_CTRLPALMV AND TMP2_PALMV014.icard = @c_icard
					);

				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao final os SENSOBOX do ID em questão, PARA refazer a tabela
				--DELETE from PALMV015 where ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1')
				
				-- VAI DELETAR A MATRICULA DE QUALQUER STATUS PORQUE PODE CAIR NA SITUACAO EM QUE HA EXCLUSAO DA MATRICULA, MAS NAO VAI PORQUE O EQUIPAMENTO ESTA OCUPADO.
				-- SE HOUVER POSTERIORMENTE INCLUSAO DESSA MESMA MATRICULA, DEVE=-SE EXCLUIR A EXCLUSAO DESSA MATRICULA DA TABELA
				DELETE from PALMV015 where ICARD = @c_icard
				

--				DECLARE cur_tmpauto CURSOR FOR (SELECT ICARD, END_CTRLPALMV, STATUS from PALMV015 --WITH (UPDLOCK, NOWAIT)
--					where ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1'))
--				OPEN cur_tmpauto
--				FETCH NEXT FROM cur_tmpauto into @xc_icard, @xc_endip, @xc_status
--
--				WHILE @@fetch_status != -1
--				begin
--					DELETE PALMV015 WHERE ICARD = @xc_icard and END_CTRLPALMV = @xc_endip
--					FETCH NEXT FROM cur_tmpauto into @xc_icard, @xc_endip, @xc_status
--				end
--
--				CLOSE cur_tmpauto
--				DEALLOCATE cur_tmpauto

			END
			
		END
			
		-- ******************************************************************
		-- PREPARA TABELA TEMPORARIA DE INCLUSAO COM OS ENDEREÇOS IP DOS SENSOBOXS
		SET @nCont = (SELECT COUNT(*) FROM TMP2_PALMV014)
				
		IF (@nCont != 0) BEGIN
			-- insere na tabela final PALMV014  os ID x SENSOBOX e STATUS de carga (0 / 1= a carregar)
			DECLARE cur_autoins CURSOR FOR (SELECT ICARD, END_CTRLPALMV from TMP2_PALMV014)
			OPEN cur_autoins
			FETCH NEXT FROM cur_autoins into @xc_icard, @xc_endip

			WHILE (@@fetch_status != -1)	BEGIN
					
				SELECT @aux_icard  = icard from PALMV014 --WITH (UPDLOCK, NOWAIT) 
					WHERE ICARD = @xc_icard AND
						  END_CTRLPALMV = @xc_endip ;
								  
				IF (@@ROWCOUNT = 0)
					INSERT INTO PALMV014 (ICARD, END_CTRLPALMV, STATUS) 
								values (@xc_icard, @xc_endip, '1')
				ELSE
					UPDATE PALMV014 SET STATUS = '1' 
						WHERE  ICARD = @xc_icard AND
							   END_CTRLPALMV = @xc_endip;
					
				FETCH NEXT FROM cur_autoins into @xc_icard, @xc_endip
			END;					
			
			SET @nAchouGrupo = 1;
			
			-- coloca o SENSOBOX na tab. PALMV004 (CARGA LISTA) o SENSOBOX q não existir
			insert into PALMV004 (END_CTRLPALMV, DATA_LOAD, STATUS)
				select distinct END_CTRLPALMV, GETDATE(), '0'
					from
						PALMV014
					where
						END_CTRLPALMV not in ( select END_CTRLPALMV from PALMV004 );

			CLOSE cur_autoins
			DEALLOCATE cur_autoins
						
		END
			
		-- PREPARA TABELA TEMPORARIA DE EXCLUSAO COM OS ENDEREÇOS IP DOS SENSOBOXS
		
		SET @nCont = (SELECT COUNT(*) FROM TMP2_PALMV015)
		IF (@nCont != 0) BEGIN

			-- insere na tabela final PALMV015  os ID x SENSOBOX e STATUS de carga (0 / 1= a excluir)
			DECLARE cur_autoexc CURSOR FOR (SELECT ICARD, END_CTRLPALMV from TMP2_PALMV015)
			OPEN cur_autoexc
			FETCH NEXT FROM cur_autoexc into @xc_icard, @xc_endip

			WHILE (@@fetch_status != -1)	BEGIN
					
				SELECT @aux_icard  = icard from PALMV015 --WITH(UPDLOCK, NOWAIT)
					WHERE ICARD = @xc_icard AND
						  END_CTRLPALMV = @xc_endip ;
								  
				IF (@@ROWCOUNT = 0)
					INSERT INTO PALMV015 (ICARD, END_CTRLPALMV, STATUS) 
								values (@xc_icard, @xc_endip, '1')
				ELSE
					UPDATE PALMV015 SET STATUS = '1' 
						WHERE  ICARD = @xc_icard AND
							   END_CTRLPALMV = @xc_endip;
					
				FETCH NEXT FROM cur_autoexc into @xc_icard, @xc_endip
			END;					
			
			SET @nAchouGrupo = 1

			-- coloca o SENSOBOX na tab. PALMV005 (CARGA LISTA) o SENSOBOX q não existir
			insert into PALMV005 (END_CTRLPALMV, DATA_LOAD, STATUS)
				select distinct END_CTRLPALMV, GETDATE(), '0'
				from
					PALMV015
				where
					END_CTRLPALMV not in ( select END_CTRLPALMV from PALMV005 );
							
			CLOSE cur_autoexc
			DEALLOCATE cur_autoexc
		END	
			
		-- atualiza status da matricula, como tratado
		IF (@nAchouGrupo = 1) 	
			update PALMV001 SET ST = '0' 
				where ICARD = @c_icard;
			
		DELETE TMP2_PALMV014
		DELETE TMP2_PALMV015

		FETCH NEXT FROM cur_autopalmv INTO @c_icard, @c_status
	END

	CLOSE cur_autopalmv
	DEALLOCATE cur_autopalmv

	--COMMIT TRAN
	SET LOCK_TIMEOUT -1
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.trata2_palmv'))
	DROP PROCEDURE TELESSVR.trata2_palmv
GO

CREATE PROCEDURE TELESSVR.trata2_palmv AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_status CHAR(1)
DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000

	-- ********************   ARRUMAR SITUAÇÕES PARA PALMVEIN INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS PALMVEIN QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA (status '4')
	DECLARE cur_troubleIns1 CURSOR FOR 
		(SELECT distinct ICARD from PALMV014 
			WHERE STATUS = '4'
		)
	OPEN cur_troubleIns1
	FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE cur_troubleIns2 CURSOR FOR 
			(SELECT END_CTRLPALMV from PALMV014 
				WHERE (ICARD = @z_mat and STATUS = '4')
			)
		OPEN cur_troubleIns2
		FETCH NEXT FROM cur_troubleIns2 INTO @z_endip
	
		WHILE (@@fetch_status != -1) BEGIN
			DELETE PALMV014 WHERE (END_CTRLPALMV = @z_endip and ICARD = @z_mat and STATUS = '4')	-- vai excluir registro porque nao adianta reenviar 
	
			UPDATE PALMV004 set status = '1'WHERE (END_CTRLPALMV =  @z_endip AND STATUS = '3') ;
	
			FETCH NEXT FROM cur_troubleIns2 INTO @z_endip
		END
	
	
		CLOSE cur_troubleIns2
		deallocate cur_troubleIns2
	
		FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	END
		
	CLOSE cur_troubleIns1
	deallocate cur_troubleIns1
	

	-- ***********************  TRATA AS PALMVEIN QUE FICARAM PENDENTES NA CARGA	
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS PALMVEINS (DA TAB.PALMV001 CADASTRO)
	-- delete registro de PALMV014 se nao houver cadastro de palmvein desta matricula
	DECLARE cur_autoIns1 CURSOR FOR 
		(SELECT distinct ICARD from PALMV014 
			WHERE STATUS = '3'
		)
	OPEN cur_autoIns1
	FETCH NEXT FROM cur_autoIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		-- VERIFICA SE HÁ CADASTRO DO PALMVEIN DA MATRICULA
		SELECT @aux_icard = ICARD FROM PALMV001 WHERE ICARD = @z_mat;
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de palmvein desta matricula
			DECLARE cur_autoIns2 CURSOR FOR 
				(SELECT END_CTRLPALMV from PALMV014 
					WHERE (ICARD = @z_mat and STATUS = '3')
				)
			OPEN cur_autoIns2
			FETCH NEXT FROM cur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				--UPDATE PALMV014 set status = '0' WHERE (END_CTRLPALMV = @z_endip and ICARD = @z_mat and STATUS = '3')
				DELETE PALMV014 WHERE (END_CTRLPALMV = @z_endip and ICARD = @z_mat and STATUS = '3')

				UPDATE PALMV004 set status = '1'WHERE (END_CTRLPALMV =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM cur_autoIns2 INTO @z_endip
			END


			CLOSE cur_autoIns2
			deallocate cur_autoIns2
		END

		FETCH NEXT FROM cur_autoIns1 INTO @z_mat
	END
	
	CLOSE cur_autoIns1
	deallocate cur_autoIns1
	
	
	-- altera status dos codins SensoBox para carga de palmvein, se esses não estiverem com carga de palmvein ou estiverem pendentes
	DECLARE cur_autoIns1 CURSOR FOR 
		(SELECT distinct END_CTRLPALMV from PALMV014 
			WHERE (STATUS != '0' and STATUS != '2')
		)
	OPEN cur_autoIns1
	FETCH NEXT FROM cur_autoIns1 INTO @z_endip
	
	WHILE (@@fetch_status != -1) BEGIN
		UPDATE PALMV004 set status = '1'
			WHERE END_CTRLPALMV = @z_endip and (STATUS = '0' or STATUS = '3')
			
		FETCH NEXT FROM cur_autoIns1 INTO @z_endip
	END
		
	CLOSE cur_autoIns1
	deallocate cur_autoIns1
	
	
	-- ********************   TRATA EQUIPAMENTOS PALMVEIN QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos PALMVEIN q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos PALMVEIN q tiveram carga de aplicativo 

	DECLARE cur_autoIns1 CURSOR FOR 
		(SELECT distinct END_CTRLPALMV, STATUS from PALMV004 
			WHERE ((status = '5') or 		-- CARGA DE APLICATIVO
				   ((status = '2') and (DATEADD (MINUTE, 2, data_load)  < getdate()) )
				  )
		)
	OPEN cur_autoIns1
	FETCH NEXT FROM cur_autoIns1 INTO @z_endip, @z_status
	while @@fetch_status != -1
	begin
		IF (@z_status = '2') begin		-- situação q estava fazendo a carga e deu problema
			UPDATE PALMV014 set status = '1' WHERE (END_CTRLPALMV = @z_endip and STATUS = '2')
			UPDATE PALMV004 set status = '1' WHERE (END_CTRLPALMV = @z_endip)
		end

		ELSE begin
			IF (@z_status = '5') begin		-- HOUVE CARGA DE APLICATIVO, MAS NAO VAI RECARREGAR AS BIOMETRIAS
				UPDATE PALMV004 set status = '0' WHERE (END_CTRLPALMV = @z_endip)
			end
		end
		
				
		FETCH NEXT FROM cur_autoIns1 INTO @z_endip, @z_status
	end
	CLOSE cur_autoIns1
	deallocate cur_autoIns1
	
	
	-- ***********************  TRATA AS PALMVEIN QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUAÇÃO
	-- para palms DE PALMV014 que ficaram em estado carregando '2'	, e o equipamento está em estado de repouso	, forca o equipamento a carrega-lo novamente
	
	DECLARE cur_autoIns1 CURSOR FOR 
		(SELECT A.END_CTRLPALMV, A.STATUS from PALMV004 A 
			INNER JOIN PALMV014 B ON
				A.status = '0' AND 
				A.END_CTRLPALMV = B.END_CTRLPALMV AND 
				B.STATUS = '2')
	OPEN cur_autoIns1
	FETCH NEXT FROM cur_autoIns1 INTO @z_endip, @z_status
	
	WHILE (@@fetch_status != -1) BEGIN
		UPDATE PALMV014 SET STATUS = '1' 
			WHERE END_CTRLPALMV = @z_endip AND STATUS = '2';
		UPDATE PALMV004 set STATUS = '1' 
			WHERE END_CTRLPALMV = @z_endip;

		FETCH NEXT FROM cur_autoIns1 INTO @z_endip, @z_status;
	END

	
	CLOSE cur_autoIns1
	deallocate cur_autoIns1
	
	
	-- ********************   ARRUMAR SITUAÇÕES PARA PALMV EXCLUSAO
	
	-- ***********************  TRATA AS PALMV QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins PALMV para exclusao de palmv, se esses não estiverem com exclusao de palmv ou estiverem pendentes
	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_CTRLPALMV from PALMV015 
			WHERE STATUS != '0' and STATUS != '2' and STATUS != '4')
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip
	
	WHILE (@@fetch_status != -1) BEGIN
		UPDATE PALMV005 set status = '1'
			WHERE (END_CTRLPALMV = @z_endip) and 
				  (STATUS = '0' or STATUS = '3')
			
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip
	END
	
	CLOSE cur_autoExc1
	deallocate cur_autoExc1
	
	
	-- ********************   TRATA EQUIPAMENTOS PALMV QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 
	
	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_CTRLPALMV,STATUS from PALMV005 
			WHERE ( (status = '5') or 													-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())   
				  )			
		)			
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE PALMV015 set status = '1'
				WHERE (END_CTRLPALMV = @z_endip and status = '2')

			UPDATE PALMV005 set status = '1' 
					where (END_CTRLPALMV = @z_endip )
		end
				
		else if (@z_status = '5') begin
			UPDATE PALMV005 set status = '0' where (END_CTRLPALMV = @z_endip)	
		end;
				
				
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status
	end
	CLOSE cur_autoExc1
	deallocate cur_autoExc1
	

	-- ***********************  TRATA AS PALMV QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUAÇÃO
	-- para palmv de PALMV015 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT a.END_CTRLPALMV, a.status 
			from PALMV005 A 
			INNER JOIN PALMV015 B ON
				A.END_CTRLPALMV = B.END_CTRLPALMV AND 
				A.status = '0' AND 
				B.STATUS = '2') 
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status
	
	WHILE (@@fetch_status != -1) BEGIN
		UPDATE PALMV015 SET STATUS = '1' 
			WHERE END_CTRLPALMV = @z_endip AND STATUS = '2';
		UPDATE PALMV005 set STATUS = '1' 
			WHERE END_CTRLPALMV = @z_endip;
		
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status;
	END
	
	
	CLOSE cur_autoExc1
	deallocate cur_autoExc1

	SET LOCK_TIMEOUT -1
	
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.G3G5_P_GERDIGITAL3'))
	DROP PROCEDURE TELESSVR.G3G5_P_GERDIGITAL3
GO

CREATE PROCEDURE TELESSVR.G3G5_P_GERDIGITAL3 AS

DECLARE @ret CHAR(1)


	SET DATEFORMAT YMD


	set @ret = 0
	
	exec TELESSVR.G3G5_PREP2_SAGEM	-- prepara automatico digitais sagem
	
	exec TELESSVR.G3G5_PREP2_TSI1	-- prepara automatico digitais tsi1

	exec TELESSVR.G3G5_prep2_Palmv	-- prepara PALMV014/PALMV004 (INCLUSAO)  e PALMV015/PALMV005 (EXCLUSAO)

	-- fazer
	--exec TELESSVR.prep_OutrosBios	-- prepara automatico Outras biometrias


	exec TELESSVR.trata3_sagem		-- trata biometria sagem

	exec TELESSVR.trata3_tsi1		-- trata biometria tsi1
	
	exec TELESSVR.trata2_palmv		-- trata PALMVEIN

	-- fazer
	--exec TELESSVR.trata_OutrosBios		-- trata Outras Biometrias
	
	select @ret
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.SQLCON_VIVA'))
  DROP PROCEDURE TELESSVR.SQLCON_VIVA
GO

CREATE PROCEDURE TELESSVR.sqlcon_viva AS
DECLARE
  @cAux CHAR(1)
BEGIN
	SET @cAux = 1
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.SQLBUSCA_TSI1_BIOMET'))
	DROP PROCEDURE TELESSVR.SQLBUSCA_TSI1_BIOMET
GO

CREATE PROCEDURE TELESSVR.sqlBusca_Tsi1_biomet  @cMatric char(12), @cTipBio char(1), @cEndIp char(15), @cTipoCons char(1),
@cTempl_tit1tot CHAR(160) OUTPUT, @cTempl_tit2tot CHAR(160) OUTPUT, 
@cTempl_tit3tot CHAR(160) OUTPUT, @cTempl_tit4tot CHAR(160) OUTPUT, 
@cTempl_Alt1tot CHAR(160) OUTPUT, @cTempl_Alt2tot CHAR(160) OUTPUT, 
@cTempl_Alt3tot CHAR(160) OUTPUT, @cTempl_Alt4tot CHAR(160) OUTPUT,
@cNivel CHAR(1) OUTPUT,
@cTempl_tit5tot CHAR(160) OUTPUT, @cTempl_Alt5tot CHAR(160) OUTPUT,
@cTempl_tit6tot CHAR(26) OUTPUT, @cTempl_Alt6tot CHAR(26) OUTPUT
AS
DECLARE @cTempl_tit5aux AS CHAR(128), @cTempl_Alt5aux AS CHAR(128), @cVDigit char(1)
DECLARE @RetFun int, @Pad int, @Alt int, @nAchou int
BEGIN
	select @RetFun = 3
	select @cTempl_tit1tot = NULL
	select @cTempl_tit2tot = NULL
	select @cTempl_tit3tot = NULL
	select @cTempl_tit4tot = NULL
	select @cTempl_tit5aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	select @cTempl_Alt1tot = NULL
	select @cTempl_Alt2tot = NULL
	select @cTempl_Alt3tot = NULL
	select @cTempl_Alt4tot = NULL
	select @cTempl_Alt5aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	
	set @cNivel = NULL
	set @cVDigit = '2'
	set @nAchou = 0;
	set @Pad = 0;
	set @Alt = 0;
	
	-- PARA VALIDA??O ONLINE 
	IF (@cTipoCons = '1') 
	begin
		IF EXISTS (SELECT Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric) 
		begin
			SELECT @cVDigit = Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric
			-- procura por Templates da matricula
			IF EXISTS (SELECT * FROM CONTDIG_TSI1  WHERE ICARD = @cMatric)
			begin
				SELECT @cTempl_tit1tot = TEMPL_TIT1,
				   @cTempl_tit2tot = TEMPL_TIT2,
				   @cTempl_tit3tot = TEMPL_TIT3,
				   @cTempl_tit4tot = TEMPL_TIT4,
		   		   @cTempl_tit5aux = TEMPL_TIT5,
				   @cTempl_Alt1tot = TEMPL_ALT1,
				   @cTempl_Alt2tot = TEMPL_ALT2,
				   @cTempl_Alt3tot = TEMPL_ALT3,
		   		   @cTempl_Alt4tot = TEMPL_ALT4,
		   		   @cTempl_Alt5aux = TEMPL_ALT5,
				   @cNivel = NIVEL
				FROM CONTDIG_TSI1
				WHERE ICARD = @cMatric
					
				set @nAchou = 1;
			end
			ELSE begin
				IF (CONVERT(INT,@cVDigit) = 2) 
					set @RetFun = -2;
				ELSE begin
					set @Pad = 0;
					set @Alt = 0;
				end
			end
		end
		ELSE
			set @RetFun = -2;
	end
	
	-- PARA COMANDO CARGA DIGITAIS 
	ELSE begin
		-- procura por Templates da matricula
		IF EXISTS (SELECT * FROM CONTDIG_TSI1  WHERE ICARD = @cMatric)
		begin
			SELECT @cTempl_tit1tot = TEMPL_TIT1,
				   @cTempl_tit2tot = TEMPL_TIT2,
				   @cTempl_tit3tot = TEMPL_TIT3,
				   @cTempl_tit4tot = TEMPL_TIT4,
		   		   @cTempl_tit5aux = TEMPL_TIT5,
				   @cTempl_Alt1tot = TEMPL_ALT1,
				   @cTempl_Alt2tot = TEMPL_ALT2,
				   @cTempl_Alt3tot = TEMPL_ALT3,
		   		   @cTempl_Alt4tot = TEMPL_ALT4,
		   		   @cTempl_Alt5aux = TEMPL_ALT5
			FROM CONTDIG_TSI1
			WHERE ICARD = @cMatric
			set @nAchou = 1;
		end
		ELSE begin
			set @Pad = 0;
			set @Alt = 0;
		end
	end	
	
	-- verifica o conteudo das digitais
	IF (@nAchou = 1) begin
		select @Pad = 1    -- assume que tem template padrao
		select @Alt = 1    -- assume que tem template alternativo
		if ((@cTempl_tit1tot is Null) or (@cTempl_tit2tot is Null) or 
			(@cTempl_tit3tot is Null) or (@cTempl_tit4tot is Null) or 
			(@cTempl_tit5aux is Null) or
			(datalength(@cTempl_tit1tot) < 160) or (datalength(@cTempl_tit2tot) < 160) or
			(datalength(@cTempl_tit3tot) < 160) or (datalength(@cTempl_tit4tot) < 160) or 
			(datalength(@cTempl_tit5aux) < 128)) 
		begin
			SELECT @Pad = 0
		end 
	
		IF (datalength(@cTempl_tit5aux) = 128) BEGIN
			SET @cTempl_tit5tot = @cTempl_tit5aux + REPLICATE('0',160-LEN(@cTempl_tit5aux) )
			SET @cTempl_tit6tot = REPLICATE('0', 26)
		END
	
		if ((@cTempl_Alt1tot is Null) or (@cTempl_Alt2tot is Null) or
			(@cTempl_Alt3tot is Null) or (@cTempl_Alt4tot is Null) or 
			(@cTempl_Alt5aux is Null) or
			(datalength(@cTempl_Alt1tot) < 160) or (datalength(@cTempl_Alt2tot) < 160) or
			(datalength(@cTempl_Alt3tot) < 160) or (datalength(@cTempl_Alt4tot) < 160) or 
			(datalength(@cTempl_Alt5aux) < 128)) 
		begin 
			SELECT @Alt = 0
		end
	
		IF (datalength(@cTempl_Alt5aux) = 128) BEGIN
			SET @cTempl_Alt5tot = @cTempl_Alt5aux + REPLICATE('0',160-LEN(@cTempl_Alt5aux) )
			SET @cTempl_Alt6tot = REPLICATE('0', 26)
		END
	end
	
	IF (@RetFun != -2) begin
		if (@Pad = 1) 
			if (@Alt = 1) 
				SET @RetFun = 0   -- tem padrao e tem alternativo
			else 
				SET @RetFun = 1   -- tem padrao e nao tem alternativo
		
		if (@Pad = 0) 
			if (@Alt = 1) 
				SET @RetFun = 2   -- nao tem padrao e tem alternativo
			else 
				SET @RetFun = 3   -- nao tem padrao e nao tem alternativo	
	end
	-- VERIFICA SE NAO ACHOU NENHUMA BIOMETRIA E ? COMANDO DE ENVIO DE DIGITAIS, DEVERA GUARDAR INFORMACAO EM DIGLOAD001	
	IF ((@RetFun = 3) and (@cTipoCons != '1' )) 
		INSERT into DIGLOAD001 (END_IP, ICARD, BIO_TIPO) 		-- insere em tabela DIGLOAD001
						VALUES (@cEndIp, @cMatric, @cTipBio);
		
	return (@RetFun)
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.SQLAVISA_CPBB_NOVELL_TCP'))
	DROP PROCEDURE TELESSVR.SQLAVISA_CPBB_NOVELL_TCP
GO

CREATE PROCEDURE TELESSVR.sqlavisa_cpbb_novell_tcp  @pt_aviso char(250)
AS
DECLARE @Ret smallint, @cEndIp char(15), @cAviso char(2), @cStat char(1), @cMens char(30)
	set @Ret    = 0
	set @cEndIp = SUBSTRING(@pt_aviso,  1,15)
	set @cAviso = SUBSTRING(@pt_aviso, 16, 2)
	set @cStat  = SUBSTRING(@pt_aviso, 18, 1)
	set @cMens  = SUBSTRING(@pt_aviso, 19,30)
   
	if exists (select ST from CP_BN  WHERE AVISO = @cAviso and END_IP = @cEndIp and BLUEB = '00' and TERM = '00') 
	begin
		UPDATE CP_BN SET ST = @cStat, EPN3 = @cMens 
			WHERE AVISO = @cAviso AND
				END_IP = @cEndIp and
				BLUEB = '00' and
				TERM = '00'
	end	
	else
	begin
		-- aviso nao existe, sera' inserido novo comando
		INSERT INTO CP_BN (END_IP, AVISO, ST, EPN3) 
			VALUES (@cEndIp, @cAviso, @cStat, @cMens)
    end
              
	SELECT @Ret
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

-----------------------------------------------------------------------------
-- 2.10.9.0 || 2.10.9.0 || 2.10.9.0 || 2.10.9.0 || 2.10.9.0 || 2.10.9.0 || --
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Create date:		06/01/2020 - 08:37
-- Changed:			06/01/2020 - 08:37
-- Redmine: 		@5365
-----------------------------------------------------------------------------

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.REPALARME_EI'))
	DROP TRIGGER TELESSVR.REPALARME_EI
GO

-----------------------------------------------------------------------------------
-- CONEX ACESSO V.40.00.01 || CONEX ACESSO V.40.00.01 || CONEX ACESSO V.40.00.01 ||
-----------------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Create date:		09/03/2020 - 09:13
-- Changed:			09/03/2020 - 09:13
-- Redmine: 		@5213
-----------------------------------------------------------------------------

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlapos_datahora6'))
  DROP PROCEDURE TELESSVR.sqlapos_datahora6
GO

CREATE PROCEDURE TELESSVR.sqlapos_datahora6 @cEndIp CHAR(15), @pt_aviso char(250), @nTipo int AS

DECLARE @nRet SMALLINT, @cAviso char(2), @cStat char(1), @cMens char(30), @dData DATETIME
DECLARE @ERR INT

	SET @nRet = 0
	SET NOCOUNT ON
	SET DATEFORMAT DMY

	set @cAviso = SUBSTRING(@pt_aviso, 16, 2)
	set @cStat  = SUBSTRING(@pt_aviso, 18, 1)
	set @cMens  = SUBSTRING(@pt_aviso, 19,30)
	set @dData = '01-01-01 00:00:00'

	-- resposta de comando 
	if exists (select ST from CP_BN  WHERE AVISO = @cAviso and END_IP = @cEndIp) 
	begin
		UPDATE CP_BN SET ST = @cStat,    
						 EPN3 = @cMens 
		WHERE AVISO = @cAviso AND
			  END_IP = @cEndIp
	end	
	else
	begin
		-- aviso nao existe, sera' inserido novo comando
		INSERT INTO CP_BN (END_IP, AVISO, ST, EPN3) VALUES (@cEndIp, @cAviso, @cStat, @cMens)
	end

	SELECT @nRet
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlatu_geral4'))
  DROP PROCEDURE TELESSVR.sqlatu_geral4
GO

CREATE PROCEDURE TELESSVR.sqlatu_geral4 @cEndIp VARCHAR(15), @pt_aviso VARCHAR(60), @cTipo CHAR(1), @cData CHAR(12) AS

DECLARE @nRet SMALLINT, @cStatus VARCHAR(1), @cAviso VARCHAR(2), @cMens VARCHAR(30), @cAux VARCHAR(1), @dData DATETIME

	SET NOCOUNT ON
	SET DATEFORMAT DMY
	SET @nRet = 0
	SET @cAviso = SUBSTRING(@pt_aviso, 16,2)
	SET @cStatus = SUBSTRING(@pt_aviso, 18,1)
	SET @cMens   = SUBSTRING(@pt_aviso, 19,30)
	SET @dData = substring(@cData,1,2)+'-'+substring(@cData,3,2)+'-'+substring(@cData,5,2)+' '+
		 		substring(@cData,7,2)+':'+substring(@cData,9,2)+':'+substring(@cData,11,2)

	-- ATUALIZA CP_BN
    IF NOT EXISTS (SELECT ST FROM CP_BN  
    				WHERE AVISO = @cAviso and END_IP = @cEndIp) BEGIN
		-- aviso nao existe, sera' inserido novo comando
		INSERT into CP_BN (END_IP, AVISO, ST, EPN3) 
			values (@cEndIp, @cAviso, @cStatus, @cMens)          
	END
	ELSE BEGIN
		UPDATE CP_BN  SET
			ST = @cStatus,
			EPN3 = @cMens
		WHERE AVISO = @cAviso and END_IP = @cEndIp
	END

	SET LOCK_TIMEOUT -1

	SELECT @nRet
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlavisa_cpbb_novell_tcp'))
  DROP PROCEDURE TELESSVR.sqlavisa_cpbb_novell_tcp
GO

CREATE PROCEDURE TELESSVR.sqlavisa_cpbb_novell_tcp  @pt_aviso char(250)
AS

DECLARE @Ret smallint, @cEndIp char(15), @cAviso char(2), @cStat char(1), @cMens char(30)

	set @Ret    = 0
	set @cEndIp = SUBSTRING(@pt_aviso,  1,15)
	set @cAviso = SUBSTRING(@pt_aviso, 16, 2)
	set @cStat  = SUBSTRING(@pt_aviso, 18, 1)
	set @cMens  = SUBSTRING(@pt_aviso, 19,30)
   
	if exists (select ST from CP_BN  WHERE AVISO = @cAviso and END_IP = @cEndIp and BLUEB = '00' and TERM = '00') 
	begin
		UPDATE CP_BN SET ST = @cStat, EPN3 = @cMens 
			WHERE AVISO = @cAviso AND
				END_IP = @cEndIp and
				BLUEB = '00' and
				TERM = '00'
	end	
	else
	begin
		-- aviso nao existe, sera' inserido novo comando
		INSERT INTO CP_BN (END_IP, AVISO, ST, EPN3) 
			VALUES (@cEndIp, @cAviso, @cStat, @cMens)
    end
              
	SELECT @Ret

GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlBusca_Omok_biomet2'))
  DROP PROCEDURE TELESSVR.sqlBusca_Omok_biomet2
GO

CREATE PROCEDURE TELESSVR.sqlBusca_Omok_biomet2  @cMatric char(12), @cTipBio char(1), @cEndIp char(15), @cTipoCons char(1),
@cTempl_tit1tot CHAR(160) OUTPUT, @cTempl_tit2tot CHAR(160) OUTPUT, 
@cTempl_tit3tot CHAR(160) OUTPUT, @cTempl_tit4tot CHAR(160) OUTPUT, 
@cTempl_Alt1tot CHAR(160) OUTPUT, @cTempl_Alt2tot CHAR(160) OUTPUT, 
@cTempl_Alt3tot CHAR(160) OUTPUT, @cTempl_Alt4tot CHAR(160) OUTPUT,
@cNivel CHAR(1) OUTPUT, 
@cTempl_tit5tot CHAR(160) OUTPUT, @cTempl_Alt5tot CHAR(160) OUTPUT,
@cTempl_tit6tot CHAR(26) OUTPUT, @cTempl_Alt6tot CHAR(26) OUTPUT

AS
DECLARE @cVDigit char(1)
DECLARE @RetFun int, @Pad int, @Alt int, @nAchou int

BEGIN
	select @RetFun = 3
	select @cTempl_tit1tot = NULL
	select @cTempl_tit2tot = NULL
	select @cTempl_tit3tot = NULL
	select @cTempl_tit4tot = NULL
	select @cTempl_tit5tot = NULL
	select @cTempl_tit6tot = NULL
	select @cTempl_Alt1tot = NULL
	select @cTempl_Alt2tot = NULL
	select @cTempl_Alt3tot = NULL
	select @cTempl_Alt4tot = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL

	set @cNivel = NULL
	set @cVDigit = '2'
	set @nAchou = 0;
	set @Pad = 0;
	set @Alt = 0;

	-- PARA VALIDA��O ONLINE 
	IF (@cTipoCons = '1') 
	begin
		IF EXISTS (SELECT Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric) 
		begin
			SELECT @cVDigit = Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric

			-- procura por Templates da matricula
			IF EXISTS (SELECT * FROM CONTDIG_OMOK  WHERE ICARD = @cMatric)
			begin
				SELECT @cTempl_tit1tot = TEMPL_TIT1,
					   @cTempl_tit2tot = TEMPL_TIT2,
					   @cTempl_tit3tot = TEMPL_TIT3,
					   @cTempl_tit4tot = TEMPL_TIT4,
					   @cTempl_Alt1tot = TEMPL_ALT1,
					   @cTempl_Alt2tot = TEMPL_ALT2,
					   @cTempl_Alt3tot = TEMPL_ALT3,
					   @cTempl_Alt4tot = TEMPL_ALT4,
					   @cNivel = NIVEL,
					   @cTempl_tit5tot = TEMPL_TIT5,
					   @cTempl_Alt5tot = TEMPL_ALT5,
					   @cTempl_tit6tot = TEMPL_TIT6,
					   @cTempl_Alt6tot = TEMPL_ALT6
				FROM CONTDIG_OMOK
				WHERE ICARD = @cMatric
					
				set @nAchou = 1;
			end
			ELSE begin
				IF (CONVERT(INT,@cVDigit) = 2) 
					set @RetFun = -2;
				ELSE begin
					set @Pad = 0;
					set @Alt = 0;
				end
			end
		end
		ELSE
			set @RetFun = -2;
	end

	-- PARA COMANDO CARGA DIGITAIS 
	ELSE begin
		-- procura por Templates da matricula
		IF EXISTS (SELECT * FROM CONTDIG_OMOK  WHERE ICARD = @cMatric)
		begin
			SELECT @cTempl_tit1tot = TEMPL_TIT1,
				   @cTempl_tit2tot = TEMPL_TIT2,
				   @cTempl_tit3tot = TEMPL_TIT3,
				   @cTempl_tit4tot = TEMPL_TIT4,
				   @cTempl_Alt1tot = TEMPL_ALT1,
				   @cTempl_Alt2tot = TEMPL_ALT2,
				   @cTempl_Alt3tot = TEMPL_ALT3,
				   @cTempl_Alt4tot = TEMPL_ALT4,
				   @cNivel = NIVEL,
				   @cTempl_tit5tot = TEMPL_TIT5,
				   @cTempl_Alt5tot = TEMPL_ALT5,
				   @cTempl_tit6tot = TEMPL_TIT6,
				   @cTempl_Alt6tot = TEMPL_ALT6
			FROM CONTDIG_OMOK
				WHERE ICARD = @cMatric
							
			set @nAchou = 1;
		end

		ELSE begin
			set @Pad = 0;
			set @Alt = 0;
		end
	end	

	-- verifica o conteudo das digitais
	IF (@nAchou = 1) begin
		select @Pad = 1    -- assume que tem template padrao
		select @Alt = 1    -- assume que tem template alternativo

	    if ((@cTempl_tit1tot is Null) or (@cTempl_tit2tot is Null) or 
			(@cTempl_tit3tot is Null) or (@cTempl_tit4tot is Null) or
			(@cTempl_tit5tot is Null) or (@cTempl_tit6tot is Null) or 
			--(datalength(@cTempl_tit1tot) < 160) or (datalength(@cTempl_tit2tot) < 160) or
			--(datalength(@cTempl_tit3tot) < 160) or (datalength(@cTempl_tit4tot) < 160) or
			--(datalength(@cTempl_tit5tot) < 160) or (datalength(@cTempl_tit6tot) < 26)) 
			(len(@cTempl_tit1tot) < 160) or (len(@cTempl_tit2tot) < 160) or
			(len(@cTempl_tit3tot) < 160) or (len(@cTempl_tit4tot) < 160) or
			(len(@cTempl_tit5tot) < 160) or (len(@cTempl_tit6tot) < 26)) 
			
	    begin
			SELECT @Pad = 0
	    end 
	    if ((@cTempl_Alt1tot is Null) or (@cTempl_Alt2tot is Null) or
			(@cTempl_Alt3tot is Null) or (@cTempl_Alt4tot is Null) or
			(@cTempl_Alt5tot is Null) or (@cTempl_Alt6tot is Null) or
			--(datalength(@cTempl_Alt1tot) < 160) or (datalength(@cTempl_Alt2tot) < 160) or
			--(datalength(@cTempl_Alt3tot) < 160) or (datalength(@cTempl_Alt4tot) < 160) or
			--(datalength(@cTempl_Alt5tot) < 160) or (datalength(@cTempl_Alt6tot) < 26)) 
			(len(@cTempl_Alt1tot) < 160) or (len(@cTempl_Alt2tot) < 160) or
			(len(@cTempl_Alt3tot) < 160) or (len(@cTempl_Alt4tot) < 160) or
			(len(@cTempl_Alt5tot) < 160) or (len(@cTempl_Alt6tot) < 26)) 
			
	    begin 
			SELECT @Alt = 0
	    end

	end
	
	IF (@RetFun != -2) begin
		if (@Pad = 1) 
			if (@Alt = 1) 
				SET @RetFun = 0   -- tem padrao e tem alternativo
			else 
				SET @RetFun = 1   -- tem padrao e nao tem alternativo
		
		if (@Pad = 0) 
			if (@Alt = 1) 
				SET @RetFun = 2   -- nao tem padrao e tem alternativo
			else 
				SET @RetFun = 3   -- nao tem padrao e nao tem alternativo	
	end

	-- VERIFICA SE NAO ACHOU NENHUMA BIOMETRIA E � COMANDO DE ENVIO DE DIGITAIS, DEVERA GUARDAR INFORMACAO EM DIGLOAD001	
	IF ((@RetFun = 3) and (@cTipoCons != '1' )) 
		INSERT into DIGLOAD001 (END_IP, ICARD, BIO_TIPO) 		-- insere em tabela DIGLOAD001
						VALUES (@cEndIp, @cMatric, @cTipBio);
		
	return (@RetFun)

END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlBusca_Sagem_biomet2'))
  DROP PROCEDURE TELESSVR.sqlBusca_Sagem_biomet2
GO

CREATE PROCEDURE TELESSVR.sqlBusca_Sagem_biomet2  @cMatric char(12), @cTipBio char(1), @cEndIp char(15), @cTipoCons char(1),
@cTempl_tit1tot CHAR(160) OUTPUT, @cTempl_tit2tot CHAR(160) OUTPUT, 
@cTempl_tit3tot CHAR(160) OUTPUT, @cTempl_tit4tot CHAR(160) OUTPUT, 
@cTempl_Alt1tot CHAR(160) OUTPUT, @cTempl_Alt2tot CHAR(160) OUTPUT, 
@cTempl_Alt3tot CHAR(160) OUTPUT, @cTempl_Alt4tot CHAR(160) OUTPUT,
@cNivel CHAR(1) OUTPUT,
@cTempl_tit5tot CHAR(160) OUTPUT, @cTempl_Alt5tot CHAR(160) OUTPUT,
@cTempl_tit6tot CHAR(26)  OUTPUT, @cTempl_Alt6tot CHAR(26)  OUTPUT

AS
DECLARE @cTempl_tit4aux CHAR(32), @cTempl_Alt4aux CHAR(32), @cVDigit CHAR(1) 
DECLARE @RetFun int, @Pad int, @Alt int, @nAchou int

BEGIN

	select @RetFun = 3
	select @cTempl_tit1tot = NULL
	select @cTempl_tit2tot = NULL
	select @cTempl_tit3tot = NULL
	select @cTempl_tit4tot = NULL
	select @cTempl_tit4aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	select @cTempl_Alt1tot = NULL
	select @cTempl_Alt2tot = NULL
	select @cTempl_Alt3tot = NULL
	select @cTempl_Alt4tot = NULL
	select @cTempl_Alt4aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL

	set @cNivel = NULL
	set @cVDigit = '2'
	set @nAchou = 0;
	set @Pad = 0;
	set @Alt = 0;
	

	-- PARA VALIDA��O ONLINE 
	IF (@cTipoCons = '1') 
	begin
		IF EXISTS (SELECT Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric) 
		begin
			SELECT @cVDigit = Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric

			-- procura por Templates da matricula
			IF EXISTS (SELECT * FROM CONTDIG_SAGEM  WHERE ICARD = @cMatric)
			begin
				SELECT @cTempl_tit1tot = TEMPL_TIT1,
				   @cTempl_tit2tot = TEMPL_TIT2,
				   @cTempl_tit3tot = TEMPL_TIT3,
				   @cTempl_tit4aux = TEMPL_TIT4,
				   @cTempl_Alt1tot = TEMPL_ALT1,
				   @cTempl_Alt2tot = TEMPL_ALT2,
				   @cTempl_Alt3tot = TEMPL_ALT3,
				   @cTempl_Alt4aux = TEMPL_ALT4,
				   @cNivel = NIVEL
				FROM CONTDIG_SAGEM
				WHERE ICARD = @cMatric
				
				set @nAchou = 1;
			end
			ELSE begin
				IF (CONVERT(INT,@cVDigit) = 2) 
					set @RetFun = -2;
				ELSE begin
					set @Pad = 0;
					set @Alt = 0;
				end
			end
		end
		ELSE
			set @RetFun = -2;
	end
	
	-- PARA COMANDO CARGA DIGITAIS 
	ELSE begin
		-- procura por Templates da matricula
		IF EXISTS (SELECT * FROM CONTDIG_SAGEM  WHERE ICARD = @cMatric)
		begin
			SELECT @cTempl_tit1tot = TEMPL_TIT1,
			   @cTempl_tit2tot = TEMPL_TIT2,
			   @cTempl_tit3tot = TEMPL_TIT3,
			   @cTempl_tit4aux = TEMPL_TIT4,
			   @cTempl_Alt1tot = TEMPL_ALT1,
			   @cTempl_Alt2tot = TEMPL_ALT2,
			   @cTempl_Alt3tot = TEMPL_ALT3,
			   @cTempl_Alt4aux = TEMPL_ALT4
			FROM CONTDIG_SAGEM
			WHERE ICARD = @cMatric
				
			set @nAchou = 1;
		end
		ELSE begin
			set @Pad = 0;
			set @Alt = 0;
		end
	end
	
	-- verifica o conteudo das digitais
	IF (@nAchou = 1) begin
		select @Pad = 1    -- assume que tem template padrao
		select @Alt = 1    -- assume que tem template alternativo
		if ((@cTempl_tit1tot is Null) or (@cTempl_tit2tot is Null) or 
			(@cTempl_tit3tot is Null) or (@cTempl_tit4aux is Null) or
			--(datalength(@cTempl_tit1tot) < 160) or (datalength(@cTempl_tit2tot) < 160) or
			--(datalength(@cTempl_tit3tot) < 160) or (datalength(@cTempl_tit4aux) < 32)) 
			(len(@cTempl_tit1tot) < 160) or (len(@cTempl_tit2tot) < 160) or
			(len(@cTempl_tit3tot) < 160) or (len(@cTempl_tit4aux) < 32)) 
			
		begin
			SELECT @Pad = 0
		end 

		--IF (datalength(@cTempl_tit4aux) = 32) BEGIN
		IF (len(@cTempl_tit4aux) = 32) BEGIN
			SET @cTempl_tit4tot = @cTempl_tit4aux + REPLICATE('0',160-LEN(@cTempl_tit4aux) )
			SET @cTempl_tit5tot = REPLICATE('0', 160)
			SET @cTempl_tit6tot = REPLICATE('0', 26)
		END

		if ((@cTempl_Alt1tot is Null) or (@cTempl_Alt2tot is Null) or
			(@cTempl_Alt3tot is Null) or (@cTempl_Alt4aux is Null) or
			--(datalength(@cTempl_Alt1tot) < 160) or (datalength(@cTempl_Alt2tot) < 160) or
			--(datalength(@cTempl_Alt3tot) < 160) or (datalength(@cTempl_Alt4aux) < 32)) 
			(len(@cTempl_Alt1tot) < 160) or (len(@cTempl_Alt2tot) < 160) or
			(len(@cTempl_Alt3tot) < 160) or (len(@cTempl_Alt4aux) < 32)) 
			
		begin 
			SELECT @Alt = 0
		end

		--IF (datalength(@cTempl_Alt4aux) = 32) BEGIN
		IF (len(@cTempl_Alt4aux) = 32) BEGIN
			SET @cTempl_Alt4tot = @cTempl_Alt4aux + REPLICATE('0',160-LEN(@cTempl_Alt4aux) )
			SET @cTempl_Alt5tot = REPLICATE('0', 160)
			SET @cTempl_Alt6tot = REPLICATE('0', 26)
		END
	end
	
	IF (@RetFun != -2) begin
		if (@Pad = 1) 
			if (@Alt = 1) 
				SET @RetFun = 0   -- tem padrao e tem alternativo
			else 
				SET @RetFun = 1   -- tem padrao e nao tem alternativo
		
		if (@Pad = 0) 
			if (@Alt = 1) 
				SET @RetFun = 2   -- nao tem padrao e tem alternativo
			else 
				SET @RetFun = 3   -- nao tem padrao e nao tem alternativo	
	end

	-- VERIFICA SE NAO ACHOU NENHUMA BIOMETRIA E � COMANDO DE ENVIO DE DIGITAIS, DEVERA GUARDAR INFORMACAO EM DIGLOAD001	
	IF ((@RetFun = 3) and (@cTipoCons != '1' )) 
		INSERT into DIGLOAD001 (END_IP, ICARD, BIO_TIPO) 		-- insere em tabela DIGLOAD001
						VALUES (@cEndIp, @cMatric, @cTipBio);
		
	return (@RetFun)
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlBusca_Tsi1_biomet2'))
  DROP PROCEDURE TELESSVR.sqlBusca_Tsi1_biomet2
GO

CREATE PROCEDURE TELESSVR.sqlBusca_Tsi1_biomet2  @cMatric char(12), @cTipBio char(1), @cEndIp char(15), @cTipoCons char(1),
@cTempl_tit1tot CHAR(160) OUTPUT, @cTempl_tit2tot CHAR(160) OUTPUT, 
@cTempl_tit3tot CHAR(160) OUTPUT, @cTempl_tit4tot CHAR(160) OUTPUT, 
@cTempl_Alt1tot CHAR(160) OUTPUT, @cTempl_Alt2tot CHAR(160) OUTPUT, 
@cTempl_Alt3tot CHAR(160) OUTPUT, @cTempl_Alt4tot CHAR(160) OUTPUT,
@cNivel CHAR(1) OUTPUT,
@cTempl_tit5tot CHAR(160) OUTPUT, @cTempl_Alt5tot CHAR(160) OUTPUT,
@cTempl_tit6tot CHAR(26) OUTPUT, @cTempl_Alt6tot CHAR(26) OUTPUT
AS

DECLARE @cTempl_tit5aux AS CHAR(128), @cTempl_Alt5aux AS CHAR(128), @cVDigit char(1)
DECLARE @RetFun int, @Pad int, @Alt int, @nAchou int

BEGIN
	select @RetFun = 3
	select @cTempl_tit1tot = NULL
	select @cTempl_tit2tot = NULL
	select @cTempl_tit3tot = NULL
	select @cTempl_tit4tot = NULL
	select @cTempl_tit5aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	select @cTempl_Alt1tot = NULL
	select @cTempl_Alt2tot = NULL
	select @cTempl_Alt3tot = NULL
	select @cTempl_Alt4tot = NULL
	select @cTempl_Alt5aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	
	set @cNivel = NULL
	set @cVDigit = '2'
	set @nAchou = 0;
	set @Pad = 0;
	set @Alt = 0;
	
	-- PARA VALIDA��O ONLINE 
	IF (@cTipoCons = '1') 
	begin
		IF EXISTS (SELECT Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric) 
		begin
			SELECT @cVDigit = Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric
			-- procura por Templates da matricula
			IF EXISTS (SELECT * FROM CONTDIG_TSI1  WHERE ICARD = @cMatric)
			begin
				SELECT @cTempl_tit1tot = TEMPL_TIT1,
				   @cTempl_tit2tot = TEMPL_TIT2,
				   @cTempl_tit3tot = TEMPL_TIT3,
				   @cTempl_tit4tot = TEMPL_TIT4,
		   		   @cTempl_tit5aux = TEMPL_TIT5,
				   @cTempl_Alt1tot = TEMPL_ALT1,
				   @cTempl_Alt2tot = TEMPL_ALT2,
				   @cTempl_Alt3tot = TEMPL_ALT3,
		   		   @cTempl_Alt4tot = TEMPL_ALT4,
		   		   @cTempl_Alt5aux = TEMPL_ALT5,
				   @cNivel = NIVEL
				FROM CONTDIG_TSI1
				WHERE ICARD = @cMatric
					
				set @nAchou = 1;
			end
			ELSE begin
				IF (CONVERT(INT,@cVDigit) = 2) 
					set @RetFun = -2;
				ELSE begin
					set @Pad = 0;
					set @Alt = 0;
				end
			end
		end
		ELSE
			set @RetFun = -2;
	end
	
	-- PARA COMANDO CARGA DIGITAIS 
	ELSE begin
		-- procura por Templates da matricula
		IF EXISTS (SELECT * FROM CONTDIG_TSI1  WHERE ICARD = @cMatric)
		begin
			SELECT @cTempl_tit1tot = TEMPL_TIT1,
				   @cTempl_tit2tot = TEMPL_TIT2,
				   @cTempl_tit3tot = TEMPL_TIT3,
				   @cTempl_tit4tot = TEMPL_TIT4,
		   		   @cTempl_tit5aux = TEMPL_TIT5,
				   @cTempl_Alt1tot = TEMPL_ALT1,
				   @cTempl_Alt2tot = TEMPL_ALT2,
				   @cTempl_Alt3tot = TEMPL_ALT3,
		   		   @cTempl_Alt4tot = TEMPL_ALT4,
		   		   @cTempl_Alt5aux = TEMPL_ALT5
			FROM CONTDIG_TSI1
			WHERE ICARD = @cMatric

			set @nAchou = 1;
		end

		ELSE begin
			set @Pad = 0;
			set @Alt = 0;
		end
	end	
	
	-- verifica o conteudo das digitais
	IF (@nAchou = 1) begin
		select @Pad = 1    -- assume que tem template padrao
		select @Alt = 1    -- assume que tem template alternativo
		if ((@cTempl_tit1tot is Null) or (@cTempl_tit2tot is Null) or 
			(@cTempl_tit3tot is Null) or (@cTempl_tit4tot is Null) or 
			(@cTempl_tit5aux is Null) or
			--(datalength(@cTempl_tit1tot) < 160) or (datalength(@cTempl_tit2tot) < 160) or
			--(datalength(@cTempl_tit3tot) < 160) or (datalength(@cTempl_tit4tot) < 160) or 
			--(datalength(@cTempl_tit5aux) < 128)) 
			(len(@cTempl_tit1tot) < 160) or (len(@cTempl_tit2tot) < 160) or
			(len(@cTempl_tit3tot) < 160) or (len(@cTempl_tit4tot) < 160) or 
			(len(@cTempl_tit5aux) < 128)) 
			
		begin
			SELECT @Pad = 0
		end 
	
		IF (datalength(@cTempl_tit5aux) = 128) BEGIN
			SET @cTempl_tit5tot = @cTempl_tit5aux + REPLICATE('0',160-LEN(@cTempl_tit5aux) )
			SET @cTempl_tit6tot = REPLICATE('0', 26)
		END
	
		if ((@cTempl_Alt1tot is Null) or (@cTempl_Alt2tot is Null) or
			(@cTempl_Alt3tot is Null) or (@cTempl_Alt4tot is Null) or 
			(@cTempl_Alt5aux is Null) or
			--(datalength(@cTempl_Alt1tot) < 160) or (datalength(@cTempl_Alt2tot) < 160) or
			--(datalength(@cTempl_Alt3tot) < 160) or (datalength(@cTempl_Alt4tot) < 160) or 
			--(datalength(@cTempl_Alt5aux) < 128)) 
			(len(@cTempl_Alt1tot) < 160) or (len(@cTempl_Alt2tot) < 160) or
			(len(@cTempl_Alt3tot) < 160) or (len(@cTempl_Alt4tot) < 160) or 
			(len(@cTempl_Alt5aux) < 128)) 
			
		begin 
			SELECT @Alt = 0
		end
	
		--IF (datalength(@cTempl_Alt5aux) = 128) BEGIN
		IF (len(@cTempl_Alt5aux) = 128) BEGIN
			SET @cTempl_Alt5tot = @cTempl_Alt5aux + REPLICATE('0',160-LEN(@cTempl_Alt5aux) )
			SET @cTempl_Alt6tot = REPLICATE('0', 26)
		END
	end
	
	IF (@RetFun != -2) begin
		if (@Pad = 1) 
			if (@Alt = 1) 
				SET @RetFun = 0   -- tem padrao e tem alternativo
			else 
				SET @RetFun = 1   -- tem padrao e nao tem alternativo
		
		if (@Pad = 0) 
			if (@Alt = 1) 
				SET @RetFun = 2   -- nao tem padrao e tem alternativo
			else 
				SET @RetFun = 3   -- nao tem padrao e nao tem alternativo	
	end

	-- VERIFICA SE NAO ACHOU NENHUMA BIOMETRIA E � COMANDO DE ENVIO DE DIGITAIS, DEVERA GUARDAR INFORMACAO EM DIGLOAD001	
	IF ((@RetFun = 3) and (@cTipoCons != '1' )) 
		INSERT into DIGLOAD001 (END_IP, ICARD, BIO_TIPO) 		-- insere em tabela DIGLOAD001
						VALUES (@cEndIp, @cMatric, @cTipBio);
		
	return (@RetFun)

END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlBusca_Veri_biomet2'))
  DROP PROCEDURE TELESSVR.sqlBusca_Veri_biomet2
GO

CREATE PROCEDURE TELESSVR.sqlBusca_Veri_biomet2  @cMatric char(12), @cTipBio char(1), @cEndIp char(15), @cTipoCons char(1),
@cTempl_tit1tot CHAR(160) OUTPUT, @cTempl_tit2tot CHAR(160) OUTPUT, 
@cTempl_tit3tot CHAR(160) OUTPUT, @cTempl_tit4tot CHAR(160) OUTPUT, 
@cTempl_Alt1tot CHAR(160) OUTPUT, @cTempl_Alt2tot CHAR(160) OUTPUT, 
@cTempl_Alt3tot CHAR(160) OUTPUT, @cTempl_Alt4tot CHAR(160) OUTPUT,
@cNivel CHAR(1) OUTPUT,
@cTempl_tit5tot CHAR(56) OUTPUT, @cTempl_Alt5tot CHAR(56) OUTPUT
AS

DECLARE @cVDigit CHAR(1) 
DECLARE @RetFun int, @Pad int, @Alt int, @nAchou int


BEGIN
	--select @RetFun = -1
	select @RetFun = 3
	select @cTempl_tit1tot = NULL
	select @cTempl_tit2tot = NULL
	select @cTempl_tit3tot = NULL
	select @cTempl_tit4tot = NULL
	select @cTempl_tit5tot = NULL
	select @cTempl_Alt1tot = NULL
	select @cTempl_Alt2tot = NULL
	select @cTempl_Alt3tot = NULL
	select @cTempl_Alt4tot = NULL
	select @cTempl_Alt5tot = NULL
	
	set @cNivel = NULL
	set @cVDigit = '2'
	set @nAchou = 0;
	set @Pad = 0;
	set @Alt = 0;

	-- PARA VALIDA��O ONLINE 
	IF (@cTipoCons = '1') 
	begin
		IF EXISTS (SELECT Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric) 
		begin
			SELECT @cVDigit = Ver_Digit FROM CONTROLE WHERE ICARD = @cMatric

			-- procura por Templates da matricula
			IF EXISTS (SELECT * FROM CONTDIG_VERI  WHERE ICARD = @cMatric)
			begin
				SELECT @cTempl_tit1tot = TEMPL_TIT1,
					   @cTempl_tit2tot = TEMPL_TIT2,
					   @cTempl_tit3tot = TEMPL_TIT3,
					   @cTempl_tit4tot = TEMPL_TIT4,
					   @cTempl_Alt1tot = TEMPL_ALT1,
					   @cTempl_Alt2tot = TEMPL_ALT2,
					   @cTempl_Alt3tot = TEMPL_ALT3,
					   @cTempl_Alt4tot = TEMPL_ALT4,
					   @cTempl_tit5tot = TEMPL_TIT5,
					   @cTempl_Alt5tot = TEMPL_ALT5,
					   @cNivel = NIVEL
				FROM CONTDIG_VERI
				WHERE ICARD = @cMatric
				
				set @nAchou = 1;
			end
			ELSE begin
				IF (CONVERT(INT,@cVDigit) = 2) 
					set @RetFun = -2;
				ELSE begin
					set @Pad = 0;
					set @Alt = 0;
				end
			end
		end
		ELSE
			set @RetFun = -2;
	end

	-- PARA COMANDO CARGA DIGITAIS 
	ELSE begin
		-- procura por Templates da matricula
		IF EXISTS (SELECT * FROM CONTDIG_VERI  WHERE ICARD = @cMatric)
		begin
			SELECT @cTempl_tit1tot = TEMPL_TIT1,
				   @cTempl_tit2tot = TEMPL_TIT2,
				   @cTempl_tit3tot = TEMPL_TIT3,
				   @cTempl_tit4tot = TEMPL_TIT4,
				   @cTempl_Alt1tot = TEMPL_ALT1,
				   @cTempl_Alt2tot = TEMPL_ALT2,
				   @cTempl_Alt3tot = TEMPL_ALT3,
				   @cTempl_Alt4tot = TEMPL_ALT4,
				   @cTempl_tit5tot = TEMPL_TIT5,
				   @cTempl_Alt5tot = TEMPL_ALT5,
				   @cNivel = NIVEL
			FROM CONTDIG_VERI
			WHERE ICARD = @cMatric
				
			set @nAchou = 1;
		end
		ELSE begin
			set @Pad = 0;
			set @Alt = 0;
		end
	end

	-- verifica o conteudo das digitais
	IF (@nAchou = 1) begin
		select @Pad = 1    -- assume que tem template padrao
		select @Alt = 1    -- assume que tem template alternativo

	    if ((@cTempl_tit1tot is Null) or (@cTempl_tit2tot is Null) or 
			(@cTempl_tit3tot is Null) or (@cTempl_tit4tot is Null) or
			(@cTempl_tit5tot is Null) or 
			--(datalength(@cTempl_tit1tot) < 160) or 		(datalength(@cTempl_tit2tot) < 160) or
			--(datalength(@cTempl_tit3tot) < 160) or 		(datalength(@cTempl_tit4tot) < 160) or
			--(datalength(@cTempl_tit5tot) < 56)) 
			(len(@cTempl_tit1tot) < 160) or (len(@cTempl_tit2tot) < 160) or
			(len(@cTempl_tit3tot) < 160) or (len(@cTempl_tit4tot) < 160) or
			(len(@cTempl_tit5tot) < 56)) 
			
	    begin
			SELECT @Pad = 0
	    end 
	    
	    if ((@cTempl_Alt1tot is Null) or (@cTempl_Alt2tot is Null) or
			(@cTempl_Alt3tot is Null) or (@cTempl_Alt4tot is Null) or
			(@cTempl_Alt5tot is Null) or
			--(datalength(@cTempl_Alt1tot) < 160) or 		(datalength(@cTempl_Alt2tot) < 160) or
			--(datalength(@cTempl_Alt3tot) < 160) or 		(datalength(@cTempl_Alt4tot) < 160) or
			--(datalength(@cTempl_Alt5tot) < 56)) 
			(len(@cTempl_Alt1tot) < 160) or (len(@cTempl_Alt2tot) < 160) or
			(len(@cTempl_Alt3tot) < 160) or (len(@cTempl_Alt4tot) < 160) or
			(len(@cTempl_Alt5tot) < 56)) 
			
	    begin 
			SELECT @Alt = 0
	    end
	end
	
	IF (@RetFun != -2) begin
		if (@Pad = 1) 
			if (@Alt = 1) 
				SET @RetFun = 0   -- tem padrao e tem alternativo
			else 
				SET @RetFun = 1   -- tem padrao e nao tem alternativo
		
		if (@Pad = 0) 
			if (@Alt = 1) 
				SET @RetFun = 2   -- nao tem padrao e tem alternativo
			else 
				SET @RetFun = 3   -- nao tem padrao e nao tem alternativo	
	end

	-- VERIFICA SE NAO ACHOU NENHUMA BIOMETRIA E � COMANDO DE ENVIO DE DIGITAIS, DEVERA GUARDAR INFORMACAO EM DIGLOAD001	
	IF ((@RetFun = 3) and (@cTipoCons != '1' )) 
		INSERT into DIGLOAD001 (END_IP, ICARD, BIO_TIPO) 		-- insere em tabela DIGLOAD001
						VALUES (@cEndIp, @cMatric, @cTipBio);
		
	return (@RetFun)
	
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlcon_coacao_sagemx2'))
  DROP PROCEDURE TELESSVR.sqlcon_coacao_sagemx2
GO

CREATE PROCEDURE TELESSVR.sqlcon_coacao_sagemx2 @cMatric char(12),
@cTempl_Coa1tot CHAR(160) OUTPUT, @cTempl_Coa2tot CHAR(160) OUTPUT, 
@cTempl_Coa3tot CHAR(160) OUTPUT, @cTempl_Coa4tot CHAR(160) OUTPUT, 
@cTempl_Coa5tot CHAR(160) OUTPUT, @cTempl_Coa6tot CHAR(160) OUTPUT 

AS
DECLARE @RetFun int, @Coa int, @cTempl_Coa4aux AS CHAR(32)
BEGIN
	set @RetFun = 1
	set @Coa = 1
	select @cTempl_Coa1tot = NULL
	select @cTempl_Coa2tot = NULL
	select @cTempl_Coa3tot = NULL
	select @cTempl_Coa4tot = NULL
	select @cTempl_Coa4aux = NULL
	select @cTempl_Coa5tot = NULL
	select @cTempl_Coa6tot = NULL
	
	-- procura por Templates da matricula
	IF EXISTS (SELECT * FROM CONTDIG_SAGEM WITH (Index = CONTDIG_SAGEM_IND1) WHERE ICARD = @cMatric)
	begin
	    SELECT @cTempl_Coa1tot = TEMPL_COA1,
		   @cTempl_Coa2tot = TEMPL_COA2,
		   @cTempl_Coa3tot = TEMPL_COA3,
		   @cTempl_Coa4aux = TEMPL_COA4
		FROM CONTDIG_SAGEM
		WHERE ICARD = @cMatric

	    IF ((@cTempl_Coa1tot is Null) or (@cTempl_Coa2tot is Null) or 
			(@cTempl_Coa3tot is Null) or (@cTempl_Coa4tot is Null) or
			--(datalength(@cTempl_Coa1tot) < 160) or (datalength(@cTempl_Coa2tot) < 160) or
			--(datalength(@cTempl_Coa3tot) < 160) or (datalength(@cTempl_Coa4aux) < 32))
			(len(@cTempl_Coa1tot) < 160) or (len(@cTempl_Coa2tot) < 160) or
			(len(@cTempl_Coa3tot) < 160) or (len(@cTempl_Coa4aux) < 32))
			
			SET @Coa = 0
	    ELSE 
	    begin
			SET @cTempl_Coa4tot = @cTempl_Coa4aux + REPLICATE('0',160-LEN(@cTempl_Coa4aux) )
			SET @cTempl_Coa5tot = REPLICATE('0', 160)
			SET @cTempl_Coa6tot = REPLICATE('0', 26)
	    end
	END

	IF (@Coa = 0) 
	begin
		Set @RetFun = 0
	end
	return (@RetFun)
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlcon_coacao2_tsi1'))
  DROP PROCEDURE TELESSVR.sqlcon_coacao2_tsi1
GO

CREATE PROCEDURE TELESSVR.sqlcon_coacao2_tsi1 @cMatric char(12),
@cTempl_Coa1tot CHAR(160) OUTPUT, @cTempl_Coa2tot CHAR(160) OUTPUT, 
@cTempl_Coa3tot CHAR(160) OUTPUT, @cTempl_Coa4tot CHAR(160) OUTPUT, 
@cTempl_Coa5tot CHAR(160) OUTPUT, @cTempl_Coa6tot CHAR(160) OUTPUT 

AS
DECLARE @RetFun int, @Coa int, @cTempl_Coa5aux AS CHAR(128)
BEGIN
	set @RetFun = 1
	set @Coa = 1
	select @cTempl_Coa1tot = NULL
	select @cTempl_Coa2tot = NULL
	select @cTempl_Coa3tot = NULL
	select @cTempl_Coa4tot = NULL
	select @cTempl_Coa5tot = NULL
	select @cTempl_Coa5aux = NULL
	select @cTempl_Coa6tot = NULL
	
	-- procura por Templates da matricula
	IF EXISTS (SELECT * FROM CONTDIG_TSI1 WHERE ICARD = @cMatric)
	begin
	    SELECT @cTempl_Coa1tot = TEMPL_COA1,
		   @cTempl_Coa2tot = TEMPL_COA2,
		   @cTempl_Coa3tot = TEMPL_COA3,
		   @cTempl_Coa4tot = TEMPL_COA4,
		   @cTempl_Coa5aux = TEMPL_COA5
		FROM CONTDIG_TSI1
		WHERE ICARD = @cMatric

	    IF ((@cTempl_Coa1tot is Null) or (@cTempl_Coa2tot is Null) or 
			(@cTempl_Coa3tot is Null) or (@cTempl_Coa4tot is Null) or 
			(@cTempl_Coa5aux is Null) or
			--(datalength(@cTempl_Coa1tot) < 160) or (datalength(@cTempl_Coa2tot) < 160) or
			--(datalength(@cTempl_Coa3tot) < 160) or (datalength(@cTempl_Coa4tot) < 160) or 
			--(datalength(@cTempl_Coa5aux) < 128))
			(len(@cTempl_Coa1tot) < 160) or (len(@cTempl_Coa2tot) < 160) or
			(len(@cTempl_Coa3tot) < 160) or (len(@cTempl_Coa4tot) < 160) or 
			(len(@cTempl_Coa5aux) < 128))
			
			SET @Coa = 0
	    else 
	    begin
			SET @cTempl_Coa5tot = @cTempl_Coa5aux + REPLICATE('0',160-LEN(@cTempl_Coa5aux) )
			SET @cTempl_Coa6tot = REPLICATE('0', 26)
	    end
	END

	IF (@Coa = 0) 
	begin
		Set @RetFun = 0
	end
	return (@RetFun)
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlcon_coacao_omokx2'))
  DROP PROCEDURE TELESSVR.sqlcon_coacao_omokx2
GO

CREATE PROCEDURE TELESSVR.sqlcon_coacao_omokx2 @cMatric char(12),
@cTempl_Coa1tot CHAR(160) OUTPUT, @cTempl_Coa2tot CHAR(160) OUTPUT, 
@cTempl_Coa3tot CHAR(160) OUTPUT, @cTempl_Coa4tot CHAR(160) OUTPUT, 
@cTempl_Coa5tot CHAR(160) OUTPUT, @cTempl_Coa6tot CHAR(160) OUTPUT 

AS
DECLARE @RetFun int, @Coa int
BEGIN
	set @RetFun = 1
	set @Coa = 1
	select @cTempl_Coa1tot = NULL
	select @cTempl_Coa2tot = NULL
	select @cTempl_Coa3tot = NULL
	select @cTempl_Coa4tot = NULL
	select @cTempl_Coa5tot = NULL
	select @cTempl_Coa6tot = NULL
	
	-- procura por Templates da matricula
	IF EXISTS (SELECT * FROM CONTDIG_OMOK WITH (Index = CONTDIG_OMOK_IND1) WHERE ICARD = @cMatric)
	begin
	    SELECT @cTempl_Coa1tot = TEMPL_COA1,
		   @cTempl_Coa2tot = TEMPL_COA2,
		   @cTempl_Coa3tot = TEMPL_COA3,
		   @cTempl_Coa4tot = TEMPL_COA4,
		   @cTempl_Coa5tot = TEMPL_COA5,
		   @cTempl_Coa6tot = TEMPL_COA6
		FROM CONTDIG_OMOK
		WHERE ICARD = @cMatric

	    if ((@cTempl_Coa1tot is Null) or (@cTempl_Coa2tot is Null) or 
			(@cTempl_Coa3tot is Null) or (@cTempl_Coa4tot is Null) or
			(@cTempl_Coa5tot is Null) or (@cTempl_Coa6tot is Null) or 
			--(datalength(@cTempl_Coa1tot) < 160) or (datalength(@cTempl_Coa2tot) < 160) or
			--(datalength(@cTempl_Coa3tot) < 160) or (datalength(@cTempl_Coa4tot) < 160) or
			--(datalength(@cTempl_Coa5tot) < 160) or (datalength(@cTempl_Coa6tot) < 26)) 
			(len(@cTempl_Coa1tot) < 160) or (len(@cTempl_Coa2tot) < 160) or
			(len(@cTempl_Coa3tot) < 160) or (len(@cTempl_Coa4tot) < 160) or
			(len(@cTempl_Coa5tot) < 160) or (len(@cTempl_Coa6tot) < 26)) 
			
	    begin
			SET @Coa = 0
	    end 
	end
	IF (@Coa = 0) 
	begin
		Set @RetFun = 0
	end
	return (@RetFun)
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlcon_viva'))
  DROP PROCEDURE TELESSVR.sqlcon_viva
GO

CREATE PROCEDURE TELESSVR.sqlcon_viva AS

DECLARE
  @cAux CHAR(1)

BEGIN
	SET @cAux = 1
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlload_listadig4'))
  DROP PROCEDURE TELESSVR.sqlload_listadig4
GO

CREATE PROCEDURE TELESSVR.sqlload_listadig4  @cMatric CHAR(12), @cEndIp CHAR(15), @cTipo CHAR(1), @cErro CHAR(1) AS

DECLARE @Ret smallint, @cStatus CHAR(1), @cBioTipo CHAR(1), @ERR INT  , @cAux char(12)

	SET @Ret = 0
	SET LOCK_TIMEOUT 2000
	SET @cBioTipo = '0'
	
	SELECT @cBioTipo = BIO_TIPO FROM DIG002
		WHERE END_IP = @cEndIp;
				  
	IF (@cBioTipo = '6' or @cBioTipo = '7') 		-- (SAGEM)
		UPDATE DIG001 SET STATUS = @cTipo 
			where ICARD = @cMatric and
				  END_IP = @cEndIp;
	ELSE  
		IF (@cBioTipo = '8')		--  (TSI1)
			UPDATE DIG003 SET STATUS = @cTipo 				  
				where ICARD = @cMatric and
				  	END_IP = @cEndIp;
		ELSE
			IF (@cBioTipo != '0')		--  VIRDI ('9') E OUTRAS BIOMETRIAS
				UPDATE DIG004 SET STATUS = @cTipo 				  
					where ICARD = @cMatric and
						END_IP = @cEndIp;
	
	
	-- NOVO
	IF (@cTipo = '0') 		-- NAOU HOUVE ERRO NA CARGA
		INSERT INTO HISTDIG (IFUNC, END_IP, BIO_TIPO, INSEXC, MODO) VALUES (@cMatric, @cEndIp, @cBioTipo, 'I', 'A')	-- TIPO:'I'= INCLUSAO, 'E'=EXCLUSAO; MODO:'A'=AUTOMATICO, 'M'=MANUAL

	ELSE begin	-- HOUVE ERRO NA CARGA, INSERE NA TABELA DE ERROS DIGLOAD001
		--IF (@cTipo = '6') OR (@cTipo = '7') 	-- ERRO DE CARGA (devido a memoria cheiia, minucia errada: que nao adianta enviar a digital novamente ao equipamento )
			INSERT INTO DIGLOAD001 (END_IP, ICARD, BIO_TIPO, NERRO) VALUES (@cEndIp, @cMatric, @cBioTipo, @cErro);
	end
	-- FIM NOVO
	

	UPDATE DIG002 SET DATA_LOAD = getdate() where END_IP = @cEndIp
	
	
	SET LOCK_TIMEOUT -1
	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.trata3_palmv'))
  DROP PROCEDURE TELESSVR.trata3_palmv
GO

CREATE PROCEDURE TELESSVR.trata3_palmv AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_status CHAR(1)
DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000

	-- ********************   ARRUMAR SITUA��ES PARA PALMVEIN INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS PALMVEIN QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA (status '4')
	DECLARE cur_troubleIns1 CURSOR FOR 
		(SELECT distinct ICARD from PALMV014 
			WHERE STATUS = '4'
		)
	OPEN cur_troubleIns1
	FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE cur_troubleIns2 CURSOR FOR 
			(SELECT END_CTRLPALMV from PALMV014 
				WHERE (ICARD = @z_mat and STATUS = '4')
			)
		OPEN cur_troubleIns2
		FETCH NEXT FROM cur_troubleIns2 INTO @z_endip
	
		WHILE (@@fetch_status != -1) BEGIN
			--DELETE PALMV014 WHERE (END_CTRLPALMV = @z_endip and ICARD = @z_mat and STATUS = '4')	-- vai excluir registro porque nao adianta reenviar 
			UPDATE PALMV014 SET STATUS = '0' WHERE (END_CTRLPALMV = @z_endip and ICARD = @z_mat and STATUS = '4')	-- vai alterar status para 0  porque nao adianta reenviar 
	
			UPDATE PALMV004 set status = '1'WHERE (END_CTRLPALMV =  @z_endip AND STATUS = '3') ;
	
			FETCH NEXT FROM cur_troubleIns2 INTO @z_endip
		END
	
	
		CLOSE cur_troubleIns2
		deallocate cur_troubleIns2
	
		FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	END
		
	CLOSE cur_troubleIns1
	deallocate cur_troubleIns1
	

	-- ***********************  TRATA AS PALMVEIN QUE FICARAM PENDENTES NA CARGA	
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS PALMVEINS (DA TAB.PALMV001 CADASTRO)
	-- delete registro de PALMV014 se nao houver cadastro de palmvein desta matricula
	DECLARE cur_autoIns1 CURSOR FOR 
		(SELECT distinct ICARD from PALMV014 
			WHERE STATUS = '3'
		)
	OPEN cur_autoIns1
	FETCH NEXT FROM cur_autoIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		-- VERIFICA SE H� CADASTRO DO PALMVEIN DA MATRICULA
		SELECT @aux_icard = ICARD FROM PALMV001 WHERE ICARD = @z_mat;
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de palmvein desta matricula
			DECLARE cur_autoIns2 CURSOR FOR 
				(SELECT END_CTRLPALMV from PALMV014 
					WHERE (ICARD = @z_mat and STATUS = '3')
				)
			OPEN cur_autoIns2
			FETCH NEXT FROM cur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				--UPDATE PALMV014 set status = '0' WHERE (END_CTRLPALMV = @z_endip and ICARD = @z_mat and STATUS = '3')
				DELETE PALMV014 WHERE (END_CTRLPALMV = @z_endip and ICARD = @z_mat and STATUS = '3')

				UPDATE PALMV004 set status = '1'WHERE (END_CTRLPALMV =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM cur_autoIns2 INTO @z_endip
			END


			CLOSE cur_autoIns2
			deallocate cur_autoIns2
		END

		FETCH NEXT FROM cur_autoIns1 INTO @z_mat
	END
	
	CLOSE cur_autoIns1
	deallocate cur_autoIns1
	
	
	-- altera status dos codins SensoBox para carga de palmvein, se esses n�o estiverem com carga de palmvein ou estiverem pendentes
	DECLARE cur_autoIns1 CURSOR FOR 
		(SELECT distinct END_CTRLPALMV from PALMV014 
			WHERE (STATUS != '0' and STATUS != '2')
		)
	OPEN cur_autoIns1
	FETCH NEXT FROM cur_autoIns1 INTO @z_endip
	
	WHILE (@@fetch_status != -1) BEGIN
		UPDATE PALMV004 set status = '1'
			WHERE END_CTRLPALMV = @z_endip and (STATUS = '0' or STATUS = '3')
			
		FETCH NEXT FROM cur_autoIns1 INTO @z_endip
	END
		
	CLOSE cur_autoIns1
	deallocate cur_autoIns1
	
	
	-- ********************   TRATA EQUIPAMENTOS PALMVEIN QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos PALMVEIN q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos PALMVEIN q tiveram carga de aplicativo 

	DECLARE cur_autoIns1 CURSOR FOR 
		(SELECT distinct END_CTRLPALMV, STATUS from PALMV004 
			WHERE ((status = '5') or 		-- CARGA DE APLICATIVO
				   ((status = '2') and (DATEADD (MINUTE, 2, data_load)  < getdate()) )
				  )
		)
	OPEN cur_autoIns1
	FETCH NEXT FROM cur_autoIns1 INTO @z_endip, @z_status
	while @@fetch_status != -1
	begin
		IF (@z_status = '2') begin		-- situa��o q estava fazendo a carga e deu problema
			UPDATE PALMV014 set status = '1' WHERE (END_CTRLPALMV = @z_endip and STATUS = '2')
			UPDATE PALMV004 set status = '1' WHERE (END_CTRLPALMV = @z_endip)
		end

		ELSE begin
			IF (@z_status = '5') begin		-- HOUVE CARGA DE APLICATIVO, MAS NAO VAI RECARREGAR AS BIOMETRIAS
				UPDATE PALMV004 set status = '0' WHERE (END_CTRLPALMV = @z_endip)
			end
		end
		
				
		FETCH NEXT FROM cur_autoIns1 INTO @z_endip, @z_status
	end
	CLOSE cur_autoIns1
	deallocate cur_autoIns1
	
	
	-- ***********************  TRATA AS PALMVEIN QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUA��O
	-- para palms DE PALMV014 que ficaram em estado carregando '2'	, e o equipamento est� em estado de repouso	, forca o equipamento a carrega-lo novamente
	
	DECLARE cur_autoIns1 CURSOR FOR 
		(SELECT A.END_CTRLPALMV, A.STATUS from PALMV004 A 
			INNER JOIN PALMV014 B ON
				A.status = '0' AND 
				A.END_CTRLPALMV = B.END_CTRLPALMV AND 
				B.STATUS = '2')
	OPEN cur_autoIns1
	FETCH NEXT FROM cur_autoIns1 INTO @z_endip, @z_status
	
	WHILE (@@fetch_status != -1) BEGIN
		UPDATE PALMV014 SET STATUS = '1' 
			WHERE END_CTRLPALMV = @z_endip AND STATUS = '2';
		UPDATE PALMV004 set STATUS = '1' 
			WHERE END_CTRLPALMV = @z_endip;

		FETCH NEXT FROM cur_autoIns1 INTO @z_endip, @z_status;
	END

	
	CLOSE cur_autoIns1
	deallocate cur_autoIns1
	
	
	-- ********************   ARRUMAR SITUA��ES PARA PALMV EXCLUSAO
	
	-- ***********************  TRATA AS PALMV QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins PALMV para exclusao de palmv, se esses n�o estiverem com exclusao de palmv ou estiverem pendentes
	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_CTRLPALMV from PALMV015 
			WHERE STATUS != '0' and STATUS != '2' and STATUS != '4')
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip
	
	WHILE (@@fetch_status != -1) BEGIN
		UPDATE PALMV005 set status = '1'
			WHERE (END_CTRLPALMV = @z_endip) and 
				  (STATUS = '0' or STATUS = '3')
			
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip
	END
	
	CLOSE cur_autoExc1
	deallocate cur_autoExc1
	
	
	-- ********************   TRATA EQUIPAMENTOS PALMV QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 
	
	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_CTRLPALMV,STATUS from PALMV005 
			WHERE ( (status = '5') or 													-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())   
				  )			
		)			
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE PALMV015 set status = '1'
				WHERE (END_CTRLPALMV = @z_endip and status = '2')

			UPDATE PALMV005 set status = '1' 
					where (END_CTRLPALMV = @z_endip )
		end
				
		else if (@z_status = '5') begin
			UPDATE PALMV005 set status = '0' where (END_CTRLPALMV = @z_endip)	
		end;
				
				
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status
	end
	CLOSE cur_autoExc1
	deallocate cur_autoExc1
	

	-- ***********************  TRATA AS PALMV QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUA��O
	-- para palmv de PALMV015 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT a.END_CTRLPALMV, a.status 
			from PALMV005 A 
			INNER JOIN PALMV015 B ON
				A.END_CTRLPALMV = B.END_CTRLPALMV AND 
				A.status = '0' AND 
				B.STATUS = '2') 
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status
	
	WHILE (@@fetch_status != -1) BEGIN
		UPDATE PALMV015 SET STATUS = '1' 
			WHERE END_CTRLPALMV = @z_endip AND STATUS = '2';
		UPDATE PALMV005 set STATUS = '1' 
			WHERE END_CTRLPALMV = @z_endip;
		
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status;
	END
	
	
	CLOSE cur_autoExc1
	deallocate cur_autoExc1

	SET LOCK_TIMEOUT -1
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.trata4_sagem'))
  DROP PROCEDURE TELESSVR.trata4_sagem
GO

CREATE PROCEDURE TELESSVR.trata4_sagem AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)

DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000


	-- ********************   ARRUMAR SITUA��ES PARA SAGEM    -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA (status '4')
	DECLARE cur_troubleIns1 CURSOR FOR 
		(SELECT distinct ICARD from DIG001 
			WHERE STATUS = '4'
		)
	OPEN cur_troubleIns1
	FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE cur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from DIG001 
				WHERE (ICARD = @z_mat and STATUS = '4')
			)
		OPEN cur_troubleIns2
		FETCH NEXT FROM cur_troubleIns2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			--DELETE DIG001 WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '4')	-- vai excluir registro porque nao adianta reenviar 
			UPDATE DIG001 SET STATUS = '0' WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '4')	-- vai alterar status para concluido  porque nao adianta reenviar 

			UPDATE DIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM cur_troubleIns2 INTO @z_endip
		END


		CLOSE cur_troubleIns2
		deallocate cur_troubleIns2

		FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	END
	
	CLOSE cur_troubleIns1
	deallocate cur_troubleIns1



	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS SAGEM (DA TAB.CONTDIG_SAGEM CADASTRO)
	-- delete registro de DIG001 se nao houver cadastro de BIO SAGEM desta matricula
	DECLARE cur_autoIns1 CURSOR FOR 
		(SELECT distinct ICARD from DIG001 
			WHERE STATUS = '3'
		)
	OPEN cur_autoIns1
	FETCH NEXT FROM cur_autoIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		-- VERIFICA SE H� CADASTRO DO BIO SAGEM DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_SAGEM WHERE ICARD = @z_mat;
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO SAGEM desta matricula
			DECLARE cur_autoIns2 CURSOR FOR 
				(SELECT END_IP from DIG001 
					WHERE (ICARD = @z_mat and STATUS = '3')
				)
			OPEN cur_autoIns2
			FETCH NEXT FROM cur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				--UPDATE DIG001 set status = '0' WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '3')
				DELETE DIG001 WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '3')

				UPDATE DIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM cur_autoIns2 INTO @z_endip
			END


			CLOSE cur_autoIns2
			deallocate cur_autoIns2
		END

		FETCH NEXT FROM cur_autoIns1 INTO @z_mat
	END
	
	CLOSE cur_autoIns1
	deallocate cur_autoIns1



	-- altera status de todos os codins para carga de digitais, se esses n�o estiverem com carga de digitais ou estiverem pendentes

	DECLARE cur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO from DIG001 
			WHERE ( status != '0' and status != '2' and			-- biometrias pendentes na carga
					(BIO_TIPO = '6' OR BIO_TIPO = '7')
				  )
		)
	OPEN cur_endip
	FETCH NEXT FROM cur_endip INTO @z_endip, @z_biotipo
	
	WHILE @@fetch_status != -1
	begin
		UPDATE DIG002 set status = '1'						-- FORCA RECARGA DAS BIOMETRIAS PENDENTES, ATIVANDO DIG002
			WHERE (END_IP = @z_endip and 
					(STATUS = '0' or STATUS = '3') and 
					BIO_TIPO = @z_biotipo)
		FETCH NEXT FROM cur_endip INTO @z_endip, @z_biotipo
	end

	CLOSE cur_endip
	deallocate cur_endip




	-- ********************   TRATA EQUIPAMENTOS SAGEM QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos SAGEM q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos SAGEM que tiveram carga de aplicativo ('5') de devem voltar ao estado de repouso. OBS: nao est� fazenda a recarga de biometria automaticamente.
	
	DECLARE cur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from DIG002 
			WHERE ((BIO_TIPO = '6' or BIO_TIPO = '7')
				   and
				   (status = '5' or status = '6' OR		-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())) 
				  )
		)
	OPEN cur_dig02
	FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_biotipo, @z_status
	
	WHILE @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE DIG001 set STATUS = '1'			-- status = 1 (A carregar)
				WHERE (end_ip = @z_endip and status = '2' and BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')
					
			UPDATE DIG002 set status = '1'  		-- FOR�A A RECARGA PARA AQUELS QUE DERAM PROBLEMA
				where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)
		end

		else if (@z_status = '5' or @z_status = '6') begin
			-- exec TELESSVR.recarga_sagem @z_endip							-- CHAMADA DE PROCEDURE QUE PREPARA DIG001 COM AS MATRICULAS A SEREM CARREGADAS NO EQUIPMENTO QUE TEVE CARGA DE APLICATIVO
			-- UPDATE DIG002 set status = '1' where (end_ip = @z_endip)		-- FAZ RECARGA DE BIOMETRIAS SAGEM APOS CARGA DE APLICATIVO, automaticamente

			UPDATE DIG002 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)		-- NAO FAZ RECARGA DE BIOMETRIAS SAGEM APOS CARGA DE APLICATIVO
		end;
		
		FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE cur_dig02
	DEALLOCATE cur_dig02
	

	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUA��O
	-- para BIOMETRIAS  SAGEM DE DIG001 que ficaram em estado carregando '2', e o equipamento est� em estado de repouso	, forca o equipamento a carrega-lo novamente
	
	DECLARE cur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.STATUS from DIG002 A 
			INNER JOIN DIG001 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				(A.BIO_TIPO = '6') or (A.BIO_TIPO = '7')) 
	OPEN cur_dig02
	FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG001 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and (BIO_TIPO = '6' or BIO_TIPO = '7');
		UPDATE DIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip and (BIO_TIPO = '6' or BIO_TIPO = '7');
		
		FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_status;
	END
	CLOSE cur_dig02
	deallocate cur_dig02
	

	


	-- ********************   ARRUMAR SITUA��ES PARA SAGEM    -  EXCLUSAO
	
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins Sagem para exclusao de biometria, se esses n�o estiverem com exclusao de biometria ou estiverem pendentes

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO  from DIG101 
			WHERE ( STATUS != '0' and STATUS != '2' and  STATUS != '4' and 
					(BIO_TIPO = '6' or BIO_TIPO = '7')
				  )
		)
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG102 set status = '1'
			WHERE (END_IP = @z_endip) and 
				(STATUS = '0' or STATUS = '3') and 
				(BIO_TIPO = '6' or BIO_TIPO = '7')

		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE cur_autoExc1
	deallocate cur_autoExc1



	
	
	-- ********************   TRATA EQUIPAMENTOS SAGEM QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from DIG102 
			WHERE ( (BIO_TIPO = '6' or BIO_TIPO = '7')
					and
					(status = '5' or status = '6' or 													-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin

			UPDATE DIG101 set status = '1'
				WHERE (END_IP = @z_endip and STATUS = '2' and BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')

			UPDATE DIG102 set status = '1' 
					where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)
		end
		
		else if (@z_status = '5' or @z_status = '6') begin
			UPDATE DIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;

		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE cur_autoExc1
	deallocate cur_autoExc1



	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUA��O
	-- para digitais de DIG101 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.status from DIG102 A 
			INNER JOIN DIG101 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				(A.BIO_TIPO = '6' or A.BIO_TIPO = '7'))
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG101 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and (BIO_TIPO = '6' or BIO_TIPO = '7');
		UPDATE DIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip AND (BIO_TIPO = '6' or BIO_TIPO = '7');

		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status;
	END
	CLOSE cur_autoExc1
	deallocate cur_autoExc1

	SET LOCK_TIMEOUT -1

GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.trata4_tsi1'))
  DROP PROCEDURE TELESSVR.trata4_tsi1
GO

CREATE PROCEDURE TELESSVR.trata4_tsi1 AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)

DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000


	-- ********************   ARRUMAR SITUA��ES PARA TSI1    -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA  (status '4')
	DECLARE cur_troubleIns1 CURSOR FOR 
		(SELECT distinct ICARD from DIG003 
			WHERE STATUS = '4'
		)
	OPEN cur_troubleIns1
	FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE cur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from DIG003 
				WHERE (ICARD = @z_mat and STATUS = '4')
			)
		OPEN cur_troubleIns2
		FETCH NEXT FROM cur_troubleIns2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			--DELETE DIG003 WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '4')
			UPDATE DIG003 SET STATUS = '0' WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '4')

			UPDATE DIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM cur_troubleIns2 INTO @z_endip
		END


		CLOSE cur_troubleIns2
		deallocate cur_troubleIns2

		FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	END
	
	CLOSE cur_troubleIns1
	deallocate cur_troubleIns1

	

	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS TSI1 (DA TAB.CONTDIG_TSI1 CADASTRO)
	-- delete registro de DIG003 se nao houver cadastro de BIO TSI1 desta matricula
	DECLARE cur_autoIns1 CURSOR FOR 
		(SELECT distinct ICARD from DIG003 
			WHERE STATUS = '3'
		)
	OPEN cur_autoIns1
	FETCH NEXT FROM cur_autoIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		-- VERIFICA SE H� CADASTRO DO BIO TSI1 DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_TSI1 WHERE ICARD = @z_mat;
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO TSI1 desta matricula
			DECLARE cur_autoIns2 CURSOR FOR 
				(SELECT END_IP from DIG003 
					WHERE (ICARD = @z_mat and STATUS = '3')
				)
			OPEN cur_autoIns2
			FETCH NEXT FROM cur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				--UPDATE DIG003 set status = '0' WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '3')
				DELETE DIG003 WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '3')

				UPDATE DIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM cur_autoIns2 INTO @z_endip
			END


			CLOSE cur_autoIns2
			deallocate cur_autoIns2
		END

		FETCH NEXT FROM cur_autoIns1 INTO @z_mat
	END
	
	CLOSE cur_autoIns1
	deallocate cur_autoIns1







	-- altera status de todos os codins para carga de digitais, se esses n�o estiverem com carga de digitais ou estiverem pendentes

	DECLARE cur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO from DIG003 
			WHERE (STATUS != '0' and STATUS != '2' AND BIO_TIPO = '8')		-- biometrias pendentes na carga
		)
	OPEN cur_endip
	FETCH NEXT FROM cur_endip INTO @z_endip, @z_biotipo
	
	while @@fetch_status != -1
	begin
		UPDATE DIG002 set status = '1'
			WHERE (END_IP = @z_endip and 
					(STATUS = '0' or STATUS= '3') and 
				  	BIO_TIPO = @z_biotipo)
		FETCH NEXT FROM cur_endip INTO @z_endip, @z_biotipo
	end
	CLOSE cur_endip
	deallocate cur_endip



	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos TSI1 q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos TSI1 q tiveram carga de aplicativo 
	DECLARE cur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from DIG002 
			WHERE ((BIO_TIPO = '8')
					and
				   (status = '5' or status = '6' OR			-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))
				  )
		)
	OPEN cur_dig02
	FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_biotipo, @z_status

	WHILE @@fetch_status != -1
	begin
		-- OBSERVACAO: PARA BIOMETRIA TSI1, A CARGA DE APLICATIVO NO EQUIPAMENTO NAO APAGA AS BIOMETRIAS, POIS BIOMETRIA TSI1 FICA NO LEITOR E NAO NO EQUIPAMENTO,
		-- LOGO NAO � NECESSARIO FAZER A RECARGA DE BIOMETRIA
		IF (@z_status = '2') begin		-- situa��o q estava fazendo a carga e deu problema

			UPDATE DIG003 set STATUS = '1'			-- status = 1 : a carregar
				WHERE (END_IP = @z_endip and STATUS = '2'  and BIO_TIPO = @z_biotipo) 

			UPDATE DIG002 set status = '1' 
				where (END_IP = @z_endip and BIO_TIPO = @z_biotipo)
		end

		ELSE begin
			IF (@z_status = '5' or @z_status = '6') begin		-- HOUVE CARGA DE APLICATIVO, MAS NAO VAI RECARREGAR AS BIOMETRIAS
				UPDATE DIG002 set status = '0' 
					WHERE (end_ip = @z_endip  and BIO_TIPO = @z_biotipo)
			end
		end
		
		FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end

	CLOSE cur_dig02
	DEALLOCATE cur_dig02
	


	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUA��O
	-- para BIOMETRIAS  TSI1 DE DIG003 que ficaram em estado carregando '2', e o equipamento est� em estado de repouso	, forca o equipamento a carrega-lo novamente

	DECLARE cur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.status from DIG002 A 
			INNER JOIN DIG003 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = '8')
	OPEN cur_dig02
	FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG003 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' AND BIO_TIPO = '8';
		UPDATE DIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip  and BIO_TIPO = '8';
			
		FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_status;
	END
	CLOSE cur_dig02
	deallocate cur_dig02
	


	-- ********************   ARRUMAR SITUA��ES PARA   TSI1   -  EXCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins Sagem para exclusao de biometria, se esses n�o estiverem com exclusao de biometria ou estiverem pendentes

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO from DIG103 
			WHERE (STATUS != '0' and STATUS != '2' and BIO_TIPO = '8')
		)
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG102 set STATUS = '1'
			WHERE (END_IP = @z_endip) and 
			  	  (STATUS = '0' or STATUS = '3') and 
				  (BIO_TIPO = '8')

		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE cur_autoExc1
	deallocate cur_autoExc1
	


	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from DIG102 
			WHERE ( (BIO_TIPO = '8')
					and
					(status = '5' or status = '6' or 													-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip,  @z_biotipo, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE DIG103 set status = '1'
				WHERE (END_IP = @z_endip) and (status = '2') and (BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')

			UPDATE DIG102 set status = '1' 
				WHERE (END_IP = @z_endip  and BIO_TIPO = @z_biotipo)
		end
				
		else if (@z_status = '5' or @z_status = '6') begin
			UPDATE DIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;
				
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE cur_autoExc1
	deallocate cur_autoExc1



	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUA��O
	-- para digitais de DIG103 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.status from DIG102 A 
			INNER JOIN DIG103 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = '8')
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG103 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and BIO_TIPO = '8';
		UPDATE DIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip and BIO_TIPO = '8';
	
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status;
	END
	CLOSE cur_autoExc1
	deallocate cur_autoExc1

	SET LOCK_TIMEOUT -1
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.G3G5_P_GERDIGITAL4'))
  DROP PROCEDURE TELESSVR.G3G5_P_GERDIGITAL4
GO

CREATE PROCEDURE TELESSVR.G3G5_P_GERDIGITAL4 AS

DECLARE @ret CHAR(1)


	SET DATEFORMAT YMD


	set @ret = 0
	
	exec TELESSVR.G3G5_PREP2_SAGEM	-- prepara automatico digitais sagem
	
	exec TELESSVR.G3G5_PREP2_TSI1	-- prepara automatico digitais tsi1

	exec TELESSVR.G3G5_prep2_Palmv	-- prepara PALMV014/PALMV004 (INCLUSAO)  e PALMV015/PALMV005 (EXCLUSAO)

	-- fazer
	--exec TELESSVR.prep_OutrosBios	-- prepara automatico Outras biometrias


	exec TELESSVR.trata4_sagem		-- trata biometria sagem

	exec TELESSVR.trata4_tsi1		-- trata biometria tsi1
	
	exec TELESSVR.trata3_palmv		-- trata PALMVEIN

	-- fazer
	--exec TELESSVR.trata_OutrosBios		-- trata Outras Biometrias
	
	select @ret
	GO


SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

--------------------------------------------------------------------
-- Create date: 	13/04/2020 - 10:06
-- Changed:			12/05/2020 - 15:44
-- Sequence:		0061
-- Redmine: 		@5886
--------------------------------------------------------------------

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sitcoletor_alarme'))
	DROP TRIGGER TELESSVR.sitcoletor_alarme
GO

CREATE trigger TELESSVR.sitcoletor_alarme on TELESSVR.SITCOLETOR for update, insert as
DECLARE

    @v_Alarme_OFF INTEGER = 302,
    @v_datetime DATETIME
    
BEGIN

    SELECT @v_datetime = GETDATE()                              

    INSERT INTO suricato.TbAlarSTrata
    (
        DataColeAlar,
        HoraColeAlar,
        SequColeAlar,
        DataAlar,
        HoraAlar,
        CodiPlan,
        CodiCole,
        CodiSind,
        TipoAlar,
        StatAlar,
        DataRecoAlar,
        HoraRecoAlar,
        UsuaReceChav,
        DescRecoUsua,
        TipoRecoReal,
        EndeEntrCole
    )
    SELECT 
        CONVERT(DATE, CONVERT( VARCHAR, @v_datetime, 101 ), 101),
        DATEPART(SECOND, @v_datetime) + DATEPART(minute, @v_datetime)* 60 + datepart(hour, @v_datetime) * 3600,
        DATEPART(SECOND, @v_datetime),
        CONVERT(DATE, CONVERT( VARCHAR, @v_datetime, 101 ), 101),
        DATEPART(SECOND, @v_datetime) + DATEPART(minute, @v_datetime)* 60 + datepart(hour, @v_datetime) * 3600,
        CodiPlan,
        CodiCole,
        @v_Alarme_OFF,
        CASE INSERTED.STATUS WHEN 0 THEN 1 ELSE 0 END,
        0,
        CONVERT(DATETIME,'12/31/1900 00:00:00', 101),
        0,
        null,
        '',
        null,
        null
    FROM
        suricato.TbCodin
      INNER JOIN INSERTED ON
        NumeEndeCole = INSERTED.ENDIP
      INNER JOIN DELETED ON
        NumeEndeCole = DELETED.ENDIP
      WHERE
        INSERTED.STATUS <> DELETED.STATUS
END
GO

-----------------------------------------------------------------------------
-- CONEX REP V.08.00.01 || CONEX REP V.08.00.01 || CONEX REP V.08.00.01 || --
-----------------------------------------------------------------------------

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'REPADNSR001')
	BEGIN
		CREATE TABLE TELESSVR.REPADNSR001 (
			END_IP		VARCHAR(15) 	DEFAULT '000.000.000.000' NOT NULL CONSTRAINT ct1_REPADNSR001 CHECK ((datalength(end_ip) = 15) and (end_ip NOT IN ('               '))),	
			REP			CHAR(17)		NOT NULL,
			NSR			CHAR(9)			NOT NULL,
			TIPO_INFO	INT				NOT NULL,
			STATUS		CHAR(1)			DEFAULT '0' NOT NULL,
			INFORM		VARCHAR(200),
			DATA_INS	DATETIME 		DEFAULT GETDATE()
		)
	END
GO
IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'REPAUTOBIOF' AND UPPER(COLUMN_NAME) = 'QTD_FUNC')
	ALTER TABLE TELESSVR.REPAUTOBIOF ADD QTD_FUNC INT default 5 CONSTRAINT ct1_REPAUTOBIOF CHECK ((QTD_FUNC >= 0) and (QTD_FUNC <= 200));
GO
IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'REPAUXEMPR' AND UPPER(COLUMN_NAME) = 'IFUNC')
	BEGIN
		TRUNCATE TABLE TELESSVR.REPAUXEMPR
		ALTER TABLE TELESSVR.REPAUXEMPR ADD IFUNC CHAR(12) NOT NULL CONSTRAINT ct1_REPAUXEMPR CHECK (IFUNC not like '%[^0-9]%')
	END
GO
IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'REPAUXEMPR' AND UPPER(COLUMN_NAME) = 'ST')
	ALTER TABLE TELESSVR.REPAUXEMPR ADD ST CHAR(1) default '0' NOT NULL;
GO
IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'REPAUXEMPR_IND1')
    DROP INDEX TELESSVR.REPAUXEMPR.REPAUXEMPR_IND1;
GO
IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'REPAUXEMPR_IND2')
    DROP INDEX TELESSVR.REPAUXEMPR.REPAUXEMPR_IND2;
GO
IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'REPAUXEMPR_IND3')
    DROP INDEX TELESSVR.REPAUXEMPR.REPAUXEMPR_IND3;
GO
IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'REPAUXEMPR_IND1')
    CREATE UNIQUE INDEX REPAUXEMPR_IND1 ON TELESSVR.REPAUXEMPR (END_IP, TIPO, PIS, IFUNC);
GO
IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'REPAUXEMPR_IND2')
    CREATE UNIQUE INDEX REPAUXEMPR_IND2 ON TELESSVR.REPAUXEMPR (END_IP, TIPO, IFUNC);
GO
IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'REPAUXEMPR_IND3')
    CREATE INDEX REPAUXEMPR_IND3 ON TELESSVR.REPAUXEMPR (END_IP, TIPO, ST);
GO
IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'REPLASTCOM')
	BEGIN
		CREATE TABLE TELESSVR.REPLASTCOM (
			END_IP		VARCHAR(15) DEFAULT '000.000.000.000' NOT NULL CONSTRAINT ct1_REPLASTCOM CHECK ((datalength(end_ip) = 15) and (end_ip NOT IN ('               '))),	
			DATA_INS	DATETIME 	DEFAULT GETDATE() -- data/hora da inclusao
		)
	END
GO
IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'REPLASTCOM_IND1')
    DROP INDEX TELESSVR.REPLASTCOM.REPLASTCOM_IND1;
GO
IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'REPLASTCOM_IND1')
    CREATE UNIQUE INDEX REPLASTCOM_IND1 ON TELESSVR.REPLASTCOM (END_IP);
GO


IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlrcon_viva'))
	DROP PROCEDURE TELESSVR.sqlrcon_viva
GO

CREATE PROCEDURE TELESSVR.sqlrcon_viva AS

DECLARE
  @cAux CHAR(1)

BEGIN
	SET @cAux = 1
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlravisa_cpbb_novell_tcp'))
	DROP PROCEDURE TELESSVR.sqlravisa_cpbb_novell_tcp
GO

CREATE PROCEDURE TELESSVR.sqlravisa_cpbb_novell_tcp @pt_aviso char(250)
AS

DECLARE @Ret smallint, @cEndIp char(15), @cAviso char(2), @cStat char(1), @cMens char(30)

	set @Ret    = 0
	set @cEndIp = SUBSTRING(@pt_aviso,  1,15)
	set @cAviso = SUBSTRING(@pt_aviso, 16, 2)
	set @cStat  = SUBSTRING(@pt_aviso, 18, 1)
	set @cMens  = SUBSTRING(@pt_aviso, 19,30)

	if exists (select ST from CP_BN  WHERE AVISO = @cAviso and END_IP = @cEndIp and BLUEB = '00' and TERM = '00') 
	begin
		UPDATE CP_BN SET ST = @cStat, EPN3 = @cMens 
			WHERE AVISO = @cAviso AND
				END_IP = @cEndIp and
				BLUEB = '00' and
				TERM = '00'
	end
	else
	begin
		-- aviso nao existe, sera' inserido novo comando
		INSERT INTO CP_BN (END_IP, AVISO, ST, EPN3) 
			VALUES (@cEndIp, @cAviso, @cStat, @cMens)
    end
              
	SELECT @Ret

GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlrepPto_interj2'))
	DROP PROCEDURE TELESSVR.sqlrepPto_interj2
GO

CREATE PROCEDURE TELESSVR.sqlrepPto_interj2 @cPis char(12), @cDataHora char(12) AS


DECLARE @dDtaHoraTab DATETIME, @dDtaHorPto DATETIME, @offxDtaHoraTab DATETIME
DECLARE @cAuxFunc char(20), @cAuxPis CHAR(20), @ret SMALLINT



-- CONEXREP
		-- coletara do REPEMPR002 todos os IFUNCS q foram cadastrados com o mesmo PIS
		-- guardar� em REPPONTO, todos esses IFUNCS+ PIS com a DATA e HORA da marcacao de Ponto. Exemplo: titular e varios provis�rios com o mesmo valor de PIS
		-- marcacoes offline do REP �s vezes n�o ser�o inseridos em REPPONTO, pois o que est� em REPPONTO pode ser de uma marca��o mais recente. Nesta situa��o, a marca��o offline
		-- ser� gravada em OFFREPPONTO, e atrav�s da trigger desta tabela (que � 'ativada' pelo ConexAcesso) ser� inserida em tab.ULTREPPONTO
	-- FIM CONEXREP
	
	
	-- CONEX ACESSO:
		-- situacao 1: o Conex Acesso ao passar o crach� Titular, procurara pelo Icard  em REPPONTO e far� a validacao de datahora para interjornada
		-- situacao 2: o Conex Acesso ao passar o crach� Provis�rio, procurara pelo Icard (agora do Titular)  em REPPONTO e far� a validacao de datahora para interjornada
		-- ou seja, apesar de ter sido armazenado em REPPONTO v�rios Icards com mesmo PIs, o Conex s� procurar� pelo Icard (q � do Titular), e caso encontre mais de uma linha
		-- com o mesmo Icard, s� ser� considerado o de datahora mais recente
	-- FIM CONEX ACESSO
	


	SET @ret = 1
	
	set DATEFORMAT dmy
	SET @dDtaHorPto = CAST((substring(@cDataHora,1,2)+'-'+
							 substring(@cDataHora,3,2)+'-'+
							 substring(@cDataHora,5,4)+' '+
							 substring(@cDataHora,9,2)+':'+
							 substring(@cDataHora,11,2)) AS datetime);	
							 
	-- cursor que coleta os  ICARDS  com o mesmo PIS
	declare CURSOR_IFUNCPIS cursor for 
		SELECT IFUNC, PIS FROM REPEMPR002 WHERE PIS = @cPis ORDER BY IFUNC
							 
	open CURSOR_IFUNCPIS
	fetch NEXT FROM CURSOR_IFUNCPIS into @cAuxFunc, @cAuxPis
	while @@FETCH_STATUS = 0
    begin
    	-- NESTE LOOP. guardar� em REPPONTO, todos esses IFUNCS+ PIS com a DATA e HORA da marcacao de Ponto
    	SELECT @dDtaHoraTab = DTAHORAREP FROM REPPONTO 
    		WHERE IFUNC = @cAuxFunc AND 
					PIS = @cAuxPis

		IF (@@ROWCOUNT = 0) 
			INSERT INTO REPPONTO (IFUNC, PIS, DTAHORAREP) values (@cAuxFunc, @cAuxPis, @dDtaHorPto)
	
		ELSE begin
			-- verifica se a data/hora que chega do rep � maior que do armazenado
			IF (@dDtaHorPto > @dDtaHoraTab) BEGIN
				UPDATE REPPONTO SET DTAHORAREP = @dDtaHorPto 
					WHERE IFUNC = @cAuxFunc AND PIS = @cAuxPis;
			END
			ELSE BEGIN
				-- verifica se  a data/hora que chega do rep � menor do que est� aarmazenado. 
				-- Se for igual, nada faz. 
				-- Se menor insere (se nada tiver em OFFREPPONTO) OU atualiza a data/hora do registro em OFFREPPONTO
				IF (@dDtaHorPto < @dDtaHoraTab) BEGIN
					SELECT @offxDtaHoraTab = DTAHORAREP FROM OFFREPPONTO
						WHERE IFUNC = @cAuxFunc AND 
							  PIS = @cAuxPis ;
				
					IF (@@ROWCOUNT = 0) 
						INSERT INTO OFFREPPONTO (IFUNC, PIS, DTAHORAREP) values (@cAuxFunc, @cAuxPis, @dDtaHorPto)
					ELSE
						IF (@offxDtaHoraTab != @dDtaHorPto)
							UPDATE OFFREPPONTO SET DTAHORAREP = @dDtaHorPto 
								WHERE IFUNC = @cAuxFunc AND PIS = @cAuxPis;
				END
			END
		end		

		FETCH NEXT FROM CURSOR_IFUNCPIS INTO @cAuxFunc, @cAuxPis
	END
	CLOSE CURSOR_IFUNCPIS
	DEALLOCATE CURSOR_IFUNCPIS

GO	
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlgrava_rep5interj'))
	DROP PROCEDURE TELESSVR.sqlgrava_rep5interj
GO

CREATE PROCEDURE TELESSVR.sqlgrava_rep5interj @NumRep CHAR(17), @Reg1 CHAR(250), @Reg2 CHAR(250), @EndIp  VARCHAR(15), @cInterj char(1), @nTamAdendo smallint, @RegAdendo CHAR(250)
AS
	
DECLARE @nRetorno int
DECLARE @Nsr AS CHAR(9), @TipoReg AS CHAR(1), @TotalReg as CHAR(500)
DECLARE @cAuxPis CHAR(12), @cAuxDta CHAR(12)
DECLARE @nTamAd smallint, @TipoAdendo char(2);
DECLARE @nNumTipoAd INT, @nTamInfoAd INT;



	SET @nRetorno = 1
	SET @Nsr = SUBSTRING (@Reg1, 1, 9)	
	SET @TipoReg = SUBSTRING (@Reg1, 10, 1)	
	SET @TotalReg = @Reg1+coalesce(@Reg2,'')		-- @Reg2 podera ter somente null, e podera dar problema
		

	IF (@TipoReg not in ('1', '2', '3', '4', '5', '6', '9'))
		INSERT INTO REPAFD004 
			(END_IP, REP, NSR, TIPO_REG, STATUS, INFORM) VALUES
			(@EndIp, @NumRep, @Nsr, @TipoReg, '0', @TotalReg)
	ELSE
		BEGIN
			INSERT INTO REPAFD001 
				(END_IP, REP, NSR, TIPO_REG, STATUS, INFORM) VALUES
				(@EndIp, @NumRep, @Nsr, @TipoReg, '0', @TotalReg)
				
			-- VERIFICA SE ERRO , ENTAO GRAVA EM repafd004
			IF (@@ERROR <> 0)
				INSERT INTO REPAFD004 
					(END_IP, REP, NSR, TIPO_REG, STATUS, INFORM) VALUES
					(@EndIp, @NumRep, @Nsr, @TipoReg, '0', @TotalReg)
	
			IF (@TipoReg = '3') 
			BEGIN
				INSERT INTO REPAFD003 
					(END_IP, REP, NSR, TIPO_REG, STATUS, INFORM) VALUES
					(@EndIp, @NumRep, @Nsr, @TipoReg, '0', @TotalReg)
					
				-- para Controle de Acesso Interjornada
				IF (@cInterj = '1') BEGIN
					SET @cAuxPis = SUBSTRING (@TotalReg, 23, 12);		-- pis
					SET @cAuxDta = SUBSTRING (@TotalReg, 11, 12);		-- ddmmyyyyhhmi
					EXEC TELESSVR.sqlrepPto_interj2 @cAuxPis, @cAuxDta
				END
			END
			
			-- VERIFICA SE TEM INFORMA��ES ADICIONAIS 
			SET @nTamAd = @nTamAdendo;
			WHILE (@nTamAd > 0)  BEGIN
				SET @nNumTipoAd = convert(INT, SUBSTRING (@RegAdendo, 1, 2))	-- tipo tem 2 digitos
				SET @nTamInfoAd = convert(INT, SUBSTRING (@RegAdendo, 3, 3))   -- tamanho da informacao tem 3 digitos
				IF (@nTamInfoAd > 200) 
					SET @nTamInfoAd = 200;

				INSERT INTO REPADNSR001 
					(END_IP, REP, NSR, TIPO_INFO, STATUS, INFORM) VALUES
					(@EndIp, @NumRep, @Nsr, @nNumTipoAd, '0', SUBSTRING (@RegAdendo, 6, @nTamInfoAd))


				SET @nTamAd = @nTamAd - (5 + @nTamInfoAd)
			END 
			-- fim de INFORMA��ES ADICIONAIS
					
		END
	return @nRetorno

GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlproc_dadosfunc2'))
	DROP PROCEDURE TELESSVR.sqlproc_dadosfunc2
GO

CREATE PROCEDURE TELESSVR.sqlproc_dadosfunc2 @cEndIp CHAR(15), @cNumRep CHAR(17), @nTotal int, @cLisMat CHAR(200)
AS
DECLARE @nCont int, @nContOK int, @nPos int
DECLARE @cFunc CHAR(12), @cPis CHAR(12), @cNome VARCHAR(52), @cErrMat CHAR(12)
DECLARE @cLisOkMat_1 VARCHAR(70), @cLisOkMat_2 VARCHAR(70), @cLisOkMat_3 VARCHAR(70), @cLisOkMat_4 VARCHAR(70)
DECLARE @cLisPis_1 VARCHAR(70), @cLisPis_2 VARCHAR(70), @cLisPis_3 VARCHAR(70), @cLisPis_4 VARCHAR(70)    
DECLARE @cLisNome_1 VARCHAR(250), @cLisNome_2 VARCHAR(250), @cLisNome_3 VARCHAR(250), @cLisNome_4 VARCHAR(250) 


	SET @nCont = 0
	SET @nContOK = 0

	SET @cLisOkMat_1 = ''		-- assume lista vazia de matriculas ok
	SET @cLisPis_1 = ''
	SET @cLisNome_1 = ''

	SET @cLisOkMat_2 = ''		-- assume lista vazia de matriculas ok
	SET @cLisPis_2 = ''
	SET @cLisNome_2 = ''

	SET @cLisOkMat_3 = ''		-- assume lista vazia de matriculas ok
	SET @cLisPis_3 = ''
	SET @cLisNome_3 = ''

	SET @cLisOkMat_4 = ''		-- assume lista vazia de matriculas ok
	SET @cLisPis_4 = ''
	SET @cLisNome_4 = ''

	SET @cErrMat = ''
	
	WHILE (@nCont < @nTotal) BEGIN
		SET @nPos = (@nCont * 12) + 1;
		SET @cFunc = SUBSTRING (@cLisMat, @nPos, 12);

		-- procura pelo nome e PIS contendo somente 12 digitos
		SELECT @cPis = PIS, @cNome = NOME  
			FROM REPEMPR002 WHERE (IFUNC = @cFunc) and (PIS not like '%[^0-9]%')		-- NAO DEVERA VIR PIS Q TENHA NAO DIGITO E MENOR Q 12 POSICOES

		IF (@@ROWCOUNT = 0) BEGIN
			INSERT INTO REPLOAD001 (END_IP, REP, IFUNC, DIA) 
				VALUES (@cEndIp, @cNumRep, @cFunc, getdate());
					
			if (@cErrMat = '') BEGIN 
				SET @cErrMat = @cFunc 
			END
		END
		ELSE begin
			-- cada 4 matriculas, vai em 1 variavel
			IF (@nCont < 4) begin
				SET @cLisOkMat_1 = @cLisOkMat_1 + @cFunc ;
				SET @cLisPis_1 = @cLisPis_1 + @cPis ;
				SET @cLisNome_1 = @cLisNome_1 + @cNome + ';';
			end
			ELSE IF (@nCont < 8) begin
				SET @cLisOkMat_2 = @cLisOkMat_2 + @cFunc ;
				SET @cLisPis_2 = @cLisPis_2 + @cPis ;
				SET @cLisNome_2 = @cLisNome_2 + @cNome + ';';
			end
			ELSE IF (@nCont < 12) begin
				SET @cLisOkMat_3 = @cLisOkMat_3 + @cFunc ;
				SET @cLisPis_3 = @cLisPis_3 + @cPis ;
				SET @cLisNome_3 = @cLisNome_3 + @cNome + ';';
			end
			ELSE IF (@nCont < 16) begin
				SET @cLisOkMat_4 = @cLisOkMat_4 + @cFunc ;
				SET @cLisPis_4 = @cLisPis_4 + @cPis ;
				SET @cLisNome_4 = @cLisNome_4 + @cNome + ';';
			end
			ELSE begin
				SET @nCont = @nTotal;
			end
			SET @nContOK = @nContOK + 1;
		END
		SET @nCont = @nCont+1;
	END	
	
			
	SELECT @nContOK,
		@cLisOkMat_1, @cLisPis_1, @cLisNome_1, 
		@cLisOkMat_2, @cLisPis_2, @cLisNome_2, 
		@cLisOkMat_3, @cLisPis_3, @cLisNome_3, 
		@cLisOkMat_4, @cLisPis_4, @cLisNome_4, 
		@cErrMat

	GO
			

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqller_RautoExclDigit3'))
	DROP PROCEDURE TELESSVR.sqller_RautoExclDigit3
GO

CREATE PROCEDURE TELESSVR.sqller_RautoExclDigit3 @cEndIp VARCHAR(15) 
AS

declare @nCont smallint
declare @nBloco smallint
declare @nTotal smallint
declare @cStatus char(1)
declare @cBio_Tipo char(1)
declare @ICARD varchar(12)
declare @STATUS char(1)
declare @cListaId VARCHAR(250)
declare @cListaId_1 VARCHAR(250)
declare @cListaId_2 VARCHAR(250)
declare @cListaId_3 VARCHAR(250)
declare @cListaId_4 VARCHAR(250)
declare @cListaId_5 VARCHAR(250)

declare @cListaId_6 VARCHAR(250)
declare @cListaId_7 VARCHAR(250)
declare @cListaId_8 VARCHAR(250)
declare @cListaId_9 VARCHAR(250)
declare @cListaId_10 VARCHAR(250)

	SET @nCont = 0
	SET @nBloco = 1
	SET @nTotal = 0
	
	SET @cListaId = ''
	SET @cListaId_1 = ''
	SET @cListaId_2 = ''
	SET @cListaId_3 = ''
	SET @cListaId_4 = ''
	SET @cListaId_5 = ''
	SET @cListaId_6 = ''
	SET @cListaId_7 = ''
	SET @cListaId_8 = ''
	SET @cListaId_9 = ''
	SET @cListaId_10 = ''

	SET LOCK_TIMEOUT 2000

	-- procura pelo equipamento
	IF EXISTS (SELECT * FROM RDIG102  WHERE END_IP = @cEndIp AND STATUS = '1')
	BEGIN
	    SELECT @cStatus = STATUS, @cBio_Tipo = BIO_TIPO
			FROM RDIG102 NOLOCK
			WHERE END_IP = @cEndIp

		IF (@cStatus = '1') BEGIN
			-- SAGEM
			IF (@cBio_Tipo = '6' or @cBio_Tipo = '7') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG101 
						--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
						WHERE END_IP = @cEndIp AND STATUS != '0'
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 32) 
				while (@@fetch_status != -1) and (@nTotal < 200) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE RDIG101 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					--if (@nCont > 8) begin
					if (@nCont >= 20) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId

						else if (@nBloco = 6) 
							set @cListaId_6 = @cListaId
						else if (@nBloco = 7) 
							set @cListaId_7 = @cListaId
						else if (@nBloco = 8) 
							set @cListaId_8 = @cListaId
						else if (@nBloco = 9) 
							set @cListaId_9 = @cListaId
						else if (@nBloco = 10) 
							set @cListaId_10 = @cListaId


						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			-- TSI1	
			ELSE IF (@cBio_Tipo = '8') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG103 
						--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
						WHERE END_IP = @cEndIp AND STATUS != '0' 
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 32) 
				while (@@fetch_status != -1) and (@nTotal < 200) 		-- no m�ximo 200
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE RDIG103 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					--if (@nCont > 8) begin
					if (@nCont >= 20) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
							
						else if (@nBloco = 6) 
							set @cListaId_6 = @cListaId
						else if (@nBloco = 7) 
							set @cListaId_7 = @cListaId
						else if (@nBloco = 8) 
							set @cListaId_8 = @cListaId
						else if (@nBloco = 9) 
							set @cListaId_9 = @cListaId
						else if (@nBloco = 10) 
							set @cListaId_10 = @cListaId

							
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			-- VIRDI	
			ELSE 
				--IF (@cBio_Tipo = '9') BEGIN		
				IF (@cBio_Tipo != '0') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG104 
						--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
						WHERE END_IP = @cEndIp AND STATUS != '0' 
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 32) 
				while (@@fetch_status != -1) and (@nTotal < 200) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE RDIG104 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					--if (@nCont > 8) begin
					if (@nCont >= 20) begin		-- no maximo 20 por lista
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId

						else if (@nBloco = 6) 
							set @cListaId_6 = @cListaId
						else if (@nBloco = 7) 
							set @cListaId_7 = @cListaId
						else if (@nBloco = 8) 
							set @cListaId_8 = @cListaId
						else if (@nBloco = 9) 
							set @cListaId_9 = @cListaId
						else if (@nBloco = 10) 
							set @cListaId_10 = @cListaId

						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END

			--IF ((@nCont > 0) AND (@nCont <= 8))
			IF ((@nCont > 0) AND (@nCont <= 20))
				if (@nBloco = 1) 
					set @cListaId_1 = @cListaId
				else if (@nBloco = 2) 
					set @cListaId_2 = @cListaId
				else if (@nBloco = 3) 
					set @cListaId_3 = @cListaId
				else if (@nBloco = 4) 
					set @cListaId_4 = @cListaId
				else if (@nBloco = 5) 
					set @cListaId_5 = @cListaId

				else if (@nBloco = 6) 
					set @cListaId_6 = @cListaId
				else if (@nBloco = 7) 
					set @cListaId_7 = @cListaId
				else if (@nBloco = 8) 
					set @cListaId_8 = @cListaId
				else if (@nBloco = 9) 
					set @cListaId_9 = @cListaId
				else if (@nBloco = 10) 
					set @cListaId_10 = @cListaId

			IF (@nTotal = 0) 
				UPDATE RDIG102 SET STATUS = '0' WHERE END_IP = @cEndIp;
			ELSE 
				UPDATE RDIG102 SET 
					STATUS = '2',
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;

		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaId_1 as cListaId_1,
		   @cListaId_2 as cListaId_2,
		   @cListaId_3 as cListaId_3,
		   @cListaId_4 as cListaId_4,
		   @cListaId_5 as cListaId_5,
		   @cListaId_6 as cListaId_6,
		   @cListaId_7 as cListaId_7,
		   @cListaId_8 as cListaId_8,
		   @cListaId_9 as cListaId_9,
		   @cListaId_10 as cListaId_10
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO
	
IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqller_RautoLoadDigit3'))
	DROP PROCEDURE TELESSVR.sqller_RautoLoadDigit3
GO

CREATE PROCEDURE TELESSVR.sqller_RautoLoadDigit3  @cEndIp VARCHAR(15) 
AS

declare @nCont smallint
declare @nBloco smallint
declare @nTotal int
declare @cStatus char(1)
declare @cBio_Tipo char(1)
declare @ICARD varchar(12)
declare @STATUS char(1)
declare @cListaId VARCHAR(250)
declare @cListaId_1 VARCHAR(250)
declare @cListaId_2 VARCHAR(250)
declare @cListaId_3 VARCHAR(250)
declare @cListaId_4 VARCHAR(250)
declare @cListaId_5 VARCHAR(250)
declare @cListaId_6 VARCHAR(250)
declare @cListaId_7 VARCHAR(250)
declare @cListaId_8 VARCHAR(250)
declare @cListaId_9 VARCHAR(250)
declare @cListaId_10 VARCHAR(250)

	SET @nCont = 0
	SET @nBloco = 1
	SET @nTotal = 0
	
	SET @cListaId = ''
	SET @cListaId_1 = ''
	SET @cListaId_2 = ''
	SET @cListaId_3 = ''
	SET @cListaId_4 = ''
	SET @cListaId_5 = ''

	SET @cListaId_6 = ''
	SET @cListaId_7 = ''
	SET @cListaId_8 = ''
	SET @cListaId_9 = ''
	SET @cListaId_10 = ''



	SET LOCK_TIMEOUT 5000

	-- procura pelo equipamento
	IF EXISTS (SELECT * FROM RDIG002  WHERE END_IP = @cEndIp and STATUS = '1')
	BEGIN
	    SELECT @cStatus = STATUS, @cBio_Tipo = BIO_TIPO
			FROM RDIG002
			WHERE END_IP = @cEndIp

		IF (@cStatus = '1') BEGIN
			-- SAGEM
			IF (@cBio_Tipo = '6' or @cBio_Tipo = '7') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG001 
						--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
						WHERE END_IP = @cEndIp AND STATUS != '0' 
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 24) 
				while (@@fetch_status != -1) and (@nTotal < 200) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE RDIG001 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					--if (@nCont >= 5) begin
					if (@nCont >= 20) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId

						else if (@nBloco = 6) 
							set @cListaId_6 = @cListaId
						else if (@nBloco = 7) 
							set @cListaId_7 = @cListaId
						else if (@nBloco = 8) 
							set @cListaId_8 = @cListaId
						else if (@nBloco = 9) 
							set @cListaId_9 = @cListaId
						else if (@nBloco = 10) 
							set @cListaId_10 = @cListaId

						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			-- TSI1
			IF (@cBio_Tipo = '8') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG003 
						--WHERE (END_IP = @cEndIp) and (STATUS != '0') and (STATUS != '2')
						WHERE (END_IP = @cEndIp) and (STATUS != '0') 
					ORDER by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 24) 
				while (@@fetch_status != -1) and (@nTotal < 200) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE RDIG003 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					--if (@nCont >= 5) begin
					if (@nCont >= 20) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
							
						else if (@nBloco = 6) 
							set @cListaId_6 = @cListaId
						else if (@nBloco = 7) 
							set @cListaId_7 = @cListaId
						else if (@nBloco = 8) 
							set @cListaId_8 = @cListaId
						else if (@nBloco = 9) 
							set @cListaId_9 = @cListaId
						else if (@nBloco = 10) 
							set @cListaId_10 = @cListaId
							
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			-- VIRDI E OUTROS
			--IF (@cBio_Tipo = '9') BEGIN		
			IF (@cBio_Tipo != '0') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG004 
						--WHERE (END_IP = @cEndIp) and (STATUS != '0') and (STATUS != '2')
						WHERE (END_IP = @cEndIp) and (STATUS != '0') 
					ORDER by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 24) 
				while (@@fetch_status != -1) and (@nTotal < 200) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE RDIG004 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					--if (@nCont >= 5) begin
					if (@nCont >= 20) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
							
						else if (@nBloco = 6) 
							set @cListaId_6 = @cListaId
						else if (@nBloco = 7) 
							set @cListaId_7 = @cListaId
						else if (@nBloco = 8) 
							set @cListaId_8 = @cListaId
						else if (@nBloco = 9) 
							set @cListaId_9 = @cListaId
						else if (@nBloco = 10) 
							set @cListaId_10 = @cListaId
							
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			--IF ((@nCont > 0) AND (@nCont < 5))
			IF ((@nCont > 0) AND (@nCont < 20))
				if (@nBloco = 1) 
					set @cListaId_1 = @cListaId
				else if (@nBloco = 2) 
					set @cListaId_2 = @cListaId
				else if (@nBloco = 3) 
					set @cListaId_3 = @cListaId
				else if (@nBloco = 4) 
					set @cListaId_4 = @cListaId
				else if (@nBloco = 5) 
					set @cListaId_5 = @cListaId

				else if (@nBloco = 6) 
					set @cListaId_6 = @cListaId
				else if (@nBloco = 7) 
					set @cListaId_7 = @cListaId
				else if (@nBloco = 8) 
					set @cListaId_8 = @cListaId
				else if (@nBloco = 9) 
					set @cListaId_9 = @cListaId
				else if (@nBloco = 10) 
					set @cListaId_10 = @cListaId

			IF (@nTotal = 0) 
				UPDATE RDIG002 SET STATUS = '0' WHERE END_IP = @cEndIp;
			ELSE 
				UPDATE RDIG002 SET 
					STATUS = '2',
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;
		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaId_1 as cListaId_1,
		   @cListaId_2 as cListaId_2,
		   @cListaId_3 as cListaId_3,
		   @cListaId_4 as cListaId_4,
		   @cListaId_5 as cListaId_5,
		   
		   @cListaId_6 as cListaId_6,
		   @cListaId_7 as cListaId_7,
		   @cListaId_8 as cListaId_8,
		   @cListaId_9 as cListaId_9,
		   @cListaId_10 as cListaId_10
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO
	
IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlrhora_gerbiof2'))
	DROP PROCEDURE TELESSVR.sqlrhora_gerbiof2
GO

CREATE PROCEDURE TELESSVR.sqlrhora_gerbiof2 @EndIp CHAR(15), @nTipo INT
AS

DECLARE @xret int, @nQtd int
DECLARE @cHoraIni CHAR(8),	@cHoraFim CHAR(8),	@cHoraCor CHAR(8)		-- 'hh:mi:ss'


BEGIN
	
	SET @xret = 0
	SET @nQtd = 5;
	
	
	IF EXISTS (select * from REPAUTOBIOF where END_IP = @EndIp)
	begin
		IF (@nTipo = 2) 		-- PROCURA POR FAIXA DE EXECU��O DE GERENCIAMENTO DE BIOMETRIA
			SELECT @cHoraIni = INICIO_GERBIO,  @cHoraFim = FINAL_GERBIO, @nQtd = QTD_FUNC  
				FROM REPAUTOBIOF 
				WHERE END_IP = @EndIp 

		ELSE
			SELECT @cHoraIni = INICIO_GERFUN,  @cHoraFim = FINAL_GERFUN, @nQtd = QTD_FUNC  
				FROM REPAUTOBIOF 
				WHERE END_IP = @EndIp 
		
		
		--SELECT CONVERT(VARCHAR(8),GETDATE(),114) AS '114'
		--SELECT CONVERT(@cHoraCor,GETDATE(),114)
		SET @cHoraCor = CONVERT(CHAR(8),GETDATE(),114)
		
		IF (@cHoraIni < @cHoraFim) begin 
			IF ((@cHoraCor >= @cHoraIni) AND (@cHoraCor <= @cHoraFim)) 
				SET @xret = 1;
		end
		ELSE begin
			IF (@cHoraCor >= @cHoraIni) 
				SET @xret = 1;
			ELSE
				IF (@cHoraCor <= @cHoraFim) 
					SET @xret = 1;
		end
	end
	ELSE
		SET @xret = 1
		
	
	
	IF (@xret = 1) 
	begin
		-- nao verificara o valor maximo, pois este ja � verificado em constraint da tabela REPAUTOBIOF, na coluna QTD_FUNC
		--if (@nQtd > 200) 
		--	SET @nQtd = 200;
		if ((@nQtd < 0) OR @nQtd IS NULL)
			SET @nQtd = 0
		
		select @nQtd
	end
	ELSE
		select @xret
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.Prep_RepAuto5'))
	DROP PROCEDURE TELESSVR.Prep_RepAuto5
GO

CREATE PROCEDURE TELESSVR.Prep_RepAuto5 @nQTD INT AS

DECLARE @nCont SMALLINT
DECLARE @nTemLocal SMALLINT
          
DECLARE @c_status CHAR(1)
DECLARE @c_ifunc CHAR(12)
DECLARE @c_endip CHAR(15)
DECLARE @c_grupo CHAR(5)

DECLARE @xc_status CHAR(1)
DECLARE @xc_ifunc CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @ret CHAR(1)

DECLARE @cAux CHAR(1)
DECLARE @cTipo CHAR(1)
DECLARE @nContMax SMALLINT
--DECLARE @nQTD SMALLINT

SET DATEFORMAT YMD


	set @ret = 0
	--set @nQTD = 5 * @nTempo

	SET LOCK_TIMEOUT 5000
	SET DATEFORMAT YMD
	
	
	-- *************** PREPARACAO DE INCLUSAO/EXCLUSAO  FUNCIONARIOS NOS EQUIPAMENTOS (MONTAGEM DAS TABELAS AUXILIARES)
	BEGIN
	
		-- tabela temporaria TMP_T :  TOP(N) linhas de REPNAUTO000 com solicita��o de processamento de Inclusao ('3') e Exclus�o ('8')
		DELETE TMP_T;
		DELETE TMP_NREP001;
		DELETE TMP_NREP002;
		DELETE TMP_NREPGRPATV
		
		--TRUNCATE TABLE TMP_T;
		--TRUNCATE TABLE TMP_NREP001;
		--TRUNCATE TABLE TMP_NREP002;
		--TRUNCATE TABLE TMP_NREPGRPATV;
		
		--INSERT INTO TMP_T select top(5) IFUNC, STATUS, GRUPO from REPNAUTO000 WHERE STATUS = '3' or STATUS = '8' ORDER BY DATA_INS, IFUNC
		--INSERT INTO TMP_T select top(@nQTD) IFUNC, STATUS, GRUPO from REPNAUTO000 WHERE STATUS = '3' or STATUS = '8' ORDER BY DATA_INS, IFUNC
		INSERT INTO TMP_T (IFUNC, STATUS, GRUPO) select top(@nQTD) IFUNC, STATUS, GRUPO from REPNAUTO000 WHERE STATUS = '3' or STATUS = '8' ORDER BY DATA_INS, IFUNC
		
		-- cursor para matriculas X GRUPOS a carregar/excluir
		--DECLARE cur_auto000 CURSOR FOR (select * from TMP_T)
		DECLARE cur_auto000 CURSOR FOR (select IFUNC, STATUS, GRUPO from TMP_T)

		SET @nContMax = 0
		OPEN cur_auto000
		FETCH NEXT FROM cur_auto000 INTO @c_ifunc, @c_status, @c_grupo
		
		--WHILE (@@fetch_status != -1 AND @nContMax < 100)
		WHILE (@@fetch_status != -1 AND @nContMax < @nQTD)
		BEGIN   
			SET @nTemLocal = 0
			
			DELETE TMP_NREP000GRP
			--TRUNCATE TABLE TMP_NREP000GRP
			insert into TMP_NREP000GRP (IFUNC, GRUPO, END_IP, STATUS)		-- inclui em TMP_NREP000GRP TODOS OS REPS Q FAZEM PARTE DO GRUPO EM QUESTAO (NOVO OU VELHO) DO FUNCIONARIO
				select @c_ifunc,  @c_grupo, VIEWGRPREP.end_ip, @c_status
					from VIEWGRPREP
					where
						CAST(VIEWGRPREP.grupo AS INT) = CAST(@c_grupo AS INT)

			IF (@@ROWCOUNT != 0) BEGIN
				SET @nTemLocal = 1
			END
		
		
			IF (@nTemLocal = 1) BEGIN
				DELETE TMP_NREP000OUTROS;
				--TRUNCATE TABLE TMP_NREP000OUTROS;
				
				-- inclui em TMP_NREP000OUTROS TODOS OS REPS Q FAZEM PARTE De outros GRUPOs DO FUNCIONARIO
				INSERT into TMP_NREP000OUTROS (IFUNC, GRUPO,  END_IP, STATUS)		
					select @c_ifunc, VIEWGRPREP.Grupo, VIEWGRPREP.end_ip, @c_status
						from VIEWGRPREP
						where
							(CAST(VIEWGRPREP.grupo AS INT) != CAST(@c_grupo AS INT)) and
							(CAST(VIEWGRPREP.grupo AS INT) in (select CAST(Grupo AS INT) from REPGRPF where IFUNC = @c_ifunc)) and 
							(CAST(VIEWGRPREP.grupo AS INT) not in (SELECT CAST(Grupo AS INT) FROM TMP_NREPGRPATV where IFUNC = @c_ifunc) ) ;
				
				set @nCont = @@ROWCOUNT
				
				-- Insere em tabela resultante OS REGISTROS de TMP_NREP000GRP que n�o tem em TMP_NREP000OUTROS
				IF (@c_status = '3') BEGIN
					set @cTipo = '3'

					DECLARE Rtmp_eqptos cursor for (SELECT END_IP from TMP_NREP000GRP  
						WHERE IFUNC = @c_ifunc and 
							STATUS = @cTipo and  
							CAST(Grupo AS INT) = CAST(@c_grupo AS INT))
							
					OPEN Rtmp_eqptos
					FETCH next from Rtmp_eqptos into @xc_endip
					WHILE @@fetch_status != -1
					BEGIN
						--SET @cAux = null
						--SET @cAux = (SELECT STATUS FROM TMP_NREP000OUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )

						--IF (@cAux is null) BEGIN
						
						SET @nCont = 0;
						SET @nCont = (SELECT count(*) FROM TMP_NREP000OUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
						IF (@nCont = 0)					
						BEGIN
							SET @cAux = (SELECT STATUS from TMP_NREP001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
							
							IF (@cAux is null)  
								INSERT into TMP_NREP001 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo );
							ELSE
								IF (@cAux = '0') 
									UPDATE TMP_NREP001 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip
						END
							
						-- VERIFICA SE FUNCIONARIO X IP JA EST� EM TABELA DE EXCLUSAO, PARA EXCLUIR
						BEGIN
							SET @cAux = null
							SET @cAux = (SELECT STATUS from TMP_NREP002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
							IF (@cAux = '8') 
								DELETE FROM TMP_NREP002 where IFUNC = @c_ifunc and END_IP = @xc_endip;
						END
								
						fetch next from Rtmp_eqptos into @xc_endip
					END 
					
					CLOSE Rtmp_eqptos
					DEALLOCATE Rtmp_eqptos
				END
				
				ELSE IF (@c_status = '8') begin
					set @cTipo = '8'

					DECLARE Rtmp_eqptos cursor for (SELECT END_IP from TMP_NREP000GRP  
						WHERE IFUNC = @c_ifunc and 
							STATUS = @cTipo and
							CAST(Grupo AS INT) = CAST(@c_grupo AS INT) 
							)
					OPEN Rtmp_eqptos
					FETCH next from Rtmp_eqptos into @xc_endip
					WHILE @@fetch_status != -1
					BEGIN
						--SET @cAux = null
						--SET @cAux = (SELECT STATUS FROM TMP_NREP000OUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
						--IF (@cAux is null) BEGIN
						
						SET @nCont = 0;
						SET @nCont = (SELECT count(*) FROM TMP_NREP000OUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip)
						IF (@nCont = 0)					
						BEGIN						
							SET @cAux = (SELECT STATUS from TMP_NREP002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
							
							IF (@cAux is null)  
								INSERT into TMP_NREP002 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo );
							ELSE
								IF (@cAux = '0') 
									UPDATE TMP_NREP002 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip
						END
							
						-- VERIFICA SE FUNCIONARIO X IP JA EST� EM TABELA DE INCLUSAO, PARA INCLUIR
						BEGIN
							SET @cAux = null
							SET @cAux = (SELECT STATUS from TMP_NREP001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
							IF (@cAux = '3') 
								DELETE FROM TMP_NREP002 where IFUNC = @c_ifunc and END_IP = @xc_endip;		-- DEVE-SE EXCLUIR DA TAB.EXCLUSAO TMP_NREP002, PORQUE O EQUIPAMENTO PERTENCE A OUTRO GRUPO QUE VAI INCLUI-LO
								--DELETE FROM TMP_NREP001 where IFUNC = @c_ifunc and END_IP = @xc_endip;	-- ERRADO
						END
								
						fetch next from Rtmp_eqptos into @xc_endip
					END 
					CLOSE Rtmp_eqptos
					DEALLOCATE Rtmp_eqptos
				END
			END

			SET @nContMax = @nContMax + 1
			-- atualiza estado para tratado em REPNAUTO000, SE N�O encontrou equipamento pertencente ao grupo e cai fora para tratar proximo funcionario
			UPDATE REPNAUTO000 SET STATUS = '0' 			
				WHERE IFUNC = @c_ifunc and CAST(Grupo AS INT) = CAST(@c_grupo AS INT)
			
			INSERT INTO TMP_NREPGRPATV (IFUNC, GRUPO) VALUES (@c_ifunc, @c_grupo)

			FETCH NEXT FROM cur_auto000 INTO @c_ifunc, @c_status, @c_grupo
		END
		
		CLOSE cur_auto000
		DEALLOCATE cur_auto000
	END
			

	-- ***************  TRATA OS IFUNCS INSERIDOS  ***************
	SET @nCont = (SELECT COUNT(*) FROM TMP_NREP001 WHERE STATUS = '3')
	
	IF (@nCont != 0) BEGIN
	
		-- ESTE BLOCO ABAIXO EU TIREI PORQUE O SQL_REPAUTOF() FARA ESTA PARTE DE INSERIR EM REPAUTO001 OS QUE NAO EXISTEM
		/*
		-- coloca o codin na tab. REPAUTO001 (CARGA LISTA) se eqpto  n�o existir
		insert into REPAUTO001 (END_IP, STATUS)
			select distinct end_ip, '0'
			from TMP_NREP001
			where  TMP_NREP001.STATUS = '3'	 and 
				TMP_NREP001.end_ip not in ( select end_ip from REPAUTO001 )
		
		*/
		
		
		-- insere ifunc-rep em tab. REPAUTO011, se n�o existir em tab.
		DECLARE cur_tmpauto000 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_NREP001 where STATUS = '3')
		OPEN cur_tmpauto000
		FETCH NEXT FROM cur_tmpauto000 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE REPAUTO011 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO REPAUTO011 (IFUNC, END_IP, STATUS) 
								values (@xc_ifunc, @xc_endip, '1');
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			DELETE FROM REPAUTO012 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	-- DELETA DA TABELA DE EXCLUSAO

			FETCH NEXT FROM cur_tmpauto000 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpauto000
		DEALLOCATE cur_tmpauto000
	END

	
	-- ***************   TRATA OS IFUNCS EXCLUIDOS ***************
	SET @nCont = (SELECT COUNT(*) FROM TMP_NREP002 WHERE STATUS = '8')
	
	if (@nCont != 0) BEGIN
	
		-- ESTE BLOCO ABAIXO EU TIREI PORQUE O SQL_REPAUTOF() FARA ESTA PARTE DE INSERIR EM REPAUTO001 OS QUE NAO EXISTEM
		/*
		-- coloca o codin na tab. REPAUTO002 (EXCLUSAO) se o eqpto n�o existir
		INSERT INTO REPAUTO002 (END_IP, STATUS) 
			select distinct end_ip, '0'
			from TMP_NREP002
			where TMP_NREP002.STATUS = '8'	and 
				  TMP_NREP002.end_ip not in ( select end_ip from REPAUTO002 )
		*/				
	
		-- insere ifunc-rep em tab. REPAUTO012, se n�o existir em tab.
		DECLARE cur_tmpauto000 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_NREP002 where STATUS = '8')
		OPEN cur_tmpauto000
		FETCH NEXT FROM cur_tmpauto000 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE REPAUTO012 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO REPAUTO012 (IFUNC, END_IP, STATUS) 
								values (@xc_ifunc, @xc_endip, '1');
			end

			-- deleta o ifunc da tabela de inclusao para o rep especifico do grupo
			DELETE FROM REPAUTO011 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	-- DELETA DA TABELA DE INCLUSAO

			FETCH NEXT FROM cur_tmpauto000 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpauto000
		DEALLOCATE cur_tmpauto000
	end

	/*
	DELETE TMP_T
	DELETE TMP_NREP000GRP

	DELETE TMP_NREP000OUTROS
	DELETE TMP_NREPGRPATV
	
	DELETE TMP_NREP001
	DELETE TMP_NREP002
	*/

	/*
	TRUNCATE TABLE TMP_T
	TRUNCATE TABLE TMP_NREP000GRP
	TRUNCATE TABLE TMP_NREP000OUTROS
	TRUNCATE TABLE TMP_NREPGRPATV
	TRUNCATE TABLE TMP_NREP001
	TRUNCATE TABLE TMP_NREP002
	*/
	SET LOCK_TIMEOUT -1
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlrep_autoIns3'))
	DROP PROCEDURE TELESSVR.sqlrep_autoIns3
GO

CREATE PROCEDURE TELESSVR.sqlrep_autoIns3 @cEndIp CHAR(15), @nMax SMALLINT AS
declare @nCont smallint
declare @nBloco smallint
declare @nTotal smallint
declare @cStat001 char(1)
declare @IFUNC char(12)
declare @STATUS char(1)
declare @cListaF VARCHAR(250)
declare @cListaFunc_1 VARCHAR(250)
declare @cListaFunc_2 VARCHAR(250)
declare @cListaFunc_3 VARCHAR(250)
declare @cListaFunc_4 VARCHAR(250)
declare @cListaFunc_5 VARCHAR(250)
declare @cListaFunc_6 VARCHAR(250)
declare @cListaFunc_7 VARCHAR(250)
declare @cListaFunc_8 VARCHAR(250)
declare @cListaFunc_9 VARCHAR(250)
declare @cListaFunc_10 VARCHAR(250)


	SET @nCont = 0
	SET @nBloco = 1
	SET @nTotal = 0
	
	SET @cListaF = ''
	SET @cListaFunc_1 = ''
	SET @cListaFunc_2 = ''
	SET @cListaFunc_3 = ''
	SET @cListaFunc_4 = ''
	SET @cListaFunc_5 = ''
	SET @cListaFunc_6 = ''
	SET @cListaFunc_7 = ''
	SET @cListaFunc_8 = ''
	SET @cListaFunc_9 = ''
	SET @cListaFunc_10 = ''

	SET LOCK_TIMEOUT 5000
	-- procura pelo equipamento
	IF EXISTS (SELECT * FROM REPAUTO001 WITH (Index = REPAUTO001_IND1) WHERE END_IP = @cEndIp)
	BEGIN
	    SELECT @cStat001 = STATUS
			FROM REPAUTO001
			WHERE END_IP = @cEndIp

		IF (@cStat001 = '1') BEGIN
		
			UPDATE REPAUTO001 SET 
				STATUS = '2', 
				DATA_LOAD = getdate()
			WHERE END_IP = @cEndIp;
		
		
			DECLARE linsf001_cur CURSOR FOR
				SELECT TOP(@nMax) IFUNC, STATUS FROM REPAUTO011 
					--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
					WHERE END_IP = @cEndIp AND STATUS != '0' 
					order by IFUNC;

			open linsf001_cur
			fetch next from linsf001_cur into @IFUNC, @STATUS
			while (@@fetch_status != -1) and (@nTotal < @nMax) 
			begin
				SET @cListaF = @cListaF + @IFUNC
				--UPDATE REPAUTO011 set STATUS = '2' where current of linsf001_cur
				UPDATE REPAUTO011 set STATUS = '2' 
					where IFUNC = @IFUNC AND END_IP = @cEndIp
				SET @nCont = @nCont+1
				set @nTotal = @nTotal + 1


				if (@nCont >= 20) begin
					if (@nBloco = 1) 
						set @cListaFunc_1 = @cListaF
					else if (@nBloco = 2) 
						set @cListaFunc_2 = @cListaF
					else if (@nBloco = 3) 
						set @cListaFunc_3 = @cListaF
					else if (@nBloco = 4) 
						set @cListaFunc_4 = @cListaF
					else if (@nBloco = 5) 
						set @cListaFunc_5 = @cListaF
					else if (@nBloco = 6) 
						set @cListaFunc_6 = @cListaF
					else if (@nBloco = 7) 
						set @cListaFunc_7 = @cListaF
					else if (@nBloco = 8) 
						set @cListaFunc_8 = @cListaF
					else if (@nBloco = 9) 
						set @cListaFunc_9 = @cListaF
					else if (@nBloco = 10) 
						set @cListaFunc_10 = @cListaF
					set @cListaF = ''
					set @nBloco = @nBloco+1
					set @nCont = 0
				end
				fetch next from linsf001_cur into @IFUNC, @STATUS
			end
			close linsf001_cur
			deallocate linsf001_cur
			
			if ((@nCont > 0) and (@nCont < 20))
				if (@nBloco = 1) 
					set @cListaFunc_1 = @cListaF
				else if (@nBloco = 2) 
					set @cListaFunc_2 = @cListaF
				else if (@nBloco = 3) 
					set @cListaFunc_3 = @cListaF
				else if (@nBloco = 4) 
					set @cListaFunc_4 = @cListaF
				else if (@nBloco = 5) 
					set @cListaFunc_5 = @cListaF
				else if (@nBloco = 6) 
					set @cListaFunc_6 = @cListaF
				else if (@nBloco = 7) 
					set @cListaFunc_7 = @cListaF
				else if (@nBloco = 8) 
					set @cListaFunc_8 = @cListaF
				else if (@nBloco = 9) 
					set @cListaFunc_9 = @cListaF
				else if (@nBloco = 10) 
					set @cListaFunc_10 = @cListaF
					
			IF (@nTotal = 0) 
				UPDATE REPAUTO001 SET STATUS = '0' WHERE END_IP = @cEndIp;
			ELSE 
				UPDATE REPAUTO001 SET 
					STATUS = '2', 
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;
		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaFunc_1 as cListaFunc_1,
		   @cListaFunc_2 as cListaFunc_2,
		   @cListaFunc_3 as cListaFunc_3,
		   @cListaFunc_4 as cListaFunc_4,
		   @cListaFunc_5 as cListaFunc_5,
		   @cListaFunc_6 as cListaFunc_6,
		   @cListaFunc_7 as cListaFunc_7,
		   @cListaFunc_8 as cListaFunc_8,
		   @cListaFunc_9 as cListaFunc_9,
		   @cListaFunc_10 as cListaFunc_10
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlrep_fimInsAuto3'))
	DROP PROCEDURE TELESSVR.sqlrep_fimInsAuto3
GO

CREATE PROCEDURE TELESSVR.sqlrep_fimInsAuto3  @cEndIp CHAR(15), @cStat CHAR(1) AS

declare @nCont smallint
declare @nErr smallint
declare @Aux char(12)
declare @IFUNC char(12)
declare @STATUS char(1)

	SET @nCont = 0
	SET @nErr = 0
	SET LOCK_TIMEOUT 5000
	DECLARE lfim011_cur CURSOR FOR
				SELECT IFUNC, STATUS FROM REPAUTO011 
					WHERE END_IP = @cEndIp AND STATUS = '2'
					order by IFUNC;

	open lfim011_cur
	fetch next from lfim011_cur into @IFUNC, @STATUS
	while (@@fetch_status != -1) 
	begin
	
		-- NOVO : EXCLUI LINHA SE FICOU COM STATUS '0'
		IF (@cStat = '0')
			DELETE REPAUTO011 where IFUNC = @IFUNC AND END_IP = @cEndIp        --WHERE current of lfim011_cur 
		ELSE
			update REPAUTO011 set STATUS = @cStat where current of lfim011_cur 
		SET @nCont = @nCont+1

		fetch next from lfim011_cur into @IFUNC, @STATUS
	end
	close lfim011_cur
	deallocate lfim011_cur
	
	UPDATE REPAUTO001 SET STATUS = @cStat WHERE END_IP = @cEndIp;
	SET LOCK_TIMEOUT -1

	return @nCont	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlrep_fimExcAuto4'))
	DROP PROCEDURE TELESSVR.sqlrep_fimExcAuto4
GO

CREATE PROCEDURE TELESSVR.sqlrep_fimExcAuto4  @cEndIp CHAR(15), @cStat CHAR(1) AS

declare @nCont smallint
declare @nErr smallint
declare @Aux char(12)
declare @IFUNC char(12)
declare @STATUS char(1)

	SET LOCK_TIMEOUT 5000
	SET @nCont = 0
	SET @nErr = 0
	DECLARE lexcf002_cur CURSOR FOR
				SELECT IFUNC, STATUS FROM REPAUTO012 
					WHERE END_IP = @cEndIp AND STATUS = '2'
					order by IFUNC;

	open lexcf002_cur
	fetch next from lexcf002_cur into @IFUNC, @STATUS
	while (@@fetch_status != -1)
	begin
		-- NOVO : EXCLUI LINHA SE FICOU COM STATUS '0'
		IF (@cStat = '0') BEGIN
			INSERT INTO HISTREPFUN (IFUNC, END_IP, INSEXC, MODO)	VALUES (@IFUNC, @cEndIp, 'E', 'A');		-- TIPO:'I'= INCLUSAO, 'E'=EXCLUSAO; MODO:'A'=AUTOMATICO, 'M'=MANUAL
			DELETE REPAUTO012 where IFUNC = @IFUNC AND END_IP = @cEndIp        --WHERE current of lexcf002_cur 
		END
		ELSE
			update REPAUTO012 set STATUS = @cStat where current of lexcf002_cur 
		SET @nCont = @nCont+1
		-- fim NOVO
	
	
		--update REPAUTO012 set STATUS = @cStat where current of lexcf002_cur 
		--SET @nCont = @nCont+1

		fetch next from lexcf002_cur into @IFUNC, @STATUS
	end
	close lexcf002_cur
	deallocate lexcf002_cur
	
	IF EXISTS (select END_IP FROM REPLASTCOM WHERE END_IP = @cEndIp) 
		UPDATE REPLASTCOM SET DATA_INS = GETDATE() WHERE END_IP = @cEndIp;
	ELSE
		INSERT INTO REPLASTCOM (END_IP, DATA_INS) VALUES (@cEndIp, GETDATE());

	UPDATE REPAUTO002 SET STATUS = @cStat WHERE END_IP = @cEndIp;
	SET LOCK_TIMEOUT -1


	return @nCont	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlproc_icardpis2'))
	DROP PROCEDURE TELESSVR.sqlproc_icardpis2
GO

CREATE PROCEDURE TELESSVR.sqlproc_icardpis2 @cEndIp CHAR(15), @cNumRep CHAR(17), @nTotal int, @cInicio CHAR(1), @cTipoCom CHAR(1), @cProcLisMat1 VARCHAR(250), @cProcLisMat2 VARCHAR(250), @cProcLisMat3 VARCHAR(250)
AS
DECLARE @cLisMat as VARCHAR(750)
DECLARE @Retfun int, @RetAux int, @nCont int, @nContOK int, @nPos int
DECLARE @cFunc VARCHAR(12), @cPis VARCHAR(12), @cNome VARCHAR(52)
DECLARE @cLisOKMat_1 VARCHAR(250), @cLisPis_1 VARCHAR(250) 
DECLARE @cLisOKMat_2 VARCHAR(250), @cLisPis_2 VARCHAR(250) 
DECLARE @cLisOKMat_3 VARCHAR(250), @cLisPis_3 VARCHAR(250) 
DECLARE @cErrMat VARCHAR(250)



	SET @nCont = 0
	SET @nContOK = 0

	SET @cLisOKMat_1 = ''		-- assume lista vazia de matriculas ok
	SET @cLisPis_1 = ''

	SET @cLisOKMat_2 = ''		-- assume lista vazia de matriculas ok
	SET @cLisPis_2 = ''

	SET @cLisOKMat_3 = ''		-- assume lista vazia de matriculas ok
	SET @cLisPis_3 = ''

	SET @cErrMat = NULL

	SET @cLisMat = @cProcLisMat1+coalesce(@cProcLisMat2,'')+coalesce(@cProcLisMat3,'')

	-- se � inicio de busca, limpa tabela auxiliar para o rep em questao no modo automatico ou manual
	IF (@cInicio = '1') begin 

		DELETE REPAUXEMPR WHERE END_IP = @cEndIp and TIPO = @cTipoCom;
		IF (@@ROWCOUNT = 0) begin
			SET @RetAux = 0
		END
	END 

	-- inicia a busca da lista de matriculas
	
	WHILE (@nCont < @nTotal) BEGIN
		SET @nPos = (@nCont * 12) + 1;
		SET @cFunc = SUBSTRING (@cLisMat, @nPos, 12);

		-- procura pelo nome e PIS contendo somente 12 digitos
		SELECT @cPis = PIS, @cNome = NOME  
			FROM REPEMPR002 WHERE (IFUNC = @cFunc) and (PIS not like '%[^0-9]%')		-- NAO DEVERA VIR PIS Q TENHA NAO DIGITO E MENOR Q 12 POSICOES

		IF (@@ROWCOUNT = 0) BEGIN
			INSERT INTO REPLOAD001 (END_IP, REP, IFUNC, DIA) 
				VALUES (@cEndIp, @cNumRep, @cFunc, getdate());
					
			if (@cErrMat IS null) BEGIN 
				SET @cErrMat = @cFunc 
			END
		END
		ELSE begin
			-- cada 20 matriculas, vai em 1 variavel, pois somente 20 matriculs (12 * 20) cabem em 250
			IF (@nContOK < 20) begin
				SET @cLisOKMat_1 = @cLisOKMat_1 + @cFunc ;
				SET @cLisPis_1 = @cLisPis_1 + @cPis ;
			end
			ELSE IF (@nContOK < 40) begin
				SET @cLisOKMat_2 = @cLisOKMat_2 + @cFunc ;
				SET @cLisPis_2 = @cLisPis_2 + @cPis ;
			end
			ELSE IF (@nContOK < 60) begin
				SET @cLisOKMat_3 = @cLisOKMat_3 + @cFunc ;
				SET @cLisPis_3 = @cLisPis_3 + @cPis ;
			end
			ELSE begin
				SET @nCont = @nTotal;
			end
			SET @nContOK = @nContOK + 1;
			
			-- guarda informacoes de Pis e Nome em tabela auxilar REPAUXEMPR
			UPDATE REPAUXEMPR SET NOME = @cNome, TIPO = @cTipoCom, ST = '0'  
				WHERE END_IP = @cEndIp and TIPO = @cTipoCom and PIS = @cPis;

			IF (@@ROWCOUNT = 0) BEGIN
				INSERT INTO REPAUXEMPR (END_IP, PIS, NOME, TIPO, IFUNC, ST) VALUES 
					(@cEndIp, @cPis, @cNome, @cTipoCom, @cFunc, '0')		-- cTipoCom :'0' = carga via comando, 1 = automatico
			END
			
		END
		SET @nCont = @nCont+1;
	END	
	
			
	SELECT @nContOK,
		@cLisOKMat_1, @cLisPis_1, 
		@cLisOKMat_2, @cLisPis_2, 
		@cLisOKMat_3, @cLisPis_3, 
		@cErrMat

	GO
			

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlprephist_RStF'))
	DROP PROCEDURE TELESSVR.sqlprephist_RStF
GO

CREATE PROCEDURE TELESSVR.sqlprephist_RStF @LMat1 VARCHAR(255), @LMat2 VARCHAR(255), @LMat3 VARCHAR(255), @LMat4 VARCHAR(255), @cEndIp CHAR(15), @cModo CHAR(1)
AS

DECLARE @Ret smallint , @Tam INT, @Pos INT, @cAcao CHAR(1), @cMat CHAR(12)

	SET @Ret = 0
	
		
	-- analise de LMat1
	SET @Tam = len(@LMat1) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin

			SET @cMat = SUBSTRING (@LMat1, @Pos, 12);
			UPDATE REPAUXEMPR SET ST = '1' 
				WHERE END_IP = @cEndIp AND 
					  TIPO = @cModo AND 
					  IFUNC = @cMat
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat2
	SET @Tam = len(@LMat2) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin

			SET @cMat = SUBSTRING (@LMat2, @Pos, 12);
			UPDATE REPAUXEMPR SET ST = '1' 
				WHERE END_IP = @cEndIp AND 
					  TIPO = @cModo AND 
					  IFUNC = @cMat
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat3
	SET @Tam = len(@LMat3) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin

			SET @cMat = SUBSTRING (@LMat3, @Pos, 12);
			UPDATE REPAUXEMPR SET ST = '1' 
				WHERE END_IP = @cEndIp AND 
					  TIPO = @cModo AND 
					  IFUNC = @cMat
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat4
	SET @Tam = len(@LMat4) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin
	
			SET @cMat = SUBSTRING (@LMat4, @Pos, 12);
			UPDATE REPAUXEMPR SET ST = '1' 
				WHERE END_IP = @cEndIp AND 
					  TIPO = @cModo AND 
					  IFUNC = @cMat
		end
	END;


	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlfinal_histRStF'))
	DROP PROCEDURE TELESSVR.sqlfinal_histRStF
GO

CREATE PROCEDURE TELESSVR.sqlfinal_histRStF @LMat1 VARCHAR(255), @LMat2 VARCHAR(255), @LMat3 VARCHAR(255), @LMat4 VARCHAR(255), @cEndIp CHAR(15), @cModo CHAR(1)
AS

DECLARE @Ret smallint , @Tam INT, @Pos INT, @cIFUNC CHAR(12), @cPIS CHAR(12)

	SET @Ret = 0
	
		
	-- analise de LMat1
	SET @Tam = len(@LMat1) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) 
		begin

			SET @cPIS = SUBSTRING (@LMat1, @Pos, 12);
			
			DECLARE lhistf_cur CURSOR FOR
			SELECT IFUNC FROM REPAUXEMPR 
				WHERE END_IP = @cEndIp AND 
				   TIPO = @cModo AND 
					  PIS = @cPIS AND 
					  ST = '1'
				ORDER by IFUNC;
			
			OPEN lhistf_cur
			FETCH next from lhistf_cur into @cIFUNC
			WHILE (@@fetch_status != -1) 
			BEGIN
				UPDATE REPAUXEMPR SET ST = '2' where current of lhistf_cur
					--WHERE END_IP = @cEndIp AND 
					--		TIPO = @cModo AND 
					--		PIS = @cPIS AND
					--		IFUNC = @cIFUNC AND
					--		ST = '1'
				
				FETCH next from lhistf_cur into @cIFUNC
			END
				
			CLOSE lhistf_cur
			DEALLOCATE lhistf_cur

			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat2
	SET @Tam = len(@LMat2) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) 
		begin

			SET @cPIS = SUBSTRING (@LMat2, @Pos, 12);
			
			DECLARE lhistf_cur CURSOR FOR
			SELECT IFUNC FROM REPAUXEMPR 
				WHERE END_IP = @cEndIp AND 
				      TIPO = @cModo AND 
					  PIS = @cPIS AND 
					  ST = '1'
				ORDER by IFUNC;
			
			OPEN lhistf_cur
			FETCH next from lhistf_cur into @cIFUNC
			WHILE (@@fetch_status != -1) 
			BEGIN
				UPDATE REPAUXEMPR SET ST = '2' where current of lhistf_cur
					--WHERE END_IP = @cEndIp AND 
					--		TIPO = @cModo AND 
					--		PIS = @cPIS AND
					--		IFUNC = @cIFUNC AND
					--		ST = '1'
				
				FETCH next from lhistf_cur into @cIFUNC
			END
				
			CLOSE lhistf_cur
			DEALLOCATE lhistf_cur

			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat3
	SET @Tam = len(@LMat3) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) 
		begin

			SET @cPIS = SUBSTRING (@LMat3, @Pos, 12);
			
			DECLARE lhistf_cur CURSOR FOR
			SELECT IFUNC FROM REPAUXEMPR 
				WHERE END_IP = @cEndIp AND 
				      TIPO = @cModo AND 
					  PIS = @cPIS AND 
					  ST = '1'
				ORDER by IFUNC;
			
			OPEN lhistf_cur
			FETCH next from lhistf_cur into @cIFUNC
			WHILE (@@fetch_status != -1) 
			BEGIN
				UPDATE REPAUXEMPR SET ST = '2' where current of lhistf_cur
					--WHERE END_IP = @cEndIp AND 
					--		TIPO = @cModo AND 
					--		PIS = @cPIS AND
					--		IFUNC = @cIFUNC AND
					--		ST = '1'
				
				FETCH next from lhistf_cur into @cIFUNC
			END
				
			CLOSE lhistf_cur
			DEALLOCATE lhistf_cur

			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat4
	SET @Tam = len(@LMat4) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) 
		begin

			SET @cPIS = SUBSTRING (@LMat4, @Pos, 12);
			
			DECLARE lhistf_cur CURSOR FOR
			SELECT IFUNC FROM REPAUXEMPR 
				WHERE END_IP = @cEndIp AND 
				      TIPO = @cModo AND 
					  PIS = @cPIS AND 
					  ST = '1'
				ORDER by IFUNC;
			
			OPEN lhistf_cur
			FETCH next from lhistf_cur into @cIFUNC
			WHILE (@@fetch_status != -1) 
			BEGIN
				UPDATE REPAUXEMPR SET ST = '2' where current of lhistf_cur
					--WHERE END_IP = @cEndIp AND 
					--		TIPO = @cModo AND 
					--		PIS = @cPIS AND
					--		IFUNC = @cIFUNC AND
					--		ST = '1'
				
				FETCH next from lhistf_cur into @cIFUNC
			END
				
			CLOSE lhistf_cur
			DEALLOCATE lhistf_cur

			SET @Pos = @Pos + 12;
		end
	END;


	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlhist_RfuncInme'))
	DROP PROCEDURE TELESSVR.sqlhist_RfuncInme
GO

CREATE PROCEDURE TELESSVR.sqlhist_RfuncInme @cEndIp CHAR(15), @cInsDel CHAR(1), @cNumModo CHAR(1)
AS

DECLARE @Ret INT, @cIFUNC CHAR(12), @cSTATUS CHAR(1), @cAcao CHAR(1), @cModo CHAR(1)


	SET @Ret = 0
	
	IF (@cInsDel = '3')
		SET @cAcao = 'I'
	ELSE
		SET @cAcao = 'E'
		
	IF (@cNumModo = '0')
		SET @cModo = 'M'
	ELSE
		SET @cModo = 'A'

			
	DECLARE lhistinme_cur CURSOR FOR
		SELECT IFUNC, ST FROM REPAUXEMPR 
			WHERE END_IP = @cEndIp AND 
				  TIPO = @cNumModo AND 
				  ST = '2'
			ORDER by IFUNC;

	OPEN lhistinme_cur
	FETCH next from lhistinme_cur into @cIFUNC, @cSTATUS
	WHILE (@@fetch_status != -1) 
	
	begin
		INSERT INTO HISTREPFUN (IFUNC, END_IP, INSEXC, MODO) 
			VALUES (@cIFUNC , @cEndIp, @cAcao, @cModo);
		
		FETCH next from lhistinme_cur into @cIFUNC, @cSTATUS
	END
	
	CLOSE lhistinme_cur
	DEALLOCATE lhistinme_cur


	IF EXISTS (select END_IP FROM REPLASTCOM WHERE END_IP = @cEndIp) 
		UPDATE REPLASTCOM SET DATA_INS = GETDATE() WHERE END_IP = @cEndIp;
	ELSE
		INSERT INTO REPLASTCOM (END_IP, DATA_INS) VALUES (@cEndIp, GETDATE());


	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlrep_autoExc3'))
	DROP PROCEDURE TELESSVR.sqlrep_autoExc3
GO

CREATE PROCEDURE TELESSVR.sqlrep_autoExc3  @cEndIp CHAR(15), @nMax SMALLINT AS

declare @nCont smallint
declare @nBloco smallint
declare @nTotal smallint
declare @cStat002 char(1)
declare @IFUNC char(12)
declare @STATUS char(1)
declare @cListaF VARCHAR(250)
declare @cListaFunc_1 VARCHAR(250)
declare @cListaFunc_2 VARCHAR(250)
declare @cListaFunc_3 VARCHAR(250)
declare @cListaFunc_4 VARCHAR(250)
declare @cListaFunc_5 VARCHAR(250)
declare @cListaFunc_6 VARCHAR(250)
declare @cListaFunc_7 VARCHAR(250)
declare @cListaFunc_8 VARCHAR(250)
declare @cListaFunc_9 VARCHAR(250)
declare @cListaFunc_10 VARCHAR(250)


	SET @nCont = 0
	SET @nBloco = 1
	SET @nTotal = 0
	
	SET @cListaF = ''
	SET @cListaFunc_1 = ''
	SET @cListaFunc_2 = ''
	SET @cListaFunc_3 = ''
	SET @cListaFunc_4 = ''
	SET @cListaFunc_5 = ''
	SET @cListaFunc_6 = ''
	SET @cListaFunc_7 = ''
	SET @cListaFunc_8 = ''
	SET @cListaFunc_9 = ''
	SET @cListaFunc_10 = ''

	SET LOCK_TIMEOUT 5000
	-- procura pelo equipamento
	IF EXISTS (SELECT * FROM REPAUTO002 WITH (Index = REPAUTO002_IND1) WHERE END_IP = @cEndIp)
	BEGIN
	    SELECT @cStat002 = STATUS
			FROM REPAUTO002
			WHERE END_IP = @cEndIp

		IF (@cStat002 = '1') BEGIN
		
			UPDATE REPAUTO002 SET 
				STATUS = '2', 
				DATA_LOAD = getdate()
			WHERE END_IP = @cEndIp;

			DECLARE linsf002_cur CURSOR FOR
				SELECT TOP(@nMax) IFUNC, STATUS FROM REPAUTO012 
					--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
					WHERE END_IP = @cEndIp AND STATUS != '0'
					order by IFUNC;

			open linsf002_cur
			fetch next from linsf002_cur into @IFUNC, @STATUS
			while (@@fetch_status != -1) and (@nTotal < @nMax) 
			begin
				SET @cListaF = @cListaF + @IFUNC
				UPDATE REPAUTO012 set STATUS = '2' where current of linsf002_cur
				SET @nCont = @nCont+1
				set @nTotal = @nTotal + 1


				if (@nCont >= 20) begin
					if (@nBloco = 1) 
						set @cListaFunc_1 = @cListaF
					else if (@nBloco = 2) 
						set @cListaFunc_2 = @cListaF
					else if (@nBloco = 3) 
						set @cListaFunc_3 = @cListaF
					else if (@nBloco = 4) 
						set @cListaFunc_4 = @cListaF
					else if (@nBloco = 5) 
						set @cListaFunc_5 = @cListaF
					else if (@nBloco = 6) 
						set @cListaFunc_6 = @cListaF
					else if (@nBloco = 7) 
						set @cListaFunc_7 = @cListaF
					else if (@nBloco = 8) 
						set @cListaFunc_8 = @cListaF
					else if (@nBloco = 9) 
						set @cListaFunc_9 = @cListaF
					else if (@nBloco = 10) 
						set @cListaFunc_10 = @cListaF
					set @cListaF = ''
					set @nBloco = @nBloco+1
					set @nCont = 0
				end
				fetch next from linsf002_cur into @IFUNC, @STATUS
			end
			close linsf002_cur
			deallocate linsf002_cur
			
			if ((@nCont > 0) and (@nCont < 20))
				if (@nBloco = 1) 
					set @cListaFunc_1 = @cListaF
				else if (@nBloco = 2) 
					set @cListaFunc_2 = @cListaF
				else if (@nBloco = 3) 
					set @cListaFunc_3 = @cListaF
				else if (@nBloco = 4) 
					set @cListaFunc_4 = @cListaF
				else if (@nBloco = 5) 
					set @cListaFunc_5 = @cListaF
				else if (@nBloco = 6) 
					set @cListaFunc_6 = @cListaF
				else if (@nBloco = 7) 
					set @cListaFunc_7 = @cListaF
				else if (@nBloco = 8) 
					set @cListaFunc_8 = @cListaF
				else if (@nBloco = 9) 
					set @cListaFunc_9 = @cListaF
				else if (@nBloco = 10) 
					set @cListaFunc_10 = @cListaF
					
					
			IF (@nTotal = 0) 
				UPDATE REPAUTO002 SET STATUS = '0' WHERE END_IP = @cEndIp;
			ELSE 
				UPDATE REPAUTO002 SET 
					STATUS = '2', 
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;
		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaFunc_1 as cListaFunc_1,
		   @cListaFunc_2 as cListaFunc_2,
		   @cListaFunc_3 as cListaFunc_3,
		   @cListaFunc_4 as cListaFunc_4,
		   @cListaFunc_5 as cListaFunc_5,
		   @cListaFunc_6 as cListaFunc_6,
		   @cListaFunc_7 as cListaFunc_7,
		   @cListaFunc_8 as cListaFunc_8,
		   @cListaFunc_9 as cListaFunc_9,
		   @cListaFunc_10 as cListaFunc_10
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlhist_Rfunc2'))
	DROP PROCEDURE TELESSVR.sqlhist_Rfunc2
GO

CREATE PROCEDURE TELESSVR.sqlhist_Rfunc2 @LMat1 VARCHAR(255), @LMat2 VARCHAR(255), @LMat3 VARCHAR(255), @LMat4 VARCHAR(255), @cEndIp CHAR(15), @cInsDel CHAR(1), @cModo CHAR(1)
AS

DECLARE @Ret smallint , @Tam INT, @Pos INT, @cAcao CHAR(1)

	SET @Ret = 0
	
	IF (@cInsDel = '3')
		SET @cAcao = 'I'
	ELSE
		SET @cAcao = 'E'
		
	-- analise de LMat1
	SET @Tam = len(@LMat1) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin
			INSERT INTO HISTREPFUN (IFUNC, END_IP, INSEXC, MODO) 
							VALUES (SUBSTRING (@LMat1, @Pos, 12) , @cEndIp, @cAcao, @cModo);
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat2
	SET @Tam = len(@LMat2) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin
			INSERT INTO HISTREPFUN (IFUNC, END_IP, INSEXC, MODO) 
							VALUES (SUBSTRING (@LMat2, @Pos, 12) , @cEndIp, @cAcao, @cModo);
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat3
	SET @Tam = len(@LMat3) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin
			INSERT INTO HISTREPFUN (IFUNC, END_IP, INSEXC, MODO) 
							VALUES (SUBSTRING (@LMat3, @Pos, 12) , @cEndIp, @cAcao, @cModo);
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat4
	SET @Tam = len(@LMat4) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin
			INSERT INTO HISTREPFUN (IFUNC, END_IP, INSEXC, MODO) 
							VALUES (SUBSTRING (@LMat4, @Pos, 12) , @cEndIp, @cAcao, @cModo);
			SET @Pos = @Pos + 12;
		end
	END;


	
	IF EXISTS (select END_IP FROM REPLASTCOM WHERE END_IP = @cEndIp) 
		UPDATE REPLASTCOM SET DATA_INS = GETDATE() WHERE END_IP = @cEndIp;
	ELSE
		INSERT INTO REPLASTCOM (END_IP, DATA_INS) VALUES (@cEndIp, GETDATE());


	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlhist_Rbio3'))
	DROP PROCEDURE TELESSVR.sqlhist_Rbio3
GO

CREATE PROCEDURE TELESSVR.sqlhist_Rbio3 @LMat1 CHAR(255), @LMat2 CHAR(255), @LMat3 CHAR(255), @LMat4 CHAR(255), @cEndIp CHAR(15), @cInsDel CHAR(1), @cModo CHAR(1), @cBioTipo CHAR(1)
AS

DECLARE @Ret smallint , @Tam smallint, @Pos smallint, @cAcao CHAR(1), @cBio CHAR(1), @cAuxEndIP char(12)


	SET @cBio = null
	SET @cBio = (SELECT BIO_TIPO FROM DAT07 WHERE END_IP = @cEndIp)
	IF (@cBio is null) BEGIN
		SET @cBio = ' ';
	END
	

	SET @Ret = 0
	
	IF (@cInsDel = '3')
		SET @cAcao = 'I'
	ELSE
		SET @cAcao = 'E'

	
	-- analise de LMat1
	SET @Tam = LEN (@LMat1) ;
	IF (@Tam > 0)
	BEGIN
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin
			INSERT INTO HISTREPDIG (IFUNC, END_IP, BIO_TIPO, INSEXC, MODO) 
				-- VALUES (SUBSTRING (@LMat1, @Pos, 12) , @cEndIp,  @cBioTipo, @cAcao, @cModo);
				VALUES (SUBSTRING (@LMat1, @Pos, 12) , @cEndIp,  @cBio, @cAcao, @cModo);
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat2
	SET @Tam = LEN (@LMat2) ;
	IF (@Tam > 0)
	BEGIN
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin
			INSERT INTO HISTREPDIG (IFUNC, END_IP, BIO_TIPO, INSEXC, MODO) 
				-- VALUES (SUBSTRING (@LMat2, @Pos, 12) , @cEndIp,  @cBioTipo, @cAcao, @cModo);
				VALUES (SUBSTRING (@LMat2, @Pos, 12) , @cEndIp,  @cBio, @cAcao, @cModo);
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat3
	SET @Tam = LEN (@LMat3) ;
	IF (@Tam > 0)
	BEGIN
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin
			INSERT INTO HISTREPDIG (IFUNC, END_IP, BIO_TIPO, INSEXC, MODO) 
				-- VALUES (SUBSTRING (@LMat3, @Pos, 12) , @cEndIp,  @cBioTipo, @cAcao, @cModo);
				VALUES (SUBSTRING (@LMat3, @Pos, 12) , @cEndIp,  @cBio, @cAcao, @cModo);
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat4
	SET @Tam = LEN (@LMat4) ;
	IF (@Tam > 0)
	BEGIN
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin
			INSERT INTO HISTREPDIG (IFUNC, END_IP, BIO_TIPO, INSEXC, MODO) 
				-- VALUES (SUBSTRING (@LMat4, @Pos, 12) , @cEndIp,  @cBioTipo, @cAcao, @cModo);
				VALUES (SUBSTRING (@LMat4, @Pos, 12) , @cEndIp,  @cBio, @cAcao, @cModo);
			SET @Pos = @Pos + 12;
		end
	END;
	
	SELECT @cAuxEndIP = END_IP FROM REPLASTCOM WHERE END_IP = @cEndIp;
	IF (@@ROWCOUNT = 0) 
		INSERT INTO REPLASTCOM (END_IP, DATA_INS) VALUES (@cEndIp, GETDATE());
	ELSE
		UPDATE REPLASTCOM SET DATA_INS = GETDATE() WHERE END_IP = @cEndIp;



	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlrcon_sagem_digital3'))
	DROP PROCEDURE TELESSVR.sqlrcon_sagem_digital3
GO

CREATE PROCEDURE TELESSVR.sqlrcon_sagem_digital3 @cMatric char(12), @cEndIp char(15), @cNumRep char(17),
@cTempl_tit1tot CHAR(160) OUTPUT, @cTempl_tit2tot CHAR(160) OUTPUT, 
@cTempl_tit3tot CHAR(160) OUTPUT, @cTempl_tit4tot CHAR(160) OUTPUT, 
@cTempl_Alt1tot CHAR(160) OUTPUT, @cTempl_Alt2tot CHAR(160) OUTPUT, 
@cTempl_Alt3tot CHAR(160) OUTPUT, @cTempl_Alt4tot CHAR(160) OUTPUT,
@cNivel CHAR(1) OUTPUT, @cTempl_tit5tot CHAR(160) OUTPUT, @cTempl_Alt5tot CHAR(160) OUTPUT,
@cTempl_tit6tot CHAR(26) OUTPUT, @cTempl_Alt6tot CHAR(26) OUTPUT


AS
DECLARE @Retfun int, @Pad int, @Alt int,@cTempl_tit4aux AS CHAR(32), @cTempl_Alt4aux AS CHAR(32), @cVDigit char(1)


BEGIN
--	select @Retfun = -1
	select @Retfun = 3
	select @cTempl_tit1tot = NULL
	select @cTempl_tit2tot = NULL
	select @cTempl_tit3tot = NULL
	select @cTempl_tit4tot = NULL
	select @cTempl_tit4aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	select @cTempl_Alt1tot = NULL
	select @cTempl_Alt2tot = NULL
	select @cTempl_Alt3tot = NULL
	select @cTempl_Alt4tot = NULL
	select @cTempl_Alt4aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	select @cNivel = NULL


		-- procura por Templates da matricula
		IF EXISTS (SELECT * FROM CONTDIG_SAGEM  WHERE ICARD = @cMatric)
		begin
			SELECT @cTempl_tit1tot = TEMPL_TIT1,
			   @cTempl_tit2tot = TEMPL_TIT2,
			   @cTempl_tit3tot = TEMPL_TIT3,
			   @cTempl_tit4aux = TEMPL_TIT4,
			   @cTempl_Alt1tot = TEMPL_ALT1,
			   @cTempl_Alt2tot = TEMPL_ALT2,
			   @cTempl_Alt3tot = TEMPL_ALT3,
			   @cTempl_Alt4aux = TEMPL_ALT4,
			   @cNivel = NIVEL
			FROM CONTDIG_SAGEM
			WHERE ICARD = @cMatric
			select @Pad = 1    -- assume que tem template padrao
			select @Alt = 1    -- assume que tem template alternativo
			if ((@cTempl_tit1tot is Null) or (@cTempl_tit2tot is Null) or 
				(@cTempl_tit3tot is Null) or (@cTempl_tit4aux is Null) or
			--	(datalength(@cTempl_tit1tot) < 160) or (datalength(@cTempl_tit2tot) < 160) or
			--	(datalength(@cTempl_tit3tot) < 160) or (datalength(@cTempl_tit4aux) < 32)) 
				(len(@cTempl_tit1tot) < 160) or (len(@cTempl_tit2tot) < 160) or
				(len(@cTempl_tit3tot) < 160) or (len(@cTempl_tit4aux) < 32)) 
			
			begin
				SELECT @Pad = 0
			end 

			--IF (datalength(@cTempl_tit4aux) = 32) BEGIN
			IF (len(@cTempl_tit4aux) = 32) BEGIN
				SET @cTempl_tit4tot = @cTempl_tit4aux + REPLICATE('0',160-LEN(@cTempl_tit4aux) )
				SET @cTempl_tit5tot = REPLICATE('0', 160)
				SET @cTempl_tit6tot = REPLICATE('0', 26)
			END

			if ((@cTempl_Alt1tot is Null) or (@cTempl_Alt2tot is Null) or
				(@cTempl_Alt3tot is Null) or (@cTempl_Alt4aux is Null) or
				--(datalength(@cTempl_Alt1tot) < 160) or (datalength(@cTempl_Alt2tot) < 160) or
				--(datalength(@cTempl_Alt3tot) < 160) or (datalength(@cTempl_Alt4aux) < 32)) 
				(len(@cTempl_Alt1tot) < 160) or (len(@cTempl_Alt2tot) < 160) or
				(len(@cTempl_Alt3tot) < 160) or (len(@cTempl_Alt4aux) < 32)) 
				
			begin 
				SELECT @Alt = 0
			end

			--IF (datalength(@cTempl_Alt4aux) = 32) BEGIN
			IF (len(@cTempl_Alt4aux) = 32) BEGIN
				SET @cTempl_Alt4tot = @cTempl_Alt4aux + REPLICATE('0',160-LEN(@cTempl_Alt4aux) )
				SET @cTempl_Alt5tot = REPLICATE('0', 160)
				SET @cTempl_Alt6tot = REPLICATE('0', 26)
			END
	    
		end
		ELSE BEGIN
			
				SET	@Pad = 0;
				SET @Alt = 0;
		END
		
		if (@Pad = 1) 
		begin
			if (@Alt = 1) 
				SET @Retfun = 0   -- tem padrao e tem alternativo
			else 
				SET @Retfun = 1   -- tem padrao e nao tem alternativo
		end
		ELSE
		begin
			if (@Alt = 1) 
				SET @Retfun = 2   -- nao tem padrao e tem alternativo
			else 
				SET @Retfun = 3   -- nao tem padrao e nao tem alternativo	
		end

	    
	    IF ((@Retfun = -1) or (@Retfun = 3))		-- problema ou digital nao cadastrado
	    	INSERT INTO REPDIGLOAD001 (END_IP, REP, IFUNC, BIO_TIPO, DATA_INS) 
				VALUES (@cEndIp, @cNumRep, @cMatric, '6', getdate());

	    
	return (@Retfun)
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlrcon_tsi1_digital3'))
	DROP PROCEDURE TELESSVR.sqlrcon_tsi1_digital3
GO

CREATE PROCEDURE TELESSVR.sqlrcon_tsi1_digital3 @cMatric char(12), @cEndIp char(15), @cNumRep char(17),
@cTempl_tit1tot CHAR(160) OUTPUT, @cTempl_tit2tot CHAR(160) OUTPUT, 
@cTempl_tit3tot CHAR(160) OUTPUT, @cTempl_tit4tot CHAR(160) OUTPUT, 
@cTempl_Alt1tot CHAR(160) OUTPUT, @cTempl_Alt2tot CHAR(160) OUTPUT, 
@cTempl_Alt3tot CHAR(160) OUTPUT, @cTempl_Alt4tot CHAR(160) OUTPUT,
@cNivel CHAR(1) OUTPUT, @cTempl_tit5tot CHAR(160) OUTPUT, @cTempl_Alt5tot CHAR(160) OUTPUT,
@cTempl_tit6tot CHAR(26) OUTPUT, @cTempl_Alt6tot CHAR(26) OUTPUT
AS
DECLARE @Retfun int, @Pad int, @Alt int,@cTempl_tit5aux AS CHAR(128), @cTempl_Alt5aux AS CHAR(128), @cVDigit char(1)

BEGIN
	select @Retfun = 3
	select @cTempl_tit1tot = NULL
	select @cTempl_tit2tot = NULL
	select @cTempl_tit3tot = NULL
	select @cTempl_tit4tot = NULL
	select @cTempl_tit5aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	select @cTempl_Alt1tot = NULL
	select @cTempl_Alt2tot = NULL
	select @cTempl_Alt3tot = NULL
	select @cTempl_Alt4tot = NULL
	select @cTempl_Alt5aux = NULL
	select @cTempl_Alt5tot = NULL
	select @cTempl_Alt6tot = NULL
	select @cNivel = NULL

	-- procura por Templates da matricula
	IF EXISTS (SELECT * FROM CONTDIG_TSI1 WHERE ICARD = @cMatric)
	begin
		SELECT @cTempl_tit1tot = TEMPL_TIT1,
		   @cTempl_tit2tot = TEMPL_TIT2,
		   @cTempl_tit3tot = TEMPL_TIT3,
		   @cTempl_tit4tot = TEMPL_TIT4,
		   @cTempl_tit5aux = TEMPL_TIT5,
		   @cTempl_Alt1tot = TEMPL_ALT1,
		   @cTempl_Alt2tot = TEMPL_ALT2,
		   @cTempl_Alt3tot = TEMPL_ALT3,
		   @cTempl_Alt4tot = TEMPL_ALT4,
		   @cTempl_Alt5aux = TEMPL_ALT5,
		   @cNivel = NIVEL
		FROM CONTDIG_TSI1
		WHERE ICARD = @cMatric
		select @Pad = 1    -- assume que tem template padrao
		select @Alt = 1    -- assume que tem template alternativo
		if ((@cTempl_tit1tot is Null) or (@cTempl_tit2tot is Null) or 
			(@cTempl_tit3tot is Null) or (@cTempl_tit4tot is Null) or 
			(@cTempl_tit5aux is Null) or
			--(datalength(@cTempl_tit1tot) < 160) or (datalength(@cTempl_tit2tot) < 160) or
			--(datalength(@cTempl_tit3tot) < 160) or (datalength(@cTempl_tit4tot) < 160) or 
			--(datalength(@cTempl_tit5aux) < 128)) 
			(len(@cTempl_tit1tot) < 160) or (len(@cTempl_tit2tot) < 160) or
			(len(@cTempl_tit3tot) < 160) or (len(@cTempl_tit4tot) < 160) or 
			(len(@cTempl_tit5aux) < 128)) 
			
		begin
			SELECT @Pad = 0
		end 

		--IF (datalength(@cTempl_tit5aux) = 128) BEGIN
		IF (len(@cTempl_tit5aux) = 128) BEGIN
			SET @cTempl_tit5tot = @cTempl_tit5aux + REPLICATE('0',160-LEN(@cTempl_tit5aux) )
			SET @cTempl_tit6tot = REPLICATE('0', 26)
		END

		if ((@cTempl_Alt1tot is Null) or (@cTempl_Alt2tot is Null) or
			(@cTempl_Alt3tot is Null) or (@cTempl_Alt4tot is Null) or 
			(@cTempl_Alt5aux is Null) or
			--(datalength(@cTempl_Alt1tot) < 160) or (datalength(@cTempl_Alt2tot) < 160) or
			--(datalength(@cTempl_Alt3tot) < 160) or (datalength(@cTempl_Alt4tot) < 160) or 
			--(datalength(@cTempl_Alt5aux) < 128)) 
			(len(@cTempl_Alt1tot) < 160) or (len(@cTempl_Alt2tot) < 160) or
			(len(@cTempl_Alt3tot) < 160) or (len(@cTempl_Alt4tot) < 160) or 
			(len(@cTempl_Alt5aux) < 128)) 
			
		begin 
			SELECT @Alt = 0
		end

		--IF (datalength(@cTempl_Alt5aux) = 128) BEGIN
		IF (len(@cTempl_Alt5aux) = 128) BEGIN
			SET @cTempl_Alt5tot = @cTempl_Alt5aux + REPLICATE('0',160-LEN(@cTempl_Alt5aux) )
			SET @cTempl_Alt6tot = REPLICATE('0', 26)
		END
		
		if (@Pad = 1) 
		begin
			if (@Alt = 1) 
				SET @Retfun = 0   -- tem padrao e tem alternativo
			else 
				SET @Retfun = 1   -- tem padrao e nao tem alternativo
		end
		ELSE
		begin
			if (@Alt = 1) 
				SET @Retfun = 2   -- nao tem padrao e tem alternativo
			else 
				SET @Retfun = 3   -- nao tem padrao e nao tem alternativo	
		end
	end

    IF (@Retfun = 3)		-- digital nao cadastrado
    	INSERT INTO REPDIGLOAD001 (END_IP, REP, IFUNC, BIO_TIPO, DATA_INS) 
			VALUES (@cEndIp, @cNumRep, @cMatric, '8', getdate());


	return (@Retfun)
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlload_rlistadig3'))
	DROP PROCEDURE TELESSVR.sqlload_rlistadig3
GO

CREATE PROCEDURE TELESSVR.sqlload_rlistadig3 @cMatric CHAR(12), @cEndIp CHAR(15), @cNumRep CHAR(25), @cStatus CHAR(1) , @cErro CHAR(1)
AS

DECLARE @Ret smallint, @cBioTipo CHAR(1), @ERR INT  , @cAux char(12), @cAuxEndIP char(12)

	SET @Ret = 0
	SET LOCK_TIMEOUT 2000
	SET @cBioTipo = '0'
	
	SELECT @cBioTipo = BIO_TIPO FROM RDIG002
		WHERE END_IP = @cEndIp;
		
	if (@@ROWCOUNT = 1) begin
		-- (SAGEM)
		IF (@cBioTipo = '6' or @cBioTipo = '7') 		
			UPDATE RDIG001 SET STATUS = @cStatus 
				where IFUNC = @cMatric and
					  END_IP = @cEndIp;

		--  (TSI1)
		ELSE IF (@cBioTipo = '8')  
			UPDATE RDIG003 SET STATUS = @cStatus 				  
				where IFUNC = @cMatric and
					  END_IP = @cEndIp;

		--  (VIRDI) E OUTROS
		--ELSE IF (@cBioTipo = '9')  
		ELSE IF (@cBioTipo != '0')  
			UPDATE RDIG004 SET STATUS = @cStatus 				  
				where IFUNC = @cMatric and
					  END_IP = @cEndIp;

	end

	UPDATE RDIG002 SET DATA_LOAD = getdate() where END_IP = @cEndIp


	-- NOVO
	IF (@cStatus = '0') begin
		INSERT INTO HISTREPDIG (IFUNC, END_IP, BIO_TIPO, INSEXC, MODO) VALUES (@cMatric, @cEndIp, @cBioTipo, 'I', 'A')	-- TIPO:'I'= INCLUSAO, 'E'=EXCLUSAO; MODO:'A'=AUTOMATICO, 'M'=MANUAL

		SELECT @cAuxEndIP = END_IP FROM REPLASTCOM WHERE END_IP = @cEndIp;
		IF (@@ROWCOUNT = 0) 
			INSERT INTO REPLASTCOM (END_IP, DATA_INS) VALUES (@cEndIp, GETDATE());
		ELSE
			UPDATE REPLASTCOM SET DATA_INS = GETDATE() WHERE END_IP = @cEndIp;

	end
	ELSE
		--IF (@cStatus = '4')  	-- ERRO DE CARGA (devido a memoria cheiia, minucia errada: que nao adianta enviar a digital novamente ao equipamento ), ou nao implementado
			INSERT INTO REPDIGLOAD001 (END_IP, REP, IFUNC, BIO_TIPO, NERRO) VALUES (@cEndIp, @cNumRep, @cMatric, @cBioTipo, @cErro);

	-- FIM NOVO



	SET LOCK_TIMEOUT -1
	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.sqlrperm_novocomando'))
	DROP PROCEDURE TELESSVR.sqlrperm_novocomando
GO

CREATE PROCEDURE TELESSVR.sqlrperm_novocomando @EndIp CHAR(15)
AS

DECLARE @xret int
DECLARE @cHoraBD DATETIME


BEGIN
	
	SET @xret = 1			-- assume que pode enviar comando
	
	
	IF EXISTS (select * from REPLASTCOM where END_IP = @EndIp)
	begin
		SELECT @cHoraBD = DATA_INS 
			FROM REPLASTCOM 
			WHERE END_IP = @EndIp 
		IF (DATEDIFF (second, @cHoraBD, getdate()) >= 20)
			SET @xret = 1;
		ELSE
			SET @xret = 0;
	end;
	
	SELECT @xret;
END
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.AntePrep2_ROutrosBios'))
	DROP PROCEDURE TELESSVR.AntePrep2_ROutrosBios
GO

CREATE PROCEDURE TELESSVR.AntePrep2_ROutrosBios   @nQtd INT 
AS


DECLARE @cIcard char(12), @cStatusRep char(1), @cBioTipo char(1)

BEGIN
	DECLARE cur_digaltvrd CURSOR for 
		--(SELECT top(10) ICARD, STATUS_REP, BIO_TIPO FROM CONTDIG_OUTROS 
		(SELECT top(@nQtd) ICARD, STATUS_REP, BIO_TIPO FROM CONTDIG_OUTROS 
			WHERE STATUS_REP = '1' or STATUS_REP = '3' or STATUS_REP = '8')

	OPEN cur_digaltvrd
	FETCH next from cur_digaltvrd into @cIcard, @cStatusRep, @cBioTipo 
	WHILE @@fetch_status != -1
	BEGIN

		IF (@cStatusRep = '1' or @cStatusRep = '3' or @cStatusRep = '8') 
		BEGIN
			-- INSERIRA�EM TAB.REPNDIGAUTO000, OS GRUPOS QUE A MATRICULA FAZ PARTE, PARA QUE DOS EQUIPTOS DESTE GRUPO SEJA RETIRADA ou INSERIDA A MATRICULA
			exec TELESSVR.Auxtrg_repDig2 @cIcard, @cStatusRep, @cBioTipo

			UPDATE CONTDIG_OUTROS SET STATUS_REP = '0' 
				WHERE ICARD = @cIcard and 
					BIO_TIPO = @cBioTipo
		END
		FETCH next from cur_digaltvrd into @cIcard, @cStatusRep, @cBioTipo

	END
	
	CLOSE cur_digaltvrd
	DEALLOCATE cur_digaltvrd
END

GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.ANTEPREP3_RSAGEM'))
	DROP PROCEDURE TELESSVR.ANTEPREP3_RSAGEM
GO

CREATE PROCEDURE TELESSVR.ANTEPREP3_RSAGEM  @nQtd INT 
AS


DECLARE @cIcard char(12), @cStatusRep char(1)

BEGIN
	DECLARE cur_digalts CURSOR for 
		--(SELECT top(10) ICARD, STATUS_REP FROM CONTDIG_SAGEM 
		(SELECT top(@nQtd) ICARD, STATUS_REP FROM CONTDIG_SAGEM 
			WHERE STATUS_REP = '1' or STATUS_REP = '3' or STATUS_REP = '8')

	OPEN cur_digalts
	FETCH next from cur_digalts into @cIcard, @cStatusRep
	WHILE @@fetch_status != -1
	BEGIN

		-- INSERIRA�EM TAB.REPNDIGAUTO000, OS GRUPOS QUE A MATRICULA FAZ PARTE, PARA QUE DOS EQUIPTOS DESTE GRUPO SEJA RETIRADA ou INSERIDA A MATRICULA
		exec TELESSVR.Auxtrg_repDig2 @cIcard, @cStatusRep, '6'

		UPDATE CONTDIG_SAGEM SET STATUS_REP = '0' 
				where ICARD = @cIcard;

		FETCH next from cur_digalts into @cIcard, @cStatusRep

	END
	
	CLOSE cur_digalts
	DEALLOCATE cur_digalts
END

GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.AntePrep3_RTsi1'))
	DROP PROCEDURE TELESSVR.AntePrep3_RTsi1
GO

CREATE PROCEDURE TELESSVR.AntePrep3_RTsi1 @nQtd INT 
AS


DECLARE @cIcard char(12), @cStatusRep char(1)

BEGIN
	DECLARE cur_digaltsup CURSOR for 
		--(SELECT top(10) ICARD, STATUS_REP FROM CONTDIG_TSI1 
		(SELECT top(@nQtd) ICARD, STATUS_REP FROM CONTDIG_TSI1 
			WHERE STATUS_REP = '1' or STATUS_REP = '3' or STATUS_REP = '8')

	OPEN cur_digaltsup
	FETCH next from cur_digaltsup into @cIcard, @cStatusRep
	WHILE @@fetch_status != -1
	BEGIN

		-- INSERIRA�EM TAB.REPNDIGAUTO000, OS GRUPOS QUE A MATRICULA FAZ PARTE, PARA QUE DOS EQUIPTOS DESTE GRUPO SEJA RETIRADA ou INSERIDA A MATRICULA
		exec TELESSVR.Auxtrg_repDig2 @cIcard, @cStatusRep, '8'

		UPDATE CONTDIG_TSI1 SET STATUS_REP = '0' 
				where ICARD = @cIcard;

		FETCH next from cur_digaltsup into @cIcard, @cStatusRep

	END
	
	CLOSE cur_digaltsup
	DEALLOCATE cur_digaltsup
END

GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.Prep_RepDigit3'))
	DROP PROCEDURE TELESSVR.Prep_RepDigit3
GO

CREATE PROCEDURE TELESSVR.Prep_RepDigit3 @nQtd INT 
AS

DECLARE @nCont SMALLINT
DECLARE @nTemLocal SMALLINT
          
DECLARE @c_status CHAR(1)
DECLARE @c_ifunc CHAR(12)
DECLARE @c_endip CHAR(15)
DECLARE @c_grupo CHAR(5)
DECLARE @c_biotipo CHAR(1)

DECLARE @xc_status CHAR(1)
DECLARE @xc_ifunc CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @ret CHAR(1)
DECLARE @xc_biotipo CHAR(1)

DECLARE @cAux CHAR(1)
DECLARE @cTipo CHAR(1)

SET DATEFORMAT YMD


	set @ret = 0

	SET LOCK_TIMEOUT 5000
	
	-- *************** PREPARACAO DE INCLUSAO/EXCLUSAO  FUNCIONARIOS NOS EQUIPAMENTOS (MONTAGEM DAS TABELAS AUXILIARES)
	BEGIN
	
		DELETE TMP_TD;
		DELETE TMP_NREPGRPATV;
		
		DELETE TMP_REPSAG001
		DELETE TMP_REPSAG002
	
		DELETE TMP_REPSUP001
		DELETE TMP_REPSUP002
		
		DELETE TMP_REPVRD001
		DELETE TMP_REPVRD002
		
		-- tabela temporaria TMP_TD compostas de todas as linhas de REPNDIGAUTO000 com solicita��o de processamento de Inclusao ('3') e Exclus�o ('8')
		--INSERT INTO TMP_TD select top(5) IFUNC, STATUS, GRUPO, BIO_TIPO from REPNDIGAUTO000 WHERE STATUS = '3' or STATUS = '8' ORDER BY DATA_INS, IFUNC
		INSERT INTO TMP_TD select top(@nQtd) IFUNC, STATUS, GRUPO, BIO_TIPO from REPNDIGAUTO000 WHERE STATUS = '3' or STATUS = '8' ORDER BY DATA_INS, IFUNC
		
		-- cursor para matriculas X GRUPOS a carregar/excluir
		DECLARE cur_autod000 CURSOR FOR (select IFUNC, STATUS, GRUPO, BIO_TIPO from TMP_TD)

		OPEN cur_autod000
		FETCH NEXT FROM cur_autod000 INTO @c_ifunc, @c_status, @c_grupo, @c_biotipo
		
		WHILE @@fetch_status != -1
		BEGIN   
			SET @nTemLocal = 0
			DELETE FROM TMP_NREPDIGGRP
			
			-- VERIFICA SE VALOR DE REPNDIGAUTO000.BIO_TIPO tem valor '0'.
			-- SE VALOR '0', indica que a preparacao das tabelas � para todos tipo de biometria
			-- SE VALOR � espec�fico para TIPO DE LEITOR BIO, s� vai ENTRAR EM tab. TMP_NREPDIGGRP os equipamentos dessa biometria

			IF (@c_biotipo = '0') BEGIN
				-- inclui em TMP_NREPDIGGRP TODOS OS REPS Q FAZEM PARTE DO GRUPO EM QUESTAO (NOVO OU VELHO) DO FUNCIONARIO 
				insert into TMP_NREPDIGGRP (IFUNC, GRUPO, END_IP, STATUS, BIO_TIPO)		
					select distinct @c_ifunc,  @c_grupo, VIEWGRPREP.end_ip, @c_status, VIEWGRPREP.BIO_TIPO
						from VIEWGRPREP
						where
							CAST(VIEWGRPREP.grupo AS INT) = CAST(@c_grupo AS INT) and
							--(VIEWGRPREP.bio_tipo = '6' or VIEWGRPREP.bio_tipo = '7'  or VIEWGRPREP.bio_tipo = '8' or VIEWGRPREP.bio_tipo = '9');
							--(VIEWGRPREP.bio_tipo != '0') ;
							((VIEWGRPREP.bio_tipo != '0') AND (VIEWGRPREP.bio_tipo != 'A'));
			END
			ELSE BEGIN
				insert into TMP_NREPDIGGRP (IFUNC, GRUPO, END_IP, STATUS, BIO_TIPO)		
					select distinct @c_ifunc,  @c_grupo, VIEWGRPREP.end_ip, @c_status, @c_biotipo
						from VIEWGRPREP
						where
							CAST(VIEWGRPREP.grupo AS INT) = CAST(@c_grupo AS INT) and
							VIEWGRPREP.bio_tipo = @c_biotipo
				
			END			
			
			
			IF (@@ROWCOUNT != 0) BEGIN
				SET @nTemLocal = 1
			END
		
		
			IF (@nTemLocal = 1) BEGIN
				DELETE FROM TMP_NREPDIGOUTROS;

				IF (@c_biotipo = '0') BEGIN
					-- inclui em TMP_NREPDIGOUTROS TODOS OS REPS Q FAZEM PARTE De outros GRUPOs DO FUNCIONARIO
					INSERT into TMP_NREPDIGOUTROS (IFUNC, GRUPO,  END_IP, BIO_TIPO, STATUS)		
						select distinct @c_ifunc, VIEWGRPREP.Grupo, VIEWGRPREP.end_ip, VIEWGRPREP.bio_tipo, @c_status
							from VIEWGRPREP, REPGRPF
							where
								(CAST(VIEWGRPREP.grupo AS INT) != CAST(@c_grupo AS INT)) and
								(CAST(VIEWGRPREP.grupo AS INT) in (select CAST(Grupo AS INT) from REPGRPF where IFUNC = @c_ifunc)) and 
								(CAST(VIEWGRPREP.grupo AS INT) not in (SELECT CAST(Grupo AS INT) FROM TMP_NREPDIGATV where IFUNC = @c_ifunc) ) and 
								--(VIEWGRPREP.bio_tipo = '6' or VIEWGRPREP.bio_tipo = '7'  or VIEWGRPREP.bio_tipo = '8' or VIEWGRPREP.bio_tipo = '9');
								--(VIEWGRPREP.bio_tipo != '0');
								((VIEWGRPREP.bio_tipo != '0') AND (VIEWGRPREP.bio_tipo != 'A'));
				END
				ELSE BEGIN
					INSERT into TMP_NREPDIGOUTROS (IFUNC, GRUPO,  END_IP, BIO_TIPO, STATUS)		
						select distinct @c_ifunc, VIEWGRPREP.Grupo, VIEWGRPREP.end_ip, @c_biotipo, @c_status
							from VIEWGRPREP, REPGRPF
							where
								(CAST(VIEWGRPREP.grupo AS INT) != CAST(@c_grupo AS INT)) and
								(CAST(VIEWGRPREP.grupo AS INT) in (select CAST(Grupo AS INT) from REPGRPF where IFUNC = @c_ifunc)) and 
								(CAST(VIEWGRPREP.grupo AS INT) not in (SELECT CAST(Grupo AS INT) FROM TMP_NREPDIGATV where IFUNC = @c_ifunc) ) and 
								(VIEWGRPREP.bio_tipo = @c_biotipo);
				END			

				set @nCont = @@ROWCOUNT
				
				-- Insere em tabela resultante OS REGISTROS de TMP_NREPDIGGRP que n�o tem em TMP_NREPDIGOUTROS
				IF (@c_status = '3') BEGIN		-- INCLUINDO
					set @cTipo = '3'

					DECLARE Rtmp_digeqptos cursor for (SELECT END_IP, BIO_TIPO from TMP_NREPDIGGRP  
						WHERE IFUNC = @c_ifunc and 
							STATUS = @cTipo and  
							CAST(Grupo AS INT) = CAST(@c_grupo AS INT) )
							
					OPEN Rtmp_digeqptos
					FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					WHILE @@fetch_status != -1
					BEGIN
						SET @nCont = 0;
						SET @nCont = (SELECT count(*) FROM TMP_NREPDIGOUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
						IF (@nCont = 0)					
						BEGIN
							-- trata equipamento SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') 
							begin
								SET @cAux = (SELECT STATUS FROM TMP_REPSAG001 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
								IF (@cAux  is null) 
									INSERT into TMP_REPSAG001 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo);
								ELSE
									IF (@cAux = '0') 
										UPDATE TMP_REPSAG001 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip;
							end
							ELSE 
								-- trata equipamento SUPREMA
								IF (@xc_biotipo = '8') begin
									SET @cAux = (SELECT STATUS FROM TMP_REPSUP001 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
									IF (@cAux  is null) 
										INSERT into TMP_REPSUP001 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo);
									ELSE
										IF (@cAux = '0') 
											UPDATE TMP_REPSUP001 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip;
								end											
							ELSE 
								-- trata equipamento VIRDI /e outros
								IF (@xc_biotipo != 'A') 		-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
								begin
									-- trata equipamento VIRDI / OUTROS
									SET @cAux = (SELECT STATUS FROM TMP_REPVRD001 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
									IF (@cAux  is null) 
										INSERT into TMP_REPVRD001 (IFUNC, END_IP, BIO_TIPO, STATUS)	VALUES  (@c_ifunc, @xc_endip, @xc_biotipo, @cTipo);
									ELSE
										IF (@cAux = '0') 
											UPDATE TMP_REPVRD001 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip and BIO_TIPO = @xc_biotipo;
								end
						END									
							
						-- VERIFICA SE FUNCIONARIO X IP JA EST� EM TABELA DE EXCLUSAO, PARA EXCLUIR
						BEGIN
							-- SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') begin
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPSAG002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '8') 
									DELETE FROM TMP_REPSAG002 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							end
							-- SUPREMA
							ELSE IF (@xc_biotipo = '8') begin
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPSUP002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '8') 
									DELETE FROM TMP_REPSUP002 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							end
							-- VIRDI / OUTROS
							ELSE 
								IF (@xc_biotipo != 'A') begin	-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
									SET @cAux = null
									SET @cAux = (SELECT STATUS from TMP_REPVRD002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
									IF (@cAux = '8') 
										DELETE FROM TMP_REPVRD002 where IFUNC = @c_ifunc and END_IP = @xc_endip;
								end
						END
								
						FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					END 
					
					CLOSE Rtmp_digeqptos
					DEALLOCATE Rtmp_digeqptos
				END
				
				ELSE IF (@c_status = '8') BEGIN		-- EXCLUINDO
					set @cTipo = '8'

					DECLARE Rtmp_digeqptos cursor for (SELECT END_IP, BIO_TIPO from TMP_NREPDIGGRP  
						WHERE IFUNC = @c_ifunc and 
							STATUS = @cTipo and  
							CAST(Grupo AS INT) = CAST(@c_grupo AS INT) )
					OPEN Rtmp_digeqptos
					FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					WHILE @@fetch_status != -1
					BEGIN

						SET @nCont = 0;
						SET @nCont = (SELECT count(*) FROM TMP_NREPDIGOUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
						IF (@nCont = 0)	BEGIN			
							-- trata equipamento SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') begin
								SET @cAux = (SELECT STATUS from TMP_REPSAG002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux is null)  
									INSERT into TMP_REPSAG002 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo );

								ELSE
									IF (@cAux = '0') 
										UPDATE TMP_REPSAG002 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip
							END
							ELSE 
								-- trata equipamento SUPREMA
								IF (@xc_biotipo = '8') begin
									SET @cAux = (SELECT STATUS FROM TMP_REPSUP002 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
									IF (@cAux  is null) 
										INSERT into TMP_REPSUP002 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo);
									ELSE
										IF (@cAux = '0') 
											UPDATE TMP_REPSUP002 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip;
								end											
								ELSE 
									-- trata equipamento VIRDI / OUTROS
									IF (@xc_biotipo != 'A') 		-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
									begin
										SET @cAux = (SELECT STATUS FROM TMP_REPVRD002 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
										IF (@cAux  is null) 
											INSERT into TMP_REPVRD002 (IFUNC, END_IP, BIO_TIPO, STATUS)	VALUES  (@c_ifunc, @xc_endip, @xc_biotipo, @cTipo);
										ELSE
											IF (@cAux = '0') 
												UPDATE TMP_REPVRD002 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip and BIO_TIPO = @xc_biotipo;
									end											
						END
							
						-- verifica se funcionario x ip ja est� em tabela de inclusao, para incluir
						BEGIN
							-- SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') BEGIN
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPSAG001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '3') 
									DELETE FROM TMP_REPSAG001 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							END
							-- SUPREMA
							ELSE IF (@xc_biotipo = '8') BEGIN
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPSUP001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '3') 
									DELETE FROM TMP_REPSUP001 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							END
							-- VIRDI / OUTROS
							ELSE  IF (@xc_biotipo != 'A') BEGIN					-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPVRD001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '3') 
									DELETE FROM TMP_REPVRD001 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							END
						END
							
						FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					END 
					CLOSE Rtmp_digeqptos
					DEALLOCATE Rtmp_digeqptos
				END
			END

			-- atualiza estado para tratado em REPNDIGAUTO000, SE N�O encontrou equipamento pertencente ao grupo e cai fora para tratar proximo funcionario
			UPDATE REPNDIGAUTO000 SET STATUS = '0' 			
				WHERE IFUNC = @c_ifunc and 
					BIO_TIPO = @c_biotipo and 
					CAST(Grupo AS INT) = CAST(@c_grupo AS INT)
			
			INSERT INTO TMP_NREPDIGATV (IFUNC, GRUPO, BIO_TIPO) VALUES (@c_ifunc, @c_grupo, @c_biotipo)

			FETCH NEXT FROM cur_autod000 INTO @c_ifunc, @c_status, @c_grupo, @c_biotipo
		END
		
		CLOSE cur_autod000
		DEALLOCATE cur_autod000
	END
			

	-- trata SAGEM
	-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSAG001 - INCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPSAG001 WHERE STATUS = '3')
	
	IF (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG002 (CARGA LISTA) se eqpto  n�o existir
		insert into RDIG002 (END_IP, STATUS, BIO_TIPO)
			select distinct end_ip, '0', '6' 
			from TMP_REPSAG001
			where TMP_REPSAG001.end_ip not in ( select end_ip from RDIG002 ) and 
					TMP_REPSAG001.STATUS = '3'	
		
		-- insere ifunc-rep em tab. RDIG001, se n�o existir em tab.
		DECLARE cur_tmpautoSAG001 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSAG001 where STATUS = '3' or STATUS = '1')
		OPEN cur_tmpautoSAG001
		FETCH NEXT FROM cur_tmpautoSAG001 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG001 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG001 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '6');
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			DELETE FROM RDIG101 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	-- DELETA DA TABELA DE EXCLUSAO

			FETCH NEXT FROM cur_tmpautoSAG001 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSAG001
		DEALLOCATE cur_tmpautoSAG001
	END

	
		-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSAG002 - EXCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPSAG002 WHERE STATUS = '8')
	if (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG102 (EXCLUSAO) o codin n�o existir
		INSERT INTO RDIG102 (END_IP, STATUS, BIO_TIPO) 
			select distinct end_ip, '0', '6'
			from TMP_REPSAG002
			where TMP_REPSAG002.end_ip not in ( select end_ip from RDIG102 ) and 
					TMP_REPSAG002.STATUS = '8'	
	
		-- insere ifunc-rep em tab. RDIG101, se n�o existir em tab.
		DECLARE cur_tmpautoSAG002 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSAG002 where STATUS = '8')
		OPEN cur_tmpautoSAG002
		FETCH NEXT FROM cur_tmpautoSAG002 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG101 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG101 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '6');
			end

			-- deleta o ifunc da tabela de INclusao para o rep especifico do grupo
			DELETE FROM RDIG001 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoSAG002 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSAG002
		DEALLOCATE cur_tmpautoSAG002
	end



	-- trata SUPREMA
	-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSUP001 - INCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPSUP001 WHERE STATUS = '3')
	
	IF (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG002 (CARGA LISTA) se eqpto  n�o existir
		insert into RDIG002 (END_IP, STATUS, BIO_TIPO)
			select distinct end_ip, '0', '8' 
			from TMP_REPSUP001
			where TMP_REPSUP001.end_ip not in ( select end_ip from RDIG002 ) and 
					TMP_REPSUP001.STATUS = '3'	
		
		-- insere ifunc-rep em tab. RDIG003, se n�o existir em tab.
		DECLARE cur_tmpautoSUP001 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSUP001 where STATUS = '3' or STATUS = '1')
		OPEN cur_tmpautoSUP001
		FETCH NEXT FROM cur_tmpautoSUP001 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG003 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG003 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '8');
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			DELETE FROM RDIG103 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoSUP001 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSUP001
		DEALLOCATE cur_tmpautoSUP001
	END

	
		-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSUP002 - EXCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPSUP002 WHERE STATUS = '8')
	
	if (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG102 (EXCLUSAO) o codin n�o existir
		INSERT INTO RDIG102 (END_IP, STATUS, BIO_TIPO) 
			select distinct end_ip, '0', '8'
			from TMP_REPSUP002
			where TMP_REPSUP002.end_ip not in ( select end_ip from RDIG102 ) and 
					TMP_REPSUP002.STATUS = '8'	
	
		-- insere ifunc-rep em tab. RDIG103, se n�o existir em tab.
		DECLARE cur_tmpautoSUP002 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSUP002 where STATUS = '8')
		OPEN cur_tmpautoSUP002
		FETCH NEXT FROM cur_tmpautoSUP002 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG103 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG103 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '8');
			end

			-- deleta o ifunc da tabela de INclusao para o rep especifico do grupo
			DELETE FROM RDIG003 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoSUP002 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSUP002
		DEALLOCATE cur_tmpautoSUP002
	END
	
	
	-- trata VIRDI / OUTRAS LEITORAS
	-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPVRD001 - INCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPVRD001 WHERE STATUS = '3')
	
	IF (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG002 (CARGA LISTA) se eqpto  n�o existir
		insert into RDIG002 (END_IP, STATUS, BIO_TIPO)
			--select distinct end_ip, '0', '9' 
			select distinct end_ip, '0', bio_tipo  
			from TMP_REPVRD001
			where TMP_REPVRD001.end_ip not in ( select end_ip from RDIG002 ) and 
					TMP_REPVRD001.STATUS = '3'	
		
		-- insere ifunc-rep em tab. RDIG004, se n�o existir em tab.
		DECLARE cur_tmpautoVRD001 CURSOR FOR (SELECT IFUNC, END_IP, STATUS, BIO_TIPO from TMP_REPVRD001 where STATUS = '3' or STATUS = '1')
		OPEN cur_tmpautoVRD001
		FETCH NEXT FROM cur_tmpautoVRD001 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		while @@fetch_status != -1
		begin
			UPDATE RDIG004 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG004 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', @xc_biotipo );
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			DELETE FROM RDIG104 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoVRD001 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		end
		CLOSE cur_tmpautoVRD001
		DEALLOCATE cur_tmpautoVRD001
	END

	
		-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPVRD002 - EXCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPVRD002 WHERE STATUS = '8')
	
	if (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG102 (EXCLUSAO) o codin n�o existir
		INSERT INTO RDIG102 (END_IP, STATUS, BIO_TIPO) 
			--select distinct end_ip, '0', '9'
			select distinct end_ip, '0', bio_tipo 
			from TMP_REPVRD002
			where TMP_REPVRD002.end_ip not in ( select end_ip from RDIG102 ) and 
					TMP_REPVRD002.STATUS = '8'	
	
		-- insere ifunc-rep em tab. RDIG104, se n�o existir em tab.
		DECLARE cur_tmpautoVRD002 CURSOR FOR (SELECT IFUNC, END_IP, STATUS, BIO_TIPO from TMP_REPVRD002 where STATUS = '8')
		OPEN cur_tmpautoVRD002
		FETCH NEXT FROM cur_tmpautoVRD002 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		while @@fetch_status != -1
		begin
			UPDATE RDIG104 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG104 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								--values (@xc_ifunc, @xc_endip, '1', '9');
								values (@xc_ifunc, @xc_endip, '1', @xc_biotipo );
			end

			-- deleta o ifunc da tabela de INclusao para o rep especifico do grupo
			DELETE FROM RDIG004 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoVRD002 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		end
		CLOSE cur_tmpautoVRD002
		DEALLOCATE cur_tmpautoVRD002
	end	

	SET LOCK_TIMEOUT -1

GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.trata3_RepSagem'))
	DROP PROCEDURE TELESSVR.trata3_RepSagem
GO

CREATE PROCEDURE TELESSVR.trata3_RepSagem 
AS


DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)

DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000


	-- ********************   ARRUMAR SITUA��ES PARA SAGEM    -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA (status '4')
	DECLARE Rcur_troubleIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG001 
			WHERE STATUS = '4'
		)
	OPEN Rcur_troubleIns1
	FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE Rcur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from RDIG001 
				WHERE (IFUNC = @z_mat and STATUS = '4')
			)
		OPEN Rcur_troubleIns2
		FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			--DELETE RDIG001 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')	-- vai excluir registro porque nao adianta reenviar 
			UPDATE RDIG001 set status = '0' WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')	-- vai alterar status porque nao adianta reenviar 

			UPDATE RDIG002 set status = '1' WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip
		END


		CLOSE Rcur_troubleIns2
		deallocate Rcur_troubleIns2

		FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	END
	
	CLOSE Rcur_troubleIns1
	deallocate Rcur_troubleIns1


	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS SAGEM (DA TAB.CONTDIG_SAGEM CADASTRO)
	-- delete registro de RDIG001 se nao houver cadastro de BIO SAGEM desta matricula
	DECLARE Rcur_autoIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG001 
			WHERE STATUS = '3'
		)
	OPEN Rcur_autoIns1
	FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		-- VERIFICA SE H� CADASTRO DO BIO SAGEM DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_SAGEM WHERE ICARD = @z_mat;
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO SAGEM desta matricula
			DECLARE Rcur_autoIns2 CURSOR FOR 
				(SELECT END_IP from RDIG001 
					WHERE (IFUNC = @z_mat and STATUS = '3')
				)
			OPEN Rcur_autoIns2
			FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				DELETE RDIG001 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '3')

				UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip
			END


			CLOSE Rcur_autoIns2
			deallocate Rcur_autoIns2
		END

		FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat
	END
	
	CLOSE Rcur_autoIns1
	deallocate Rcur_autoIns1



	-- ******************** ALTERA STATUS DE TODOS OS CODINS PARA CARGA DE DIGITAIS, SE ESSES N�O ESTIVEREM COM CARGA DE DIGITAIS OU ESTIVEREM PENDENTES
	-- nao altera status se o equipamento responde 'NAO IMPLEMENTADO'
	DECLARE Rcur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG001 
			--WHERE ( status != '0' and status != '2' and			-- biometrias pendentes na carga
			WHERE ( status != '0' and status != '2' and status != '4' and			-- biometrias pendentes na carga
					(BIO_TIPO = '6' OR BIO_TIPO = '7')
				  )
		)
	OPEN Rcur_endip
	FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status
	
	WHILE @@fetch_status != -1
	begin
		UPDATE RDIG002 set status = '1'						-- FORCA RECARGA DAS BIOMETRIAS PENDENTES, ATIVANDO DIG002
			WHERE (END_IP = @z_endip and 
					(STATUS = '0' or STATUS = '3' or STATUS = '4') and 		-- status '0':carregado, '3':pendente, '4':rep nao aceita carga digital
					BIO_TIPO = @z_biotipo)
		FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status
	end

	CLOSE Rcur_endip
	deallocate Rcur_endip




	-- ********************   TRATA EQUIPAMENTOS SAGEM QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos SAGEM q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos SAGEM que tiveram carga de aplicativo ('5') de devem voltar ao estado de repouso. OBS: nao est� fazenda a recarga de biometria automaticamente.
	
	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from RDIG002 
			WHERE ((BIO_TIPO = '6' or BIO_TIPO = '7')
					and
				   (status = '5' or status = '6' OR		-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())) 
				  )
		)
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status
	
	WHILE @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE RDIG001 set STATUS = '1'			-- status = 1 (A carregar)
				WHERE (end_ip = @z_endip and status = '2' and BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')
					
			UPDATE RDIG002 set status = '1'  		-- FOR�A A RECARGA PARA AQUELS QUE DERAM PROBLEMA
				where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)
		end

		else if (@z_status = '5' or @z_status = '6') begin
			UPDATE RDIG002 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)		-- NAO FAZ RECARGA DE BIOMETRIAS SAGEM APOS CARGA DE APLICATIVO
		end;
		
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_dig02
	DEALLOCATE Rcur_dig02
	

	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUA��O
	-- para BIOMETRIAS  SAGEM DE DIG001 que ficaram em estado carregando '2', e o equipamento est� em estado de repouso	, forca o equipamento a carrega-lo novamente
	
	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.STATUS from RDIG002 A 
			INNER JOIN RDIG001 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				(A.BIO_TIPO = '6') or (A.BIO_TIPO = '7')) 
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG001 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and (BIO_TIPO = '6' or BIO_TIPO = '7');
		UPDATE RDIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip and (BIO_TIPO = '6' or BIO_TIPO = '7');
		
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status;
	END
	CLOSE Rcur_dig02
	deallocate Rcur_dig02
	

	


	-- ********************   ARRUMAR SITUA��ES PARA SAGEM    -  EXCLUSAO
	
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins Sagem para exclusao de biometria, se esses n�o estiverem com exclusao de biometria ou estiverem pendentes

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO  from RDIG101 
			--WHERE ( STATUS != '0' and STATUS != '2' and 
			WHERE ( STATUS != '0' and STATUS != '2' and STATUS != '4' and 
					(BIO_TIPO = '6' or BIO_TIPO = '7')
				  )
		)
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG102 set status = '1'
			WHERE (END_IP = @z_endip) and 
				--(STATUS = '0' or STATUS = '3') and 
				(STATUS = '0' or STATUS = '3' or STATUS = '4') and 
				(BIO_TIPO = '6' or BIO_TIPO = '7')

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1



	
	
	-- ********************   TRATA EQUIPAMENTOS SAGEM QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG102 
			WHERE ( (BIO_TIPO = '6' or BIO_TIPO = '7')
					and   
					(status = '5' or status = '6' or 													-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin

			UPDATE RDIG101 set status = '1'
				WHERE (END_IP = @z_endip and STATUS = '2' and BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')

			UPDATE RDIG102 set status = '1' 
					where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)
		end
		
		else if (@z_status = '5' OR @z_status = '6') begin
			UPDATE RDIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1



	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUA��O
	-- para digitais de RDIG101 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.status from RDIG102 A 
			INNER JOIN RDIG101 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				(A.BIO_TIPO = '6' or A.BIO_TIPO = '7'))
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG101 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and (BIO_TIPO = '6' or BIO_TIPO = '7');
		UPDATE RDIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip AND (BIO_TIPO = '6' or BIO_TIPO = '7');

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status;
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1

	SET LOCK_TIMEOUT -1

GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.trata3_Reptsi1'))
	DROP PROCEDURE TELESSVR.trata3_Reptsi1
GO

CREATE PROCEDURE TELESSVR.trata3_Reptsi1 
AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)

DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000


	-- ********************   ARRUMAR SITUA��ES PARA TSI1    -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA  (status '4')
	DECLARE Rcur_troubleIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG003 
			WHERE STATUS = '4'
		)
	OPEN Rcur_troubleIns1
	FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE Rcur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from RDIG003 
				WHERE (IFUNC = @z_mat and STATUS = '4')
			)
		OPEN Rcur_troubleIns2
		FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			--DELETE RDIG003 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')
			UPDATE RDIG003 SET STATUS = '0' WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')

			UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip
		END


		CLOSE Rcur_troubleIns2
		deallocate Rcur_troubleIns2

		FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	END
	
	CLOSE Rcur_troubleIns1
	deallocate Rcur_troubleIns1



	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS TSI1 (DA TAB.CONTDIG_TSI1 CADASTRO)
	-- delete registro de RDIG003 se nao houver cadastro de BIO TSI1 desta matricula
	DECLARE Rcur_autoIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG003 
			WHERE STATUS = '3'
		)
	OPEN Rcur_autoIns1
	FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		-- VERIFICA SE H� CADASTRO DO BIO TSI1 DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_TSI1 WHERE ICARD = @z_mat;
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO TSI1 desta matricula
			DECLARE Rcur_autoIns2 CURSOR FOR 
				(SELECT END_IP from RDIG003 
					WHERE (IFUNC = @z_mat and STATUS = '3')
				)
			OPEN Rcur_autoIns2
			FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				DELETE RDIG003 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '3')

				UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip
			END


			CLOSE Rcur_autoIns2
			deallocate Rcur_autoIns2
		END

		FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat
	END
	
	CLOSE Rcur_autoIns1
	deallocate Rcur_autoIns1



	-- ******************** ALTERA STATUS DE TODOS OS CODINS PARA CARGA DE DIGITAIS, SE ESSES N�O ESTIVEREM COM CARGA DE DIGITAIS OU ESTIVEREM PENDENTES
	-- nao altera status se o equipamento responde 'NAO IMPLEMENTADO'
	DECLARE Rcur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG003 
			--WHERE (STATUS != '0' and STATUS != '2' AND BIO_TIPO = '8')		-- biometrias pendentes na carga
			WHERE (STATUS != '0' and STATUS != '2' and STATUS != '4' AND BIO_TIPO = '8')		-- biometrias pendentes na carga
		)
	OPEN Rcur_endip
	FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status 
	
	while @@fetch_status != -1
	begin
		IF (@z_status != '4') begin
			UPDATE RDIG002 set status = '1'
				WHERE (END_IP = @z_endip and 
						--(STATUS = '0' or STATUS= '3') and 
						(STATUS = '0' or STATUS= '3' or STATUS= '4') and 		-- status '0':carregado, '3':pendente, '4':rep nao aceita carga digital
						BIO_TIPO = @z_biotipo)
		end
		FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_endip
	deallocate Rcur_endip



	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos TSI1 q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos TSI1 q tiveram carga de aplicativo 
	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from RDIG002 
			WHERE ((BIO_TIPO = '8')
					and 
				   (status = '5' or status = '6' or 		-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())) 
				  )
		)
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status

	WHILE @@fetch_status != -1
	begin
		-- OBSERVACAO: PARA BIOMETRIA TSI1, A CARGA DE APLICATIVO NO EQUIPAMENTO NAO APAGA AS BIOMETRIAS, POIS BIOMETRIA TSI1 FICA NO LEITOR E NAO NO EQUIPAMENTO,
		-- LOGO NAO � NECESSARIO FAZER A RECARGA DE BIOMETRIA
		IF (@z_status = '2') begin		-- situa��o q estava fazendo a carga e deu problema

			UPDATE RDIG003 set STATUS = '1'			-- status = 1 : a carregar
				WHERE (END_IP = @z_endip and STATUS = '2'  and BIO_TIPO = @z_biotipo) 

			UPDATE RDIG002 set status = '1' 
				where (END_IP = @z_endip and BIO_TIPO = @z_biotipo)
		end

		ELSE begin
			IF (@z_status = '5' OR @z_status = '6') begin		-- HOUVE CARGA DE APLICATIVO, MAS NAO VAI RECARREGAR AS BIOMETRIAS
				UPDATE RDIG002 set status = '0' 
					WHERE (end_ip = @z_endip  and BIO_TIPO = @z_biotipo)
			end
		end
		
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end

	CLOSE Rcur_dig02
	DEALLOCATE Rcur_dig02
	


	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUA��O
	-- para BIOMETRIAS  TSI1 DE RDIG003 que ficaram em estado carregando '2', e o equipamento est� em estado de repouso	, forca o equipamento a carrega-lo novamente

	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.status from RDIG002 A 
			INNER JOIN RDIG003 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = '8')
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG003 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' AND BIO_TIPO = '8';
		UPDATE RDIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip  and BIO_TIPO = '8';
			
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status;
	END
	CLOSE Rcur_dig02
	deallocate Rcur_dig02
	


	-- ********************   ARRUMAR SITUA��ES PARA   TSI1   -  EXCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins Sagem para exclusao de biometria, se esses n�o estiverem com exclusao de biometria ou estiverem pendentes

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO from RDIG103 
			--WHERE (STATUS != '0' and STATUS != '2' and BIO_TIPO = '8')
			WHERE (STATUS != '0' and STATUS != '2' and STATUS != '4' and BIO_TIPO = '8')		-- statys 4 indica resposta do rep de nao implementado
		)
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG102 set STATUS = '1'
			WHERE (END_IP = @z_endip) and 
			  	  --(STATUS = '0' or STATUS = '3') and 
			  	  (STATUS = '0' or STATUS = '3' or STATUS = '4') and 		-- statys 4 indica resposta do rep de nao implementado
				  (BIO_TIPO = '8')

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1
	


	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG102 
			WHERE ( (BIO_TIPO = '8')
					and   
					(status = '5' or status = '6' or 													-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip,  @z_biotipo, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE RDIG103 set status = '1'
				WHERE (END_IP = @z_endip) and (status = '2') and (BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')

			UPDATE RDIG102 set status = '1' 
				WHERE (END_IP = @z_endip  and BIO_TIPO = @z_biotipo)
		end
				
		else if (@z_status = '5' OR @z_status = '6') begin
			UPDATE RDIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;
				
		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1



	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUA��O
	-- para digitais de RDIG103 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.status from RDIG102 A 
			INNER JOIN RDIG103 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = '8')
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG103 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and BIO_TIPO = '8';
		UPDATE RDIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip and BIO_TIPO = '8';
	
		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status;
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1

	SET LOCK_TIMEOUT -1
	
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.trata2_RepOutrosBios'))
	DROP PROCEDURE TELESSVR.trata2_RepOutrosBios
GO

CREATE PROCEDURE TELESSVR.trata2_RepOutrosBios 
AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)

DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000


	-- ********************   ARRUMAR SITUA��ES PARA VIRDI / OUTRAS BIOS   -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS  QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA  (status '4')
	DECLARE Rcur_troubleIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG004 
			WHERE STATUS = '4'
		)
	OPEN Rcur_troubleIns1
	FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE Rcur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from RDIG004 
				WHERE (IFUNC = @z_mat and STATUS = '4')
			)
		OPEN Rcur_troubleIns2
		FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			--DELETE RDIG004 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')
			UPDATE RDIG004 SET STATUS = '0' WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')

			UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip
		END


		CLOSE Rcur_troubleIns2
		deallocate Rcur_troubleIns2

		FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	END
	
	CLOSE Rcur_troubleIns1
	deallocate Rcur_troubleIns1


	-- ***********************  TRATA AS BIOMETRIAS VIRDI QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS VIRDI (DA TAB.CONTDIG_OUTROS CADASTRO)
	-- delete registro de RDIG004 se nao houver cadastro de BIO VIRDI desta matricula
	
	DECLARE Rcur_autoIns1 CURSOR FOR 
		(SELECT distinct IFUNC, BIO_TIPO from RDIG004 
			WHERE STATUS = '3'
		)
	OPEN Rcur_autoIns1
	FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat, @z_biotipo
	WHILE (@@fetch_status != -1) BEGIN
		
		-- VERIFICA SE H� CADASTRO DO BIO VIRDI DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_OUTROS WHERE ICARD = @z_mat and BIO_TIPO = @z_biotipo;
		
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO VIRDI desta matricula
			
			DECLARE Rcur_autoIns2 CURSOR FOR 
				(SELECT END_IP from RDIG004 
					WHERE (IFUNC = @z_mat and STATUS = '3' and BIO_TIPO = @z_biotipo)
				)
			OPEN Rcur_autoIns2
			FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				DELETE RDIG004 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '3')

				UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip
			END


			CLOSE Rcur_autoIns2
			deallocate Rcur_autoIns2
		END

		FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat, @z_biotipo
	END
	
	CLOSE Rcur_autoIns1
	deallocate Rcur_autoIns1



	-- ******************** ALTERA STATUS DE TODOS OS CODINS PARA CARGA DE DIGITAIS, SE ESSES N�O ESTIVEREM COM CARGA DE DIGITAIS OU ESTIVEREM PENDENTES
	-- nao altera status se o equipamento responde 'NAO IMPLEMENTADO'
	DECLARE Rcur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG004 
			--WHERE (STATUS != '0' and STATUS != '2' AND BIO_TIPO = '9')		-- biometrias pendentes na carga
			WHERE (STATUS != '0' and STATUS != '2' )		-- biometrias pendentes na carga
		)
	OPEN Rcur_endip
	FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status 
	
	while @@fetch_status != -1
	begin
		IF (@z_status != '4') begin
			UPDATE RDIG002 set status = '1'
				WHERE (END_IP = @z_endip and 
						--(STATUS = '0' or STATUS= '3') and 
						(STATUS = '0' or STATUS= '3' or STATUS= '4') and 		-- status '0':carregado, '3':pendente, '4':rep nao aceita carga digital
						BIO_TIPO = @z_biotipo)
		end
		FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_endip
	deallocate Rcur_endip



	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos VIRDI q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos VIRDI q tiveram carga de aplicativo 
	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from RDIG002 
			WHERE (((BIO_TIPO != '6') and (BIO_TIPO != '7') and (BIO_TIPO != '8')) 
					and 
				   (status = '5' or status = '6' or		-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())) 
				  )
		)
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status

	WHILE @@fetch_status != -1
	begin
		-- OBSERVACAO: PARA BIOMETRIA VIRDI, A CARGA DE APLICATIVO NO EQUIPAMENTO NAO APAGA AS BIOMETRIAS, POIS BIOMETRIA VIRDI FICA NO LEITOR E NAO NO EQUIPAMENTO,
		-- LOGO NAO � NECESSARIO FAZER A RECARGA DE BIOMETRIA
		IF (@z_status = '2') begin		-- situa��o q estava fazendo a carga e deu problema

			UPDATE RDIG004 set STATUS = '1'			-- status = 1 : a carregar
				WHERE (END_IP = @z_endip and STATUS = '2'  and BIO_TIPO = @z_biotipo) 

			UPDATE RDIG002 set status = '1' 
				where (END_IP = @z_endip and BIO_TIPO = @z_biotipo)
		end

		ELSE begin
			IF (@z_status = '5' OR @z_status = '6') begin		-- HOUVE CARGA DE APLICATIVO, MAS NAO VAI RECARREGAR AS BIOMETRIAS
				UPDATE RDIG002 set status = '0' 
					WHERE (end_ip = @z_endip  and BIO_TIPO = @z_biotipo)
			end
		end
		
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end

	CLOSE Rcur_dig02
	DEALLOCATE Rcur_dig02
	


	-- ***********************  TRATA AS BIOMETRIAS VIRDI QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUA��O
	-- para BIOMETRIAS  VIRDI DE RDIG004 que ficaram em estado carregando '2', e o equipamento est� em estado de repouso	, forca o equipamento a carrega-lo novamente

	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.status, A.BIO_TIPO from RDIG002 A 
			INNER JOIN RDIG004 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = B.BIO_TIPO)
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG004 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' AND BIO_TIPO = @z_biotipo;
		UPDATE RDIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip  and BIO_TIPO = @z_biotipo;
			
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status, @z_biotipo;
	END
	CLOSE Rcur_dig02
	deallocate Rcur_dig02
	


	-- ********************   ARRUMAR SITUA��ES PARA   VIRDI   -  EXCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS VIRDI QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins VIRDI para exclusao de biometria, se esses n�o estiverem com exclusao de biometria ou estiverem pendentes

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO from RDIG104 
			--WHERE (STATUS != '0' and STATUS != '2' and BIO_TIPO = '9')
			WHERE (STATUS != '0' and STATUS != '2' and STATUS != '4')		-- statys 4 indica resposta do rep de nao implementado
		)
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG102 set STATUS = '1'
			WHERE (END_IP = @z_endip) and 
			  	  --(STATUS = '0' or STATUS = '3') and 
			  	  (STATUS = '0' or STATUS = '3' or STATUS = '4') and 		-- statys 4 indica resposta do rep de nao implementado
				  (BIO_TIPO = @z_biotipo)

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1
	


	-- ********************   TRATA EQUIPAMENTOS VIRDI QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG102 
			WHERE (((BIO_TIPO != '6') and (BIO_TIPO != '7') and (BIO_TIPO != '8')) 
					and   
					(status = '5' or status = '6' or 														-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip,  @z_biotipo, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE RDIG104 set status = '1'
				WHERE (END_IP = @z_endip) and (status = '2') and (BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')

			UPDATE RDIG102 set status = '1' 
				WHERE (END_IP = @z_endip  and BIO_TIPO = @z_biotipo)
		end
				
		else if (@z_status = '5' or @z_status = '6') begin
			UPDATE RDIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;
				
		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1



	-- ***********************  TRATA AS BIOMETRIAS VIRDI QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUA��O
	-- para digitais de RDIG104 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.status, A.BIO_TIPO from RDIG102 A 
			INNER JOIN RDIG104 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = B.BIO_TIPO)
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG104 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and BIO_TIPO = @z_biotipo;
		UPDATE RDIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip and BIO_TIPO = @z_biotipo;
	
		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status, @z_biotipo;
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1

	SET LOCK_TIMEOUT -1
	
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.P_RepGerDigital3'))
	DROP PROCEDURE TELESSVR.P_RepGerDigital3
GO

CREATE PROCEDURE TELESSVR.P_RepGerDigital3  @nQtd INT
AS

DECLARE @ret CHAR(1)


	SET DATEFORMAT YMD


	set @ret = 0
	
	-- prepara automatico digitais sagem RDIG001 / RDIG101
	exec TELESSVR.AntePrep3_RSagem	@nQtd
	
	-- prepara automatico digitais tsi1 RDIG003 / RDIG103
	exec TELESSVR.AntePrep3_RTsi1 @nQtd	

	-- prepara automatico digitais virdi E OUTROS RDIG004 / RDIG104
	exec TELESSVR.AntePrep2_ROutrosBios @nQtd


	exec TELESSVR.Prep_RepDigit3 @nQtd


	-- trata biometria sagem
	exec TELESSVR.trata3_RepSagem	

	-- trata biometria tsi1
	exec TELESSVR.trata3_RepTsi1		
	
	-- trata biometria virdi/outros
	exec TELESSVR.trata2_RepOutrosBios		
	
	
	select @ret
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

--------------------------------------------------------------------
-- Create date: 	07/05/2020 - 16:13
-- Changed:			07/05/2020 - 16:13
-- Redmine: 		@6052
--------------------------------------------------------------------

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'REPAFD001_IDX01')
    CREATE INDEX REPAFD001_IDX01 ON TELESSVR.REPAFD001 ( END_IP, REP, NSR );
GO
IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('REPAFD001_TGR01'))
	DROP TRIGGER TELESSVR.REPAFD001_TGR01;
GO

-----------------------------------------------------------------------------------
-- CONEX ACESSO V.40.00.03 || CONEX ACESSO V.40.00.03 || CONEX ACESSO V.40.00.03 ||
-----------------------------------------------------------------------------------

-- OBS: HOUVE ALTERACAO SOMENTE NA APLICACAO DO CONEX

-----------------------------------------------------------------------------------
-- 2.10.10.0 || 2.10.10.0 || 2.10.10.0 || 2.10.10.0 || 2.10.10.0 || 2.10.10.0 || --
-----------------------------------------------------------------------------------

-----------------------------------------------------------------------------------
-- CONEX ACESSO V.40.01.01 || CONEX ACESSO V.40.01.01 || CONEX ACESSO V.40.01.01 ||
-----------------------------------------------------------------------------------

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'ESTAC001_IND1')
    DROP INDEX TELESSVR.ESTAC001.ESTAC001_IND1;
GO
IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'ESTAC001_IND2')
    DROP INDEX TELESSVR.ESTAC001.ESTAC001_IND2;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'ESTAC001' AND UPPER(COLUMN_NAME) = 'GREST')
    ALTER TABLE TELESSVR.ESTAC001 ALTER COLUMN GREST CHAR(6);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'ESTAC001_IND1')
    CREATE UNIQUE INDEX ESTAC001_IND1 ON TELESSVR.ESTAC001 (END_IP);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'ESTAC001_IND2')
    CREATE INDEX ESTAC001_IND2 ON TELESSVR.ESTAC001 (GREST);
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'ESTAC002_IND1')
    DROP INDEX TELESSVR.ESTAC002.ESTAC002_IND1;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'ESTAC002' AND UPPER(COLUMN_NAME) = 'GREST')
    ALTER TABLE TELESSVR.ESTAC002 ALTER COLUMN GREST CHAR(6);
GO
IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'ESTAC002' AND UPPER(COLUMN_NAME) = 'MAX_FIXO')
    ALTER TABLE TELESSVR.ESTAC002 ALTER COLUMN MAX_FIXO NUMERIC(5,0);
GO
IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'ESTAC002' AND UPPER(COLUMN_NAME) = 'MAX_ROT')
    ALTER TABLE TELESSVR.ESTAC002 ALTER COLUMN MAX_ROT NUMERIC(5,0);
GO
IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'ESTAC002' AND UPPER(COLUMN_NAME) = 'CONT_FIXO')
    ALTER TABLE TELESSVR.ESTAC002 ALTER COLUMN CONT_FIXO NUMERIC(5,0);
GO
IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'ESTAC002' AND UPPER(COLUMN_NAME) = 'CONT_ROT')
    ALTER TABLE TELESSVR.ESTAC002 ALTER COLUMN CONT_ROT NUMERIC(5,0);
GO

IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'ESTAC002' AND UPPER(COLUMN_NAME) = 'REGRA')
    ALTER TABLE TELESSVR.ESTAC002 ADD REGRA CHAR(1) DEFAULT '0' NOT NULL CONSTRAINT tp_estac9 CHECK (REGRA >= '0' AND REGRA <= '9')
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'ESTAC002_IND1')
    CREATE UNIQUE INDEX ESTAC002_IND1 ON TELESSVR.ESTAC002 (GREST)
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'INDEX1_ESTAC003')
    DROP INDEX TELESSVR.ESTAC003.INDEX1_ESTAC003;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'ESTAC003' AND UPPER(COLUMN_NAME) = 'GREST')
    ALTER TABLE TELESSVR.ESTAC003 ALTER COLUMN GREST CHAR(6)
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'ESTAC003_IND1')
    CREATE UNIQUE INDEX ESTAC003_IND1 ON TELESSVR.ESTAC003 (ICARD, GREST)
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlconG3G5_ace_usuario3')
	DROP PROCEDURE TELESSVR.sqlconG3G5_ace_usuario3;
GO

CREATE PROCEDURE TELESSVR.sqlconG3G5_ace_usuario3 @cMatricNS char(22), @cInform char(20), @cTipTerm char(1), @cEndIp char(15), @cOwner char(30), @cDataOcorr char(10), @cVisita char(12) AS
DECLARE	@cReg1 as varchar(250), @cReg2 as varchar(250), @cReg3 as varchar(250), 
		@cReg4 as varchar(250), @RetFun SMALLINT,
		@cReg5 as varchar(250), @cReg6 as varchar(250), @cReg7 as varchar(250), @cReg8 as varchar(250),
		@cReg9 as varchar(250), @cReg10 as varchar(250), @cReg11 as varchar(250)
DECLARE @ret int, @cUsuLock char(15), @cFxDiaEsp char(28), @cFxCred char(4), @Result int, @cMatBusca char(12)
DECLARE	@cIniHalm char(12), @cFimHalm char(12), @cIniIntj char(12), @cFimIntj char(12), @cFimAntD char(12)
DECLARE	@cIniHalmAux char(16), @cFimHalmAux char(16), @cIniIntjAux char(16), @cFimIntjAux char(16), @cFimAntDAux char(16)
DECLARE @dDataBD DATETIME, @dDataOcor DATETIME;
DECLARE @pos int
DECLARE @cModo char(1), @cFazLock char(1), @cDesbloqRev char(1),@cVerNumS char(1)
DECLARE @cVarAux char(12)
--DECLARE @nGrest int, @nGrestEquip int, @nCont int
DECLARE @nGrEstFixa int, @nGrestEquip int, @nCont int
DECLARE @nArea int, @nAreaEquip int
--DECLARE	@cEmFixa char(1), @AuxGr char(3), @AuxGr2 varchar(3);
DECLARE	@cEmFixa char(1), @AuxGr char(6), @AuxGr2 varchar(6);
DECLARE @cEscoltado char(12), @cEscolta char(12), @cTemEsc char(1), @cEhEscolta char(1), @cProcurado char(12), @cSentido CHAR(1)
DECLARE @nContArea int, @cFinalSentido CHAR(1), @AuxSentido CHAR(1), @nAuxArea int
DECLARE @cSituaAux char(1)
DECLARE @cRegra char(1)

DECLARE
        @cMatric   char(12),
        @cIcard    char(12),
        @cCPF	   char(11),
        @cNumSerial	   char(10),
		@cBloqBDCC char(1),
        --@cGrupo    char(3),
        @cCodig    char(6),
        @cTpFis    char(1),
        @cSitua    char(1),
        --@cSubNv    char(5),
        --@cPlanta   char(3),
        @cDataHora char(10),
        @cUltrs    char(25),
        @cDatIni   char(6),
        @cDatFim   char(6),
        @cTitular  char(12),
        @cFx_Flg   char(1), 
        @cFx_Dta   char(11), 
        @cFx_Alm   char(3),
        @cMensagem char(32), 
        @cDta_mens char(6),
        @cQtd_mens char(2),
        @cCred_Fx1 char(2), 
        @cCred_Fx2 char(2),
        @cCred_Fx3 char(2),
        @cCred_Fx4 char(2),
        @cCred_Fx5 char(2),
        @cCred_Fx6 char(2),
        @cFx1 char(8), 
        @cFx2 char(8), 
        @cFx3 char(8), 
        @cFx4 char(8), 
        @cFx5 char(8), 
        @cFx6 char(8), 
        @cUltPasR  char(10),
        --@cGrupo1   char(3),
        @cDatIniG1 char(10),
        @cDatFimG1 char(10),
        --@cGrupo2   char(3),
        @cDatIniG2 char(10),
        @cDatFimG2 char(10),
        --@cGrupo3   char(3),
        @cDatIniG3 char(10),
        @cDatFimG3 char(10),
        --@cGpoSab   char(3),
        --@cGpoDom   char(3),
        --@cGpoFer   char(3),
        @cAnti_D   char(1),
        @cBloq     char(1),
        @cVHora    char(1),
        @cVLocal   char(1),
        @cVValid   char(1),
        @cVAfast   char(1),
        @cVCred    char(1),
        @cVisEsp   char(1),
        @cVPonto   char(1),
        @cPonto    char(1),	
        @cVDigit   char(1),
      	@cTpoIntj  char(3), 
      	@cTolIntj  char(3), 
      	@cInterj   char(1),
      	@cTpoJorn  char(3), 
      	@cSaidaMax   char(1),
      	@cTipoDoc	char(1),
		@cVnDias   char(2),
		@cDiasSuc  char(2),
		@cPne    char(1),
		@cBloqRev    char(1),
		@cvViaRep char(1)

DECLARE
@cGrupo    char(5),	-- novo
@cSubNv    char(7),	-- novo
@cGrupo1   char(5),	-- novo
@cGrupo2   char(5),	-- novo
@cGrupo3   char(5),	-- novo
@cGpoSab   char(5),	-- novo
@cGpoDom   char(5),	-- novo
@cGpoFer   char(5),	-- novo
@cAdBuf VARCHAR(2),			-- novo
@nTamG int,
@cPlanta   char(5)

/*
DECLARE
@cGrupo    varchar(5),	-- novo
@cSubNv    varchar(7),	-- novo
@cGrupo1   varchar(5),	-- novo
@cGrupo2   varchar(5),	-- novo
@cGrupo3   varchar(5),	-- novo
@cGpoSab   varchar(5),	-- novo
@cGpoDom   varchar(5),	-- novo
@cGpoFer   varchar(5),	-- novo
@cAdBuf CHAR(2),			-- novo
@nTamG int,
@cPlanta   varchar(5)
*/


DECLARE @stmt1 nvarchar(4000)
DECLARE @ParmDefinition nvarchar(500);



	SET LOCK_TIMEOUT 1000	
	SET @RetFun = 0
	SET @cReg1  = ''
	SET @cReg2  = ''
	SET @cReg3  = ''
	SET @cReg4  = ''

	SET @cReg5  = ''
	SET @cReg6  = ''
	SET @cReg7  = ''
	SET @cReg8  = ''
	SET @cUsuLock = @cEndIp

	SELECT @cAdBuf = null
	SELECT @nTamG = 3 
	SELECT	@nTamG  = COLUNAS.LENGTH
	FROM 
		SYSOBJECTS AS TABELAS,
		SYSCOLUMNS AS COLUNAS
	WHERE 
		-- JOINS 
		TABELAS.ID = COLUNAS.ID
		AND TABELAS.NAME = 'DAT07'
		AND COLUNAS.NAME = 'LACES'


	SET @Result = 1	
	SET @cMatric = substring(@cMatricNS, 1, 12);
	SET @cMatBusca = '000000000000'
	SET @cTipoDoc = '0'
	SET @cBloqBDCC = '0'
	SET @cFx1 = '24002400'
	SET @cFx2 = '24002400'
	SET @cFx3 = '24002400'
	SET @cFx4 = '24002400'
	SET @cFx5 = '24002400'
	SET @cFx6 = '24002400'

	set DATEFORMAT dmy
	SET @dDataOcor = CAST((substring(@cDataOcorr,5,2)+'-'+
							 substring(@cDataOcorr,7,2)+'-'+
							 substring(@cDataOcorr,9,2)+' '+
							 substring(@cDataOcorr,1,2)+':'+
							 substring(@cDataOcorr,3,2)+':'+
							 '00') AS datetime);

	SET @cModo = substring(@cInform, 1, 1);  -- TIPO DE PESQUISA
	-- cModo = 0 :icard; 
	-- cModo = 1 :numero serial
	-- cModo = 2 :cpf
	-- cModo = 3 :bdcc


	SET @cFazLock = 	substring(@cInform, 3, 1);  -- SE CONSULTA ONLINE
	SET @cDesbloqRev = 	substring(@cInform, 4, 1);  -- SE DESBLOQUEIO REVISTA
	SET @cVerNumS = 	substring(@cInform, 5, 1);  -- SE verifica NUMSERIAL
	SET @cEhEscolta =  	substring(@cInform, 6, 1);	-- SE É INDICADOR DE ESCOLTA

	-- *******************************************************
	-- verifica se modo de busca é por CPF
	IF (@cModo ='2') begin					-- CPF
		SELECT	@cIcard   = a.ICARD,
				@cCPF	  = c.CPF,
				@cTipoDoc = c.TIPODOC
				
			FROM ContCPF c 
				INNER JOIN Controle a
					ON c.CPF = substring(@cMatric, 2, 11) and c.icard = a.icard 

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end
	
	-- *******************************************************
	-- verifica se modo de busca é por ICARD
	ELSE IF (@cModo = '0') begin  			-- ICARD
		IF (@cVerNumS = '1') BEGIN
			SELECT	@cIcard   = a.ICARD,
					@cNumSerial  = a.NUMSERIAL
				FROM Controle a 
			WHERE a.ICARD = @cMatric and
   				  a.NumSerial = substring(@cMatricNS, 13, 10) 
				
			IF (@@ROWCOUNT = 0) begin
				-- SITUACAO SURICATO: VARIOS CARTOES SM COM MESMO ICARD, E NA CONTROLE ESTAO OS VALORES DE NUM.SERIAL NA COLUNA ICARD, TODOS COM O MESMO VALOR DO TITULAR
				-- A BUSCA PRIMEIRO SERA FEITA ICARD+NUMSERIAL. SE NÃO ACHOU, QUE É ONDE SE ENCONTRA AGORA, A BUSCA SERÁ SOBRE TITULAR+ICARD. QDO ENCONTRAR, O VALOR DE
				-- CMATBUSCA SERÁ O VALOR DO CAMPO ICARD

				SELECT	@cIcard   = a.TITULAR,
						@cVarAux  = a.ICARD,
						@cSituaAux  = a.SITUA
					FROM Controle a 
				WHERE a.TITULAR = @cMatric and
					  a.ICARD = '00'+substring(@cMatricNS, 13, 10) 

				IF (@@ROWCOUNT = 0) begin
					set @cIcard = '000000000000'	-- 12 zeros
					SET @RetFun = -2
					SET @Result = 0	
				end
				ELSE begin
					-- antes de atribuir @cMatBusca = @cIcard, deve-se verificar se a situação é invalida. 
					-- Se invalida, 	cMatBusca := VarAux, para que retorne situação invalida ao Conex										
					--	SET	@cMatBusca = @cIcard;
					IF (@cSituaAux = '1') 
						SET	@cMatBusca = @cVarAux;	
					ELSE
						SET	@cMatBusca = @cIcard;
				end
			end
			ELSE begin
				SET	@cMatBusca = @cIcard;
			end
		end	

		ELSE begin
			SET @cMatBusca = @cMatric;
		end
	end
				
	-- *******************************************************
	-- verifica se modo de busca é por NUMERO SERIAL
	ELSE IF (@cModo = '1') begin  			-- NUMERO SERIAL
		SELECT	@cIcard   = a.ICARD,
				@cNumSerial  = a.NUMSERIAL
				
			FROM Controle a 
				WHERE a.NumSerial = substring(@cMatric, 3, 10) 
	
		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end


	-- *******************************************************
	-- verifica se modo de busca é por BDCC
	ELSE IF (@cModo = '3') begin  		
		SELECT	@cIcard   = a.ICARD,
				@cBloqBDCC  = c.Bloqueado
				
			FROM bdcc_cracha c 
			INNER JOIN Controle a
				ON c.Cracha = @cMatric and 
				   c.Cracha = a.ICARD  

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end


	-- *******************************************************
	-- verifica se encontrou o usuario, entao coleta informacoes do usuario
	IF (@Result = 1) begin			
		
		-- COLETA faixa horaria do usuario de acordo com o tipo de terminal 
				
		IF (@cTipTerm = '3') begin		  -- TERMINAL TIPO PONTO
			-- colocar 'X' no final de cReg1,cReg2,cReg3 e cReg4 pois o SQL trunca   valores
			-- com campos que contem branco (se o campo for o ultimo a ser concatenado)
			SELECT @cIcard    = a.ICARD,
					   @cReg1 = b.FX_DOM_P + b.FX_SEG_P + b.FX_TER_P + 'X', 
					   @cReg2 = b.FX_QUA_P + b.FX_QUI_P + b.FX_SEX_P + 'X', 
					   @cReg3 = b.FX_SAB_P + b.FX_REF + 'X',
					   --@cReg4 = a.FX_1 + a.FX_2 + a.FX_3 + a.FX_4 + a.FX_5 + a.FX_6 + 'X'
					   @cFx1 = a.FX_1, @cFx2 = a.FX_2, @cFx3 = a.FX_3, @cFx4 = a.FX_4, @cFx5 = a.FX_5, @cFx6 = a.FX_6
					   
			FROM  Controle a
				INNER JOIN  FxHoraria b  
					ON a.ICard = @cMatBusca and b.ICard = a.ICard
		end  			
		
		ELSE begin						-- TERMINAL QUE NAO É PONTO (ACESSO)
			SELECT @cIcard    = a.ICARD,
				   @cReg1 = b.FX_DOM_A + b.FX_SEG_A + b.FX_TER_A + 'X', 
				   @cReg2 = b.FX_QUA_A + b.FX_QUI_A + b.FX_SEX_A + 'X', 
				   @cReg3 = b.FX_SAB_A + b.FX_REF + 'X',
				   --@cReg4 = a.FX_1 + a.FX_2 + a.FX_3 + a.FX_4 + a.FX_5 + a.FX_6 + 'X' 
				   @cFx1 = a.FX_1, @cFx2 = a.FX_2, @cFx3 = a.FX_3, @cFx4 = a.FX_4, @cFx5 = a.FX_5, @cFx6 = a.FX_6
			FROM  Controle a
				INNER JOIN  FxHoraria b  
					ON a.ICard = @cMatBusca and b.ICard = a.ICard
		end

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
		end

		-- *******************************************************
		-- COLETA outros dados do usuario
		ELSE begin
			SELECT	@cIcard   = a.ICARD,
					@cGrupo   = a.GRUPO,
					@cCodig   = a.CODIG,
					@cTpFis   = a.TPFIS, 
					@cSitua   = a.SITUA,
					@cSubNv   = a.SUBNV,
					@cPlanta  = a.PLANTA,
					@cDataHora = a.DATAHORA,
					@cUltrs    = a.ULTRS,
					@cDatIni   = a.DATINI,
					@cDatFim   = a.DATFIM,
					@cTitular  = a.TITULAR,
					@cFx_Flg   = a.FX_FLG,
					@cFx_Dta   = a.FX_DTA,
					@cFx_Alm   = a.TEMPO_ALM,
					@cMensagem = a.MENSAGEM,
					@cDta_mens = a.DTA_MENS, 
					@cQtd_mens = a.QTD_MENS,
					@cCred_Fx1 = a.CRED_FX1,
					@cCred_Fx2 = a.CRED_FX2,
					@cCred_Fx3 = a.CRED_FX3,
					@cCred_Fx4 = a.CRED_FX4,
					@cCred_Fx5 = a.CRED_FX5,
					@cCred_Fx6 = a.CRED_FX6,
					@cUltPasR  = a.ULTPAS_REF,
					@cGrupo1   = a.GRUPO1,
					@cDatIniG1 = a.DATINIG1,
					@cDatFimG1 = a.DATFIMG1,
					@cGrupo2   = a.GRUPO2,
					@cDatIniG2 = a.DATINIG2,
					@cDatFimG2 = a.DATFIMG2,
					@cGrupo3   = a.GRUPO3,
					@cDatIniG3 = a.DATINIG3,
					@cDatFimG3 = a.DATFIMG3,
					@cGpoSab   = a.GRUPO_SAB,
					@cGpoDom   = a.GRUPO_DOM,
					@cGpoFer   = a.GRUPO_FER,
					@cAnti_D   = a.ANTI_DUPLA,
					@cBloq     = a.BLOQ_FALTA,
					@cVHora    = a.VER_HORA,
					@cVLocal   = a.VER_LOCAL,
					@cVValid   = a.VER_VALID,
					@cVAfast   = a.VER_AFAST,
					@cVCred    = a.VER_CRED,
					@cVisEsp   = a.VIS_ESP,
					@cVDigit   = a.VER_DIGIT,

					@cTpoIntj = a.TEMPO_RET,				
					@cTolIntj = a.TOLER_RET,
					@cInterj  = a.VER_RET,

					@cTpoJorn  = a.TEMPO_JORNADA, 
					@cSaidaMax = a.VER_SAIDAMAX,
					@cVnDias   = a.VER_NDIAS,
					@cPne      = a.PNE,
					@cBloqRev  = a.BLOQREV,
					@cvViaRep  = a.VER_VIAREP

				FROM Controle a
					WHERE  a.icard = @cMatBusca

			IF (@@ROWCOUNT = 0) begin
				set @cIcard = '000000000000'	-- 12 zeros
				SET @RetFun = -2
			end

			-- *******************************************************
			-- locka usuario se necessario
			ELSE begin
				IF (@cSitua = '4') or (@cFazLock = '0') begin 	-- se Provisorio, não 'bloqueia'. Sera 'bloqueado' o Titular
					set @ret = 0
				end
				ELSE begin
					SET @stmt1 = 'execute @p1 = ' + @cOwner + '.request_lock @cMat, @cUsu'
					SET @ParmDefinition = N'@cMat nvarchar(30), @cUsu CHAR(15), @p1 int OUTPUT ';		
					EXEC sp_executesql @stmt1, 
									@ParmDefinition, 
									@cMat = @cMatric, 
									@cUsu = @cEndIp,
									@p1 = @ret OUTPUT		
				end		
	
				-- *******************************************************
				-- verifica se dados são nulos para preencher com valores default
				IF (@ret = 0) begin
					SET @cFxDiaEsp = SPACE(28);
					SET @cFxCred   = SPACE(4);
					-- Armazena dados da matricula em Registro
					-- colocar 'X' no final de cReg1, cReg2 e cReg3 pois o SQL trunca            -- valores com campos que contem branco (se o campo for o ultimo a ser       -- concatenado)
					if (@cCodig is Null) 
						SET @cCodig = SPACE(6);
					if (@cTpFis is Null) 
						SET @cTpFis = SPACE(1);
					if (@cSubNv is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cSubNv = '00'+SPACE(3);	-- 3 espacos
						ELSE
							SET @cSubNv = '00'+SPACE(5);	-- 5 espacos
					END
						
					if (@cPlanta is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cPlanta = '000';		--3
						ELSE
							SET @cPlanta = '00000';		-- 5 
					END

					if (@cDataHora is Null) 
						SET @cDataHora = '3112202359';
					if (@cUltrs is Null) 
						SET @cUltrs = '0101902359'+SPACE(10);
					if (@cFx_Flg is Null)  
						SET @cFx_Flg = '0';		-- 1 
					if (@cFx_Dta is Null)  
						SET @cFx_Dta = SPACE(11);
					if (@cFx_Alm is Null)  
						SET @cFx_Alm = SPACE(3);
					if (@cDatIni is Null) 
						SET @cDatIni = SPACE(6);
					if (@cDatFim is Null) 
						SET @cDatFim = SPACE(6);
					if (@cTitular is Null) 
						SET @cTitular = SPACE(12);
					if (@cMensagem is Null)  
						SET @cMensagem = SPACE(32);
					if (@cDta_mens is Null)  
						SET @cDta_mens = SPACE(6);
					if (@cQtd_mens is Null)  
						SET @cQtd_mens = SPACE(2);
					if (@cCred_Fx1 is Null)  
						SET @cCred_Fx1 = '00';		-- 2
					if (@cCred_Fx2 is Null)  
						SET @cCred_Fx2 = '00';		-- 2
					if (@cCred_Fx3 is Null)  
						SET @cCred_Fx3 = '00';		-- 2
					if (@cCred_Fx4 is Null)  
						SET @cCred_Fx4 = '00';		-- 2
					if (@cCred_Fx5 is Null)  
						SET @cCred_Fx5 = '00';		-- 2
					if (@cCred_Fx6 is Null)  
						SET @cCred_Fx6 = '00';		-- 2
					if (@cUltPasR is Null)  
						SET @cUltPasR = SPACE(10);

					if (@cGrupo1 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo1 = '000';	-- 3 
						ELSE
							SET @cGrupo1 = '00000'	-- 5 
					END
					if (@cDatIniG1 is Null) 
						SET @cDatIniG1 = SPACE(10);
					if (@cDatFimG1 is Null) 
						SET @cDatFimG1 = SPACE(10);

					if (@cGrupo2 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo2 = '000';	-- 3 
						ELSE
							SET @cGrupo2 = '00000'	-- 5 
					END
					if (@cDatIniG2 is Null) 
						SET @cDatIniG2 = SPACE(10);
					if (@cDatFimG2 is Null) 
						SET @cDatFimG2 = SPACE(10);
					
					if (@cGrupo3 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo3 = '000';	-- 3 
						ELSE
							SET @cGrupo3 = '00000'	-- 5 
					END
					if (@cDatIniG3 is Null) 
						SET @cDatIniG3 = SPACE(10);
					if (@cDatFimG3 is Null) 
						SET @cDatFimG3 = SPACE(10);

					if (@cGpoSab is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoSab = '000';	-- 3 
						ELSE
							SET @cGpoSab = '00000'	-- 5 
					END

					if (@cGpoDom is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoDom = '000';	-- 3 
						ELSE
							SET @cGpoDom = '00000'	-- 5 
					END

					if (@cGpoFer is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoFer = '000';	-- 3 
						ELSE
							SET @cGpoFer = '00000'	-- 5 
					END

					if (@cVisEsp is Null) 
						SET @cVisEsp = '0';		-- 1
					if (@cVDigit is Null) 
						SET @cVDigit = '2';		-- 1
					if (@cTpoIntj is Null) 
						SET @cTpoIntj = '000';		-- 3
					if (@cTolIntj is Null)
						SET @cTolIntj = '000';		-- 3
					if (@cInterj is Null)
						SET @cInterj = '0';		-- 1 
					if (@cTpoJorn is Null)
						SET @cTpoJorn = '000';		-- 3
					if (@cSaidaMax is Null)
						SET @cSaidaMax = '0';		-- 1 
					if (@cTipoDoc is Null)
						SET @cTipoDoc = '2';		-- 1 

					if (@cVnDias is Null) 
						SET @cVnDias = '00';		-- 2

					if (@cPne is Null)
						SET @cPne = '0';		-- 1 
					if (@cBloqRev is Null)
						SET @cBloqRev = '0';		-- 1 
					if (@cvViaRep is Null)
						SET @cvViaRep = '0';		-- 1 

					if (@cFx1 is Null)
						SET @cFx1 = '24002400';		-- 8 
					if (@cFx2 is Null)
						SET @cFx2 = '24002400';		-- 8 
					if (@cFx3 is Null)
						SET @cFx3 = '24002400';		-- 8 
					if (@cFx4 is Null)
						SET @cFx4 = '24002400';		-- 8 
					if (@cFx5 is Null)
						SET @cFx5 = '24002400';		-- 8 
					if (@cFx6 is Null)
						SET @cFx6 = '24002400';		-- 8 


					IF (@nTamG = 3) 
						SELECT @cAdBuf = SPACE(2);		-- 2 espços
					ELSE
						SELECT @cAdBuf = null


					SET @cReg4 = @cFx1 + @cFx2 + @cFx3 + @cFx4 + @cFx5 + @cFx6 + 'X'
					
					SET @cReg5 = @cIcard + @cGrupo + 
								 @cCodig + @cTpFis + @cSitua + @cSubNv + 
								 @cPlanta + 
								 'X'
					
					/*
					SET @cReg5 = @cIcard + @cGrupo + COALESCE(@cAdBuf, '') + 
								 @cCodig + @cTpFis + @cSitua + @cSubNv + COALESCE(@cAdBuf, '') + 
								 @cPlanta + COALESCE(@cAdBuf, '') + 'X'
					*/
					

					SET @cReg6 = substring(@cDataHora,1,10) + @cUltrs + @cFx_Flg + @cFx_Dta + @cFx_Alm + 
								 @cFxDiaEsp + @cDatIni + @cDatFim + @cMensagem + @cDta_mens + @cQtd_mens  + 
								 @cCred_Fx1 + @cFxCred +
								 @cCred_Fx2 + @cFxCred +
								 @cCred_Fx3 + @cFxCred +
								 @cCred_Fx4 + @cFxCred +
								 @cCred_Fx5 + @cFxCred +
								 @cCred_Fx6 + @cFxCred +
								 @cUltPasR + @cTitular  + 'X'
								 
					SET @cReg7 = @cGrupo1 + @cDatIniG1 + @cDatFimG1 +
								 @cGrupo2 + @cDatIniG2 + @cDatFimG2 +
								 @cGrupo3 + @cDatIniG3 + @cDatFimG3 +
								 @cGpoSab + 
								 @cGpoDom + 
								 @cGpoFer + 
								 @cAnti_D + @cBloq + @cVHora + @cVLocal +
								 @cVValid + @cVAfast + @cVCred + @cVisEsp + 'X'


					/*
					SET @cReg7 = @cGrupo1 + COALESCE(@cAdBuf, '') + @cDatIniG1 + @cDatFimG1 +
								 @cGrupo2 + COALESCE(@cAdBuf, '') + @cDatIniG2 + @cDatFimG2 +
								 @cGrupo3 + COALESCE(@cAdBuf, '') + @cDatIniG3 + @cDatFimG3 +
								 @cGpoSab + COALESCE(@cAdBuf, '') + 
								 @cGpoDom + COALESCE(@cAdBuf, '') + 
								 @cGpoFer + COALESCE(@cAdBuf, '') + 
								 @cAnti_D + @cBloq + @cVHora + @cVLocal +
								 @cVValid + @cVAfast + @cVCred + @cVisEsp + 'X'
					*/					


					IF (@cDesbloqRev = '1')  
						SET @cBloqRev = '0'
					

					--SET @cReg8 = @cIcard + '0' + '0' + @cVDigit + 
					SET @cReg8 = @cIcard + @cvViaRep + '0' + @cVDigit + 
								 @cTpoIntj + @cTolIntj + @cInterj + 
								 @cTpoJorn + @cSaidaMax + 
								 @cTipoDoc + '00' + @cVnDias + 
								 --@cPne + @cBloqRev + 'X'
								 @cPne + @cBloqRev
				end
				-- matricula ja lockada
				ELSE
					SET @RetFun = -3
			end
		end
	END

	SET DATEFORMAT dmy
	SELECT @cIniHalmAux = CONVERT(char(8), a.Ini_Halm, 3)+ CONVERT(char(8), a.Ini_Halm, 8),
		   @cFimHalmAux = CONVERT(char(8), a.Fim_Halm, 3)+ CONVERT(char(8), a.Fim_Halm, 8),
		   @cIniIntjAux = CONVERT(char(8), a.Ini_Intj, 3)+ CONVERT(char(8), a.Ini_Intj, 8),
		   @cFimIntjAux = CONVERT(char(8), a.Fim_Intj, 3)+ CONVERT(char(8), a.Fim_Intj, 8),
		   @cFimAntDAux = CONVERT(char(8), a.Fim_AntiD, 3)+ CONVERT(char(8), a.Fim_AntiD, 8) ,
		   @cDiasSuc = a.Dias_Suc   
		   
	FROM DATAHORA a 
	WHERE a.ICARD = @cMatBusca
	
	IF (@@ROWCOUNT = 0) begin
  		SET @cIniHalm = '010106000000'	-- 01/01/06
		SET @cFimHalm = '010106000000'	-- 01/01/06
		SET @cIniIntj = '010106000000'	-- 01/01/06
		SET @cFimIntj = '010106000000'	-- 01/01/06
		SET @cFimAntD = '010106000000'	-- 01/01/06
		SET @cDiasSuc = '00';
	end
	ELSE begin
		SET @cIniHalm = substring (@cIniHalmAux,1,2)+substring (@cIniHalmAux, 4,2)+substring (@cIniHalmAux, 7,2)+
						substring (@cIniHalmAux,9,2)+substring (@cIniHalmAux,12,2)+substring (@cIniHalmAux,15,2)
		SET @cFimHalm = substring (@cFimHalmAux,1,2)+substring (@cFimHalmAux, 4,2)+substring (@cFimHalmAux, 7,2)+
						substring (@cFimHalmAux,9,2)+substring (@cFimHalmAux,12,2)+substring (@cFimHalmAux,15,2)
		SET @cIniIntj = substring (@cIniIntjAux,1,2)+substring (@cIniIntjAux, 4,2)+substring (@cIniIntjAux, 7,2)+
						substring (@cIniIntjAux,9,2)+substring (@cIniIntjAux,12,2)+substring (@cIniIntjAux,15,2)
		SET @cFimIntj = substring (@cFimIntjAux,1,2)+substring (@cFimIntjAux, 4,2)+substring (@cFimIntjAux, 7,2)+
						substring (@cFimIntjAux,9,2)+substring (@cFimIntjAux,12,2)+substring (@cFimIntjAux,15,2)
		SET @cFimAntD = substring (@cFimAntDAux,1,2)+substring (@cFimAntDAux, 4,2)+substring (@cFimAntDAux, 7,2)+
						substring (@cFimAntDAux,9,2)+substring (@cFimAntDAux,12,2)+substring (@cFimAntDAux,15,2)
	END
	
	SET @cReg9 = @cIcard + @cIniHalm + @cFimHalm + @cIniIntj + @cFimIntj + @cFimAntD + @cDiasSuc + 'X';

	--SET @cReg10 = @cBloqBDCC + 'X';
	SET @cReg10 = @cBloqBDCC;

	-- *******************************************************
	-- atualiza tab.CONTROLE se o usuario foi liberado pelo equipamento para revista
	IF (@RetFun = 0 AND 
		@Result = 1 AND 
		@cDesbloqRev = '1') begin
			IF (@cFazLock = '0') begin				-- marcacao offline
				SET @pos = CHARINDEX(' ', @cUltrs);  	-- VERIFICA SE data armazenada em BD tem valor em branco

				IF (@pos <= 10) and (@pos > 0) 
					SET @dDataBD = @dDataOcor;		-- assume temporariamente a mesma data de ocorrencia para que haja tualização
				ELSE begin
					set DATEFORMAT dmy
					SET @dDataBD = CAST((substring(@cUltrs,1,2)+'-'+substring(@cUltrs,3,2)+'-'+substring(@cUltrs,5,2)+' '+
							 			 substring(@cUltrs,7,2)+':'+substring(@cUltrs,9,2)+':'+'00') AS datetime);					
				end
				
				IF (@dDataOcor >= @dDataBD) 			-- atualiza BD porque a marcacao offline é mais recente que está em BD
					UPDATE CONTROLE SET BLOQREV = '0' WHERE ICARD = @cMatBusca;
			end
			ELSE
				UPDATE CONTROLE SET BLOQREV = '0' 
					WHERE ICARD = @cMatBusca
	end		
				
	
	-- *******************************************************
	-- verifica grupo do Estacionamento / AREA controlada por vaga
	SET @nGrEstFixa = 0;
	SET @nGrestEquip = 0;
	SET @cEmFixa = '0';
	SET @cRegra = '0';
	
	SELECT @nGrestEquip = convert(int, GREST)  			-- VERIFICA SE O EQUIPAMENTO PERTENCE A ALGUM ESTACIONAMENTO / AREA CONTROLADA
		FROM ESTAC001 
		WHERE END_IP = @cEndIp;
	
	IF (@@ROWCOUNT = 0) begin
		SET @nGrEstFixa = 0;
		SET @nGrestEquip = 0;
	end			
	ELSE begin
		SELECT @nGrEstFixa = convert(int, GREST),
			   @cEmFixa = EMFIXA   					-- VERIFICA SE A MATRICULA POSSUI VAGA FIXA NESTE ESTACIONAMENTO
			FROM ESTAC003 
			WHERE ICARD = @cMatBusca AND convert(int, GREST) = convert(int, @nGrestEquip);
			
		IF (@@ROWCOUNT = 0)	begin 		
			SET @nGrEstFixa = 0;
			SET @cEmFixa = '0';
		END
	END;

	-- verifica numero da regra, se equipamento pertencer a área de vagas
	IF (@nGrestEquip != 0) begin
		SELECT @cRegra = REGRA 
			FROM ESTAC002 
			WHERE convert(int, GREST) = convert(int, @nGrestEquip);
	
		IF (@@ROWCOUNT = 0) begin
			SET @cRegra = '0';
		end
	END 

	SET @AuxGr2 = convert(char, @nGrEstFixa);
	SET @AuxGr = REPLICATE('0',6-LEN(@AuxGr2) ) + @AuxGr2;
	SET @cReg8 = @cReg8 + @AuxGr;								-- grupo de estacionamento do qual o usuario tem vaga fixa
	SET @cReg8 = @cReg8 + @cEmFixa + 'X';						-- indicador se estacionou em vaga fixa

	SET @AuxGr2 = convert(char, @nGrestEquip);
	SET @AuxGr = REPLICATE('0',6-LEN(@AuxGr2) ) + @AuxGr2;			-- grupo de estacionamento ao qual o equipamento faz parte
	SET @cReg10 = @cReg10 + @AuxGr 				-- posic 1 a 6(numero da area de controle)
	SET @cReg10 = @cReg10 + @cRegra + 'X'		-- posic 7 (numero da regra)		


	-- *******************************************************
	-- verifica Area de ESCOLTA
	SET @cTemEsc = '0'

	IF (@cEhEscolta = '0')		-- não é a escolta
	BEGIN
		SET @cProcurado = @cMatBusca
		SET @nContArea = 0
		SET @cFinalSentido = '0'
		
		SET @cEscoltado = @cMatBusca
		SET @cEscolta = '000000000000'
		SET @cTemEsc = '0'
		SET @cSentido = '0'
	
		
		DECLARE escolt_cur CURSOR FOR
			SELECT AREA, SENTIDO FROM ESCOLT002 
				WHERE END_IP = @cEndIp
				ORDER by AREA;

		OPEN escolt_cur
		FETCH next from escolt_cur into @nAuxArea, @AuxSentido
		WHILE (@@fetch_status != -1)
		BEGIN
			SET @nContArea = @nContArea + 1
		
			-- localiza a AREA e MATRICULA NA TABELA DE PESSOAS A SEREM ESCOLTADAS
			IF EXISTS (
				SELECT ICARD_ESCOLTADO, AREA 
					FROM ESCOLT001 
					WHERE ICARD_ESCOLTADO = @cProcurado AND
						  AREA = @nAuxArea)

			BEGIN
				SET @cFinalSentido = 
				CASE 
					WHEN @cFinalSentido = '0' 
						THEN ( @AuxSentido)
					WHEN @cFinalSentido = '1' AND (@AuxSentido = '2' OR  @AuxSentido = '3') 
						THEN '3'
					WHEN @cFinalSentido = '2' AND (@AuxSentido = '1' OR  @AuxSentido = '3')
						THEN '3'
						ELSE @cFinalSentido
				END
					
				SET @cTemEsc = '1'
				SET @cSentido = @cFinalSentido
			END
			
			FETCH next from escolt_cur into @nAuxArea, @AuxSentido
		END
		
		CLOSE escolt_cur
		DEAllocate escolt_cur
	END


	-- É A ESCOLTA
	ELSE BEGIN
	
		SET @nContArea = 0
		SET @cEscoltado = @cVisita
		SET @cEscolta = '000000000000'
		SET @cTemEsc = '0'
		SET @cSentido = '0'
	
		DECLARE escolt_cur CURSOR FOR
			SELECT AREA FROM ESCOLT002 
				WHERE END_IP = @cEndIp
				ORDER by AREA;

	
		OPEN escolt_cur
		FETCH next from escolt_cur into @nAuxArea
		WHILE (@@fetch_status != -1)
		BEGIN
			SET @nContArea = @nContArea + 1
		
			-- VERIFICA SE A MATRICULA É AUTORIZADA A SER  ESCOLTA 

			IF EXISTS (
				SELECT ICARD_ESCOLTADO, AREA 
					FROM ESCOLT001 
					WHERE ICARD_ESCOLTADO = @cVisita AND
					   	  ICARD_GUARDA = @cMatBusca AND 
					      AREA = @nAuxArea)
			BEGIN
				SET @cEscoltado = @cVisita;
				SET @cEscolta = @cMatBusca;
				SET @cTemEsc = '0'	
				--SET @@fetch_status  = -1
				BREAK
			END
			ELSE
				FETCH next from escolt_cur into @nAuxArea
		END
		CLOSE escolt_cur
		DEAllocate escolt_cur
	END

	
	SET @cReg11 = @cEscoltado + @cEscolta + @cTemEsc + @cSentido + 'X';

	


	SET LOCK_TIMEOUT -1		
	
	SELECT @RetFun, 
		@cReg1, 
		@cReg2, 
		@cReg3, 
		@cReg4, 
		@cReg5, 
		@cReg6, 
		@cReg7, 
		@cReg8, 
		@cReg9,
		@cReg10,
		@cReg11,
		@nTamG		
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlConsVagas_Estac2')
	DROP PROCEDURE TELESSVR.sqlConsVagas_Estac2;
GO

CREATE PROCEDURE TELESSVR.sqlConsVagas_Estac2 @cGrEstac char(6)
AS

DECLARE @Ret int, @nVagasFixasLivres INT, @nVagasRotatLivres INT, @cSoFixa char(1), @cRegra char(1)
DECLARE @nMaxFixo INT, @nContFixo INT, @nMaxRot INT, @nContRot INT, @nVal INT


    SET @Ret = 0;
    SET @nVagasFixasLivres = 0;
    SET @nVagasRotatLivres = 0;
    SET @cSoFixa = '0';
    SET @cRegra = '0';
    

	-- PROCURA PELO GRUPO DE ESTACIONAMENTO PARA COLETAR AS QUANTIDADES VAGAS
	SELECT @nMaxFixo = MAX_FIXO, @nContFixo = CONT_FIXO, @nMaxRot = MAX_ROT, @nContRot = CONT_ROT, 
			@cSoFixa = SOFIXO, @cRegra = REGRA  
		FROM ESTAC002 WHERE CONVERT(INT, GREST) = CONVERT(INT, @cGrEstac)

	IF (@@ROWCOUNT <> 0) begin 
		IF (@cRegra = '1') begin 		-- REGRA DE ESTACIONAMENTO (FIXOS E ROTATIVOS)
			SET @nVagasFixasLivres = (@nMaxFixo - @nContFixo);
			SET @nVagasRotatLivres = (@nMaxRot - @nContRot);
	
			IF (@nVagasFixasLivres < 0) 
				SET @nVagasFixasLivres = 0; 
			IF (@nVagasRotatLivres < 0) 
				SET @nVagasRotatLivres = 0; 
			SET @Ret = 1;
		END
		
		ELSE IF (@cRegra = '2') begin 		-- REGRA DE REFEITÓRIO (COMUM E VIP)
			SET @nVal = (@nMaxRot - @nContRot);
			IF (@nVal > 0) 	begin
				SET @nVagasRotatLivres = @nVal;
				SET @nVagasFixasLivres = @nMaxFixo;
			end
			ELSE begin
				SET @nVagasRotatLivres = 0;
				IF ((@nMaxFixo + @nMaxRot) > @nContRot)
					SET @nVagasFixasLivres = (@nMaxFixo + @nVal);
				ELSE
					SET @nVagasFixasLivres = 0;
			end
		END
		SET @Ret = 1;
	END
		
	SELECT @Ret, @nVagasFixasLivres, @nVagasRotatLivres, @cSoFixa;
		
	GO
			

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = 'sqlAtuVagas_Estac2')
	DROP PROCEDURE TELESSVR.sqlAtuVagas_Estac2;
GO

CREATE PROCEDURE TELESSVR.sqlAtuVagas_Estac2 @cMatric char(12), @cGrEstac char(6), @cTipoVaga char(1), @nModoAlt INT, @cRegra char(1)
AS
DECLARE @Ret int, @nMaxFix int, @nMaxRot int, @nOcupFix int, @nOcupRot int, @nOcupados int, @nMaxVagas int
DECLARE @grAux VARCHAR(8), @cFlag char(1);

	SET @Ret = 1;
	
    -- REGRA 1 : ESTACIONAMENTO ROTATIVO / FIXO
	-- USUARIO se cadastrado com vaga fixa: 
	--	 se houver vaga em area fixa, entra e estaciona em vaga fixa. Incrementa contador de vaga fixa. atualiza que entrou em estacionamento via area fixa
	--   se não houver vaga em area fixa e se houver vaga em rotativo, entra e estaciona em vaga rotativa. Incrementa contador de vaga rotativa. atualiza que entrou em estacionamento usando vaga rotativa
	-- USUARIO NAO cadastrado com vaga fixa:
	--	 só pode entrar em estacionamento se houver vaga rotativa disponivel

	IF (@cRegra = '1')	begin
	
		SELECT @grAux = GREST 
			FROM ESTAC003 
			WHERE ICARD = @cMatric and 
				  convert(INT, GREST) = convert(INT, @cGrEstac);
			
		IF (@@ROWCOUNT <> 0) begin 

			-- verifica se tipo de vaga é Fixa e é Entrada		
			IF (@cTipoVaga = 'F') and (@nModoAlt > 0) 
				SET @cFlag = '1';								-- para informar que houve ocupacao da vaga fixa
			ELSE
				SET @cFlag = '0';								-- para informar que não houve ocupação da vaga fixa

			UPDATE ESTAC003 SET EMFIXA = @cFlag 
				WHERE ICARD = @cMatric and 
				  	  convert(INT, GREST) = convert(INT, @cGrEstac);
		END


		-- Procura pelo Grupo de Estacionamento para atualizar quantidade de vagas
		SELECT @nMaxFix = MAX_FIXO, 
			   @nOcupFix = CONT_FIXO, 
			   @nMaxRot =  MAX_ROT, 
			   @nOcupRot = CONT_ROT 
			FROM ESTAC002 WHERE convert(INT, GREST) = convert(INT, @cGrEstac);

		IF (@@ROWCOUNT <> 0) begin 
			IF (@cTipoVaga = 'F') begin
				SET @nOcupados = @nOcupFix;					
				SET @nMaxVagas = @nMaxFix;
			end
			ELSE begin
				SET @nOcupados = @nOcupRot;
				SET @nMaxVagas = @nMaxRot;
			end

			-- nOcupados será incrementado ou decrementado dependendo do valor de nModoAlt (que pode ser:-1, 0, 1)	
			SET @nOcupados = @nOcupados + @nModoAlt;

			-- nao deixa qtde vagas ocupadas ficar negativo
			if (@nOcupados < 0) 
				SET @nOcupados = 0;

			-- nao deixa qtde vagas ocupadas ficar maior que o permitido
			IF (@nOcupados > @nMaxVagas)
				SET @nOcupados = @nMaxVagas;

			-- atualiza contador
			IF (@nModoAlt != 0) begin
				IF (@cTipoVaga = 'F') 
					UPDATE ESTAC002 SET CONT_FIXO = @nOcupados WHERE convert(INT, GREST) = convert(INT, @cGrEstac);
				ELSE
					UPDATE ESTAC002 SET CONT_ROT = @nOcupados WHERE convert(INT, GREST) = convert(INT, @cGrEstac);
			end
		end
		ELSE
			SET @Ret = 0;
	end
	
    -- REGRA 2 : VAGAS REFEITORIO COMUM/VIP
	-- USUARIO se cadastrado com vaga Vip: 
	--	 se houver vaga em area Comum, entra . Incrementa contador de vagas Ocupadas. 
	--	 se nao houver vaga em area Comum mas tem vaga em área Vip, entra . Incrementa contador de vagas Ocupadas. 
	--	 se nao houver vaga em area Comum e não tem vaga em área Vip, é bloqueado. 
	-- USUARIO NÃO cadastrado com vaga Vip: 
	--	 se houver vaga em area Comum, entra . Incrementa contador de vagas Ocupadas. 
	--	 se nao houver vaga em area Comum mas tem vaga em área Vip, é bloqueado. 
	--	 se nao houver vaga em area Comum e não tem vaga em área Vip, é bloqueado. 
	
	ELSE begin 
		IF (@cRegra = '2')	begin
			SET @nOcupados = 0;
			IF (@nModoAlt != 0) begin
				-- Procura pelo Grupo de Estacionamento para atualizar quantidade de vagas
				SELECT @nMaxFix = MAX_FIXO, 
					   @nMaxRot = MAX_ROT, 
					   @nOcupados = CONT_ROT 
				FROM ESTAC002 
				WHERE convert(INT, GREST) = convert(INT, @cGrEstac);

				IF (@@ROWCOUNT <> 0) begin 
				
					-- nOcupados será incrementado ou decrementado dependendo do valor de nModoAlt (que pode ser:-1, 0, 1)	
					SET @nOcupados = @nOcupados + @nModoAlt;

					-- nao deixa qtde vagas ocupadas ficar negativo
					if (@nOcupados < 0) 
						SET @nOcupados = 0;

					-- nao deixa qtde vagas ocupadas ficar maior que o permitido
					-- TIREI. ACHO Q DEVE SER COLOCADO A QTDE Q TEM NA AREA, MESMO QUE TENHA ULTRAPASSADO DO MÁXIMO PERMITIDO
	--				IF (@nOcupados > (@nMaxFix + @nMaxRot)) 
	--					SET @nOcupados = (@nMaxFix + @nMaxRot);

					UPDATE ESTAC002 SET CONT_ROT = @nOcupados 
						WHERE convert(INT, GREST) = convert(INT, @cGrEstac)
				end
				ELSE
					SET @Ret = 0;			
			END
		END;
	END 

	select @Ret ;
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

-----------------------------------------------------------------------------
-- CONEX REP V.08.00.03 || CONEX REP V.08.00.03 || CONEX REP V.08.00.03 || --
-----------------------------------------------------------------------------

-- OBS: HOUVE ALTERACAO SOMENTE NA APLICACAO DO CONEX

----------------------------------------------------------------------------------
-- 2.10.11.1 || 2.10.11.1 || 2.10.11.1 || 2.10.11.1 || 2.10.11.1 || 2.10.11.1 || --
-----------------------------------------------------------------------------------

-----------------------------------------------------------------------------------
-- CONEX ACESSO V.40.01.05 || CONEX ACESSO V.40.01.05 || CONEX ACESSO V.40.01.05 ||
-----------------------------------------------------------------------------------

-- OBS: HOUVE ALTERACAO SOMENTE NA APLICACAO DO CONEX

-----------------------------------------------------------------------------
-- CONEX REP V.08.00.05 || CONEX REP V.08.00.05 || CONEX REP V.08.00.05 || --
-----------------------------------------------------------------------------

if object_id('TELESSVR.sqlprephist_RStF', 'p') is null
    exec ('create procedure TELESSVR.sqlprephist_RStF as select 1')
go

ALTER PROCEDURE TELESSVR.sqlprephist_RStF @LMat1 VARCHAR(255), @LMat2 VARCHAR(255), @LMat3 VARCHAR(255), @LMat4 VARCHAR(255), @cEndIp CHAR(15), @cModo CHAR(1)
AS

DECLARE @Ret smallint , @Tam INT, @Pos INT, @cAcao CHAR(1), @cMat CHAR(12)

	SET @Ret = 0
	
		
	-- analise de LMat1
	SET @Tam = len(@LMat1) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin

			SET @cMat = SUBSTRING (@LMat1, @Pos, 12);
			UPDATE REPAUXEMPR SET ST = '1' 
				WHERE END_IP = @cEndIp AND 
					  TIPO = @cModo AND 
					  IFUNC = @cMat
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat2
	SET @Tam = len(@LMat2) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin

			SET @cMat = SUBSTRING (@LMat2, @Pos, 12);
			UPDATE REPAUXEMPR SET ST = '1' 
				WHERE END_IP = @cEndIp AND 
					  TIPO = @cModo AND 
					  IFUNC = @cMat
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat3
	SET @Tam = len(@LMat3) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin

			SET @cMat = SUBSTRING (@LMat3, @Pos, 12);
			UPDATE REPAUXEMPR SET ST = '1' 
				WHERE END_IP = @cEndIp AND 
					  TIPO = @cModo AND 
					  IFUNC = @cMat
			SET @Pos = @Pos + 12;
		end
	END;

	-- analise de LMat4
	SET @Tam = len(@LMat4) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin
	
			SET @cMat = SUBSTRING (@LMat4, @Pos, 12);
			UPDATE REPAUXEMPR SET ST = '1' 
				WHERE END_IP = @cEndIp AND 
					  TIPO = @cModo AND 
					  IFUNC = @cMat
			SET @Pos = @Pos + 12;
		end
	END;


	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqlproc_PisNome2', 'p') is null
    exec ('create procedure TELESSVR.sqlproc_PisNome2 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlproc_PisNome2 @cEndIp CHAR(15), @nMax int, @cUltPis CHAR(12), @cTipoCarga CHAR(1)
AS
DECLARE @nCont int, @nTotal int, @nBloco int
DECLARE @cPis CHAR(12), @cNome VARCHAR(52)
DECLARE @cLisPis VARCHAR(70), @cLisPis_1 VARCHAR(70), @cLisPis_2 VARCHAR(70), @cLisPis_3 VARCHAR(70), @cLisPis_4 VARCHAR(70)    
DECLARE @cLisNome VARCHAR(250), @cLisNome_1 VARCHAR(250), @cLisNome_2 VARCHAR(250), @cLisNome_3 VARCHAR(250), @cLisNome_4 VARCHAR(250) 

	SET LOCK_TIMEOUT 5000

	SET @nCont = 0
	SET @nTotal = 0
	SET @nBloco = 1

	SET @cLisPis = ''
	SET @cLisNome = ''

	SET @cLisPis_1 = ''
	SET @cLisNome_1 = ''

	SET @cLisPis_2 = ''
	SET @cLisNome_2 = ''

	SET @cLisPis_3 = ''
	SET @cLisNome_3 = ''

	SET @cLisPis_4 = ''
	SET @cLisNome_4 = ''


	-- cursor para PIX X NOME 
	--DECLARE cur_PisNome CURSOR FOR select  PIS, NOME from REPAUXEMPR WHERE END_IP = @cEndIp AND TIPO = @cTipoCarga AND PIS > @cUltPis order by PIS  
	DECLARE cur_PisNome CURSOR FOR select  DISTINCT PIS, NOME from REPAUXEMPR WHERE END_IP = @cEndIp AND TIPO = @cTipoCarga AND PIS > @cUltPis order by PIS  

	OPEN cur_PisNome
	FETCH NEXT FROM cur_PisNome INTO @cPis, @cNome
	WHILE (@@fetch_status != -1) and (@nTotal < @nMax) 
	begin

		SET @cLisPis  = @cLisPis + @cPis
		SET @cLisNome = @cLisNome + @cNome + ';'
		
		SET @nCont  = @nCont + 1
		set @nTotal = @nTotal + 1
		
		if (@nCont >= 4) begin		-- cabem somente 4 *(52+1) em variavel de 250
			if (@nBloco = 1) begin
				set @cLisPis_1 = @cLisPis
				set @cLisNome_1 = @cLisNome
			end
			else if (@nBloco = 2) begin
				set @cLisPis_2 = @cLisPis
				set @cLisNome_2 = @cLisNome
			end
			else if (@nBloco = 3) begin
				set @cLisPis_3 = @cLisPis
				set @cLisNome_3 = @cLisNome
			end
			else if (@nBloco = 4) begin
				set @cLisPis_4 = @cLisPis
				set @cLisNome_4 = @cLisNome
			end
			set @cLisPis = ''
			set @cLisNome = ''
			set @nBloco = @nBloco+1
			set @nCont = 0
			
		end
		FETCH NEXT FROM cur_PisNome INTO @cPis, @cNome
	end
	CLOSE cur_PisNome
	DEALLOCATE cur_PisNome

	-- "SOBRAS" da lista 
	IF ((@nCont > 0) and (@nCont < 4)) begin
		if (@nBloco = 1) begin
			set @cLisPis_1 = @cLisPis
			set @cLisNome_1 = @cLisNome
		end
		else if (@nBloco = 2) begin
			set @cLisPis_2 = @cLisPis
			set @cLisNome_2 = @cLisNome
		end
		else if (@nBloco = 3) begin
			set @cLisPis_3 = @cLisPis
			set @cLisNome_3 = @cLisNome
		end
		else if (@nBloco = 4) begin
			set @cLisPis_4 = @cLisPis
			set @cLisNome_4 = @cLisNome
		end	
	end
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal,
		@cLisPis_1, @cLisNome_1, 
		@cLisPis_2, @cLisNome_2, 
		@cLisPis_3, @cLisNome_3, 
		@cLisPis_4, @cLisNome_4 

	GO
			

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqlproc_icardpis3', 'p') is null
    exec ('create procedure TELESSVR.sqlproc_icardpis3 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlproc_icardpis3 @cEndIp CHAR(15), @cNumRep CHAR(17), @nTotal int, @cInicio CHAR(1), @cTipoCom CHAR(1), @cProcLisMat1 VARCHAR(250), @cProcLisMat2 VARCHAR(250), @cProcLisMat3 VARCHAR(250)
AS
DECLARE @cLisMat as VARCHAR(750)
DECLARE @Retfun int, @RetAux int, @nCont int, @nContOK int, @nPos int
DECLARE @cFunc VARCHAR(12), @cPis VARCHAR(12), @cNome VARCHAR(52)
DECLARE @cLisOKMat_1 VARCHAR(250), @cLisPis_1 VARCHAR(250) 
DECLARE @cLisOKMat_2 VARCHAR(250), @cLisPis_2 VARCHAR(250) 
DECLARE @cLisOKMat_3 VARCHAR(250), @cLisPis_3 VARCHAR(250) 
DECLARE @cErrMat VARCHAR(250)



	SET @nCont = 0
	SET @nContOK = 0

	SET @cLisOKMat_1 = ''		-- assume lista vazia de matriculas ok
	SET @cLisPis_1 = ''

	SET @cLisOKMat_2 = ''		-- assume lista vazia de matriculas ok
	SET @cLisPis_2 = ''

	SET @cLisOKMat_3 = ''		-- assume lista vazia de matriculas ok
	SET @cLisPis_3 = ''

	SET @cErrMat = NULL

	SET @cLisMat = @cProcLisMat1+coalesce(@cProcLisMat2,'')+coalesce(@cProcLisMat3,'')

	-- se é inicio de busca, limpa tabela auxiliar para o rep em questao no modo automatico ou manual
	IF (@cInicio = '1') begin 

		DELETE REPAUXEMPR WHERE END_IP = @cEndIp and TIPO = @cTipoCom;
		IF (@@ROWCOUNT = 0) begin
			SET @RetAux = 0
		END
	END 

	-- inicia a busca da lista de matriculas
	
	WHILE (@nCont < @nTotal) BEGIN
		SET @nPos = (@nCont * 12) + 1;
		SET @cFunc = SUBSTRING (@cLisMat, @nPos, 12);

		-- procura pelo nome e PIS contendo somente 12 digitos
		SELECT @cPis = PIS, @cNome = NOME  
			FROM REPEMPR002 WHERE (IFUNC = @cFunc) and (PIS not like '%[^0-9]%')		-- NAO DEVERA VIR PIS Q TENHA NAO DIGITO E MENOR Q 12 POSICOES

		IF (@@ROWCOUNT = 0) BEGIN
			INSERT INTO REPLOAD001 (END_IP, REP, IFUNC, DIA) 
				VALUES (@cEndIp, @cNumRep, @cFunc, getdate());
					
			if (@cErrMat IS null) BEGIN 
				SET @cErrMat = @cFunc 
			END
		END
		ELSE begin
			-- cada 20 matriculas, vai em 1 variavel, pois somente 20 matriculs (12 * 20) cabem em 250
			IF (@nContOK < 20) begin
				SET @cLisOKMat_1 = @cLisOKMat_1 + @cFunc ;
				SET @cLisPis_1 = @cLisPis_1 + @cPis ;
			end
			ELSE IF (@nContOK < 40) begin
				SET @cLisOKMat_2 = @cLisOKMat_2 + @cFunc ;
				SET @cLisPis_2 = @cLisPis_2 + @cPis ;
			end
			ELSE IF (@nContOK < 60) begin
				SET @cLisOKMat_3 = @cLisOKMat_3 + @cFunc ;
				SET @cLisPis_3 = @cLisPis_3 + @cPis ;
			end
			ELSE begin
				SET @nCont = @nTotal;
			end
			SET @nContOK = @nContOK + 1;
			
			-- guarda informacoes de Pis e Nome em tabela auxilar REPAUXEMPR
			UPDATE REPAUXEMPR SET NOME = @cNome, ST = '0'  
				WHERE END_IP = @cEndIp and TIPO = @cTipoCom and PIS = @cPis AND IFUNC = @cFunc ;

			IF (@@ROWCOUNT = 0) BEGIN
				INSERT INTO REPAUXEMPR (END_IP, PIS, NOME, TIPO, IFUNC, ST) VALUES 
					(@cEndIp, @cPis, @cNome, @cTipoCom, @cFunc, '0')		-- cTipoCom :'0' = carga via comando, 1 = automatico
			END
			
		END
		SET @nCont = @nCont+1;
	END	
	
			
	SELECT @nContOK,
		@cLisOKMat_1, @cLisPis_1, 
		@cLisOKMat_2, @cLisPis_2, 
		@cLisOKMat_3, @cLisPis_3, 
		@cErrMat

	GO
			

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqller_RautoExclDigit4', 'p') is null
    exec ('create procedure TELESSVR.sqller_RautoExclDigit4 as select 1')
go

ALTER PROCEDURE TELESSVR.sqller_RautoExclDigit4 @cEndIp VARCHAR(15) 
AS

declare @nCont smallint
declare @nBloco smallint
declare @nTotal smallint
declare @cStatus char(1)
declare @cBio_Tipo char(1)
declare @ICARD varchar(12)
declare @OLD_ICARD varchar(12)
declare @STATUS char(1)
declare @cListaId VARCHAR(250)
declare @cListaId_1 VARCHAR(250)
declare @cListaId_2 VARCHAR(250)
declare @cListaId_3 VARCHAR(250)
declare @cListaId_4 VARCHAR(250)
declare @cListaId_5 VARCHAR(250)

declare @cListaId_6 VARCHAR(250)
declare @cListaId_7 VARCHAR(250)
declare @cListaId_8 VARCHAR(250)
declare @cListaId_9 VARCHAR(250)
declare @cListaId_10 VARCHAR(250)

	SET @nCont = 0
	SET @nBloco = 1
	SET @nTotal = 0
	
	SET @cListaId = ''
	SET @cListaId_1 = ''
	SET @cListaId_2 = ''
	SET @cListaId_3 = ''
	SET @cListaId_4 = ''
	SET @cListaId_5 = ''
	SET @cListaId_6 = ''
	SET @cListaId_7 = ''
	SET @cListaId_8 = ''
	SET @cListaId_9 = ''
	SET @cListaId_10 = ''

	SET LOCK_TIMEOUT 2000

	-- procura pelo equipamento
	IF EXISTS (SELECT * FROM RDIG102  WHERE END_IP = @cEndIp AND STATUS = '1')
	BEGIN
	    SELECT @cStatus = STATUS, @cBio_Tipo = BIO_TIPO
			FROM RDIG102 NOLOCK
			WHERE END_IP = @cEndIp

		IF (@cStatus = '1') BEGIN
			-- SAGEM
			IF (@cBio_Tipo = '6' or @cBio_Tipo = '7') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG101 
						--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
						WHERE END_IP = @cEndIp AND STATUS != '0'
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 32) 
				while (@@fetch_status != -1) and (@nTotal < 200) 
				begin
					SET @cListaId = @cListaId + @ICARD
					SET @OLD_ICARD =  @ICARD
					
					
					-- COMO O CURSOR TEM O WHERE STATUS <> '2',
					-- E ESTE UPDATE E´SET STATUS = 2, O UPDATE SERÁ COLOCADO APOS O FETCH , PARA NAO INTEFERIR NO CURSOR (NAO SEJA PROCESSADO NOVAMENTE DENTRO DO WHILE)
					--UPDATE RDIG101 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					--if (@nCont > 8) begin
					if (@nCont >= 20) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId

						else if (@nBloco = 6) 
							set @cListaId_6 = @cListaId
						else if (@nBloco = 7) 
							set @cListaId_7 = @cListaId
						else if (@nBloco = 8) 
							set @cListaId_8 = @cListaId
						else if (@nBloco = 9) 
							set @cListaId_9 = @cListaId
						else if (@nBloco = 10) 
							set @cListaId_10 = @cListaId


						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
					UPDATE RDIG101 set STATUS = '2' where IFUNC = @OLD_ICARD AND END_IP = @cEndIp
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			-- TSI1	
			ELSE IF (@cBio_Tipo = '8') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG103 
						--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
						WHERE END_IP = @cEndIp AND STATUS != '0' 
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 32) 
				while (@@fetch_status != -1) and (@nTotal < 200) 		-- no máximo 200
				begin
					SET @cListaId = @cListaId + @ICARD
					SET @OLD_ICARD =  @ICARD
					
					-- COMO O CURSOR TEM O WHERE STATUS <> '2',
					-- ESTE UPDATE SERÁ COLOCADO APOS O FETCH , PARA NAO INTEFERIR NO CURSOR (NAO SEJA PROCESSADO NOVAMENTE DENTRO DO WHILE)
					--UPDATE RDIG103 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					--if (@nCont > 8) begin
					if (@nCont >= 20) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
							
						else if (@nBloco = 6) 
							set @cListaId_6 = @cListaId
						else if (@nBloco = 7) 
							set @cListaId_7 = @cListaId
						else if (@nBloco = 8) 
							set @cListaId_8 = @cListaId
						else if (@nBloco = 9) 
							set @cListaId_9 = @cListaId
						else if (@nBloco = 10) 
							set @cListaId_10 = @cListaId

							
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
					UPDATE RDIG103 set STATUS = '2' where IFUNC = @OLD_ICARD AND END_IP = @cEndIp
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			-- VIRDI	
			ELSE 
				--IF (@cBio_Tipo = '9') BEGIN		
				IF (@cBio_Tipo != '0') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG104 
						--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
						WHERE END_IP = @cEndIp AND STATUS != '0' 
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 32) 
				while (@@fetch_status != -1) and (@nTotal < 200) 
				begin
					SET @cListaId = @cListaId + @ICARD
					SET @OLD_ICARD =  @ICARD
					
					-- COMO O CURSOR TEM O WHERE STATUS <> '2',
					-- E ESTE UPDATE E´SET STATUS = 2, O UPDATE SERÁ COLOCADO APOS O FETCH , PARA NAO INTEFERIR NO CURSOR (NAO SEJA PROCESSADO NOVAMENTE DENTRO DO WHILE)
					--UPDATE RDIG104 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					--if (@nCont > 8) begin
					if (@nCont >= 20) begin		-- no maximo 20 por lista
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId

						else if (@nBloco = 6) 
							set @cListaId_6 = @cListaId
						else if (@nBloco = 7) 
							set @cListaId_7 = @cListaId
						else if (@nBloco = 8) 
							set @cListaId_8 = @cListaId
						else if (@nBloco = 9) 
							set @cListaId_9 = @cListaId
						else if (@nBloco = 10) 
							set @cListaId_10 = @cListaId

						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
					UPDATE RDIG104 set STATUS = '2' where IFUNC = @OLD_ICARD AND END_IP = @cEndIp
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END

			--IF ((@nCont > 0) AND (@nCont <= 8))
			IF ((@nCont > 0) AND (@nCont <= 20))
				if (@nBloco = 1) 
					set @cListaId_1 = @cListaId
				else if (@nBloco = 2) 
					set @cListaId_2 = @cListaId
				else if (@nBloco = 3) 
					set @cListaId_3 = @cListaId
				else if (@nBloco = 4) 
					set @cListaId_4 = @cListaId
				else if (@nBloco = 5) 
					set @cListaId_5 = @cListaId

				else if (@nBloco = 6) 
					set @cListaId_6 = @cListaId
				else if (@nBloco = 7) 
					set @cListaId_7 = @cListaId
				else if (@nBloco = 8) 
					set @cListaId_8 = @cListaId
				else if (@nBloco = 9) 
					set @cListaId_9 = @cListaId
				else if (@nBloco = 10) 
					set @cListaId_10 = @cListaId

			IF (@nTotal = 0) 
				UPDATE RDIG102 SET STATUS = '0' WHERE END_IP = @cEndIp;
			ELSE 
				UPDATE RDIG102 SET 
					STATUS = '2',
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;

		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaId_1 as cListaId_1,
		   @cListaId_2 as cListaId_2,
		   @cListaId_3 as cListaId_3,
		   @cListaId_4 as cListaId_4,
		   @cListaId_5 as cListaId_5,
		   @cListaId_6 as cListaId_6,
		   @cListaId_7 as cListaId_7,
		   @cListaId_8 as cListaId_8,
		   @cListaId_9 as cListaId_9,
		   @cListaId_10 as cListaId_10
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqller_RautoLoadDigit4', 'p') is null
    exec ('create procedure TELESSVR.sqller_RautoLoadDigit4 as select 1')
go

ALTER PROCEDURE TELESSVR.sqller_RautoLoadDigit4  @cEndIp VARCHAR(15) 
AS

declare @nCont smallint
declare @nBloco smallint
declare @nTotal int
declare @cStatus char(1)
declare @cBio_Tipo char(1)
declare @ICARD varchar(12)
declare @OLD_ICARD varchar(12)

declare @STATUS char(1)
declare @cListaId VARCHAR(250)
declare @cListaId_1 VARCHAR(250)
declare @cListaId_2 VARCHAR(250)
declare @cListaId_3 VARCHAR(250)
declare @cListaId_4 VARCHAR(250)
declare @cListaId_5 VARCHAR(250)
declare @cListaId_6 VARCHAR(250)
declare @cListaId_7 VARCHAR(250)
declare @cListaId_8 VARCHAR(250)
declare @cListaId_9 VARCHAR(250)
declare @cListaId_10 VARCHAR(250)

	SET @nCont = 0
	SET @nBloco = 1
	SET @nTotal = 0
	
	SET @cListaId = ''
	SET @cListaId_1 = ''
	SET @cListaId_2 = ''
	SET @cListaId_3 = ''
	SET @cListaId_4 = ''
	SET @cListaId_5 = ''

	SET @cListaId_6 = ''
	SET @cListaId_7 = ''
	SET @cListaId_8 = ''
	SET @cListaId_9 = ''
	SET @cListaId_10 = ''



	SET LOCK_TIMEOUT 5000

	-- procura pelo equipamento
	IF EXISTS (SELECT * FROM RDIG002  WHERE END_IP = @cEndIp and STATUS = '1')
	BEGIN
	    SELECT @cStatus = STATUS, @cBio_Tipo = BIO_TIPO
			FROM RDIG002
			WHERE END_IP = @cEndIp

		IF (@cStatus = '1') BEGIN
			-- SAGEM
			IF (@cBio_Tipo = '6' or @cBio_Tipo = '7') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG001 
						--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
						WHERE END_IP = @cEndIp AND STATUS != '0' 
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 24) 
				while (@@fetch_status != -1) and (@nTotal < 200) 
				begin
					SET @cListaId = @cListaId + @ICARD
					SET @OLD_ICARD =  @ICARD
					
					-- COMO O CURSOR TEM O WHERE STATUS <> '2',
					-- ESTE UPDATE SERÁ COLOCADO APOS O FETCH , PARA NAO INTEFERIR NO CURSOR (NAO SEJA PROCESSADO NOVAMENTE DENTRO DO WHILE)
					--UPDATE RDIG001 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					--if (@nCont >= 5) begin
					if (@nCont >= 20) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId

						else if (@nBloco = 6) 
							set @cListaId_6 = @cListaId
						else if (@nBloco = 7) 
							set @cListaId_7 = @cListaId
						else if (@nBloco = 8) 
							set @cListaId_8 = @cListaId
						else if (@nBloco = 9) 
							set @cListaId_9 = @cListaId
						else if (@nBloco = 10) 
							set @cListaId_10 = @cListaId

						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
					-- ESTE UPDATE ESTÁ DEPOIS DO FETCH, MAS DENTRO DO WHILE PORQUE ESTÁ ALTERANDO CAMPO QUE FAZ PARTE DO REQUISITO DA CRIACAO DO CURSOR
					UPDATE RDIG001 set STATUS = '2' where IFUNC = @OLD_ICARD AND END_IP = @cEndIp
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			-- TSI1
			IF (@cBio_Tipo = '8') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG003 
						--WHERE (END_IP = @cEndIp) and (STATUS != '0') and (STATUS != '2')
						WHERE (END_IP = @cEndIp) and (STATUS != '0') 
					ORDER by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 24) 
				while (@@fetch_status != -1) and (@nTotal < 200) 
				begin
					SET @cListaId = @cListaId + @ICARD
					SET @OLD_ICARD =  @ICARD
					
					-- COMO O CURSOR TEM O WHERE STATUS <> '2',
					-- ESTE UPDATE SERÁ COLOCADO APOS O FETCH , PARA NAO INTEFERIR NO CURSOR (NAO SEJA PROCESSADO NOVAMENTE DENTRO DO WHILE)
					--UPDATE RDIG003 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					--if (@nCont >= 5) begin
					if (@nCont >= 20) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
							
						else if (@nBloco = 6) 
							set @cListaId_6 = @cListaId
						else if (@nBloco = 7) 
							set @cListaId_7 = @cListaId
						else if (@nBloco = 8) 
							set @cListaId_8 = @cListaId
						else if (@nBloco = 9) 
							set @cListaId_9 = @cListaId
						else if (@nBloco = 10) 
							set @cListaId_10 = @cListaId
							
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS
					-- ESTE UPDATE ESTÁ DEPOIS DO FETCH, MAS DENTRO DO WHILE PORQUE ESTÁ ALTERANDO CAMPO QUE FAZ PARTE DO REQUISITO DA CRIACAO DO CURSOR
					UPDATE RDIG003 set STATUS = '2' where IFUNC = @OLD_ICARD AND END_IP = @cEndIp
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			-- VIRDI E OUTROS
			--IF (@cBio_Tipo = '9') BEGIN		
			IF (@cBio_Tipo != '0') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG004 
						--WHERE (END_IP = @cEndIp) and (STATUS != '0') and (STATUS != '2')
						WHERE (END_IP = @cEndIp) and (STATUS != '0') 
					ORDER by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 24) 
				while (@@fetch_status != -1) and (@nTotal < 200) 
				begin
					SET @cListaId = @cListaId + @ICARD
					SET @OLD_ICARD =  @ICARD
					
					-- COMO O CURSOR TEM O WHERE STATUS <> '2',
					-- ESTE UPDATE SERÁ COLOCADO APOS O FETCH , PARA NAO INTEFERIR NO CURSOR (NAO SEJA PROCESSADO NOVAMENTE DENTRO DO WHILE)
					--UPDATE RDIG004 set STATUS = '2' where current of Rldigit_cur
					SET @nCont = @nCont+1
					set @nTotal = @nTotal + 1

					--if (@nCont >= 5) begin
					if (@nCont >= 20) begin
						if (@nBloco = 1) 
							set @cListaId_1 = @cListaId
						else if (@nBloco = 2) 
							set @cListaId_2 = @cListaId
						else if (@nBloco = 3) 
							set @cListaId_3 = @cListaId
						else if (@nBloco = 4) 
							set @cListaId_4 = @cListaId
						else if (@nBloco = 5) 
							set @cListaId_5 = @cListaId
							
						else if (@nBloco = 6) 
							set @cListaId_6 = @cListaId
						else if (@nBloco = 7) 
							set @cListaId_7 = @cListaId
						else if (@nBloco = 8) 
							set @cListaId_8 = @cListaId
						else if (@nBloco = 9) 
							set @cListaId_9 = @cListaId
						else if (@nBloco = 10) 
							set @cListaId_10 = @cListaId
							
						set @cListaId = ''
						set @nBloco = @nBloco+1
						set @nCont = 0
					end
					fetch next from Rldigit_cur into @ICARD, @STATUS

					-- ESTE UPDATE ESTÁ DEPOIS DO FETCH, MAS DENTRO DO WHILE PORQUE ESTÁ ALTERANDO CAMPO QUE FAZ PARTE DO REQUISITO DA CRIACAO DO CURSOR
					UPDATE RDIG004 set STATUS = '2' where IFUNC = @OLD_ICARD AND END_IP = @cEndIp
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			--IF ((@nCont > 0) AND (@nCont < 5))
			IF ((@nCont > 0) AND (@nCont < 20))
				if (@nBloco = 1) 
					set @cListaId_1 = @cListaId
				else if (@nBloco = 2) 
					set @cListaId_2 = @cListaId
				else if (@nBloco = 3) 
					set @cListaId_3 = @cListaId
				else if (@nBloco = 4) 
					set @cListaId_4 = @cListaId
				else if (@nBloco = 5) 
					set @cListaId_5 = @cListaId

				else if (@nBloco = 6) 
					set @cListaId_6 = @cListaId
				else if (@nBloco = 7) 
					set @cListaId_7 = @cListaId
				else if (@nBloco = 8) 
					set @cListaId_8 = @cListaId
				else if (@nBloco = 9) 
					set @cListaId_9 = @cListaId
				else if (@nBloco = 10) 
					set @cListaId_10 = @cListaId

			IF (@nTotal = 0) 
				UPDATE RDIG002 SET STATUS = '0' WHERE END_IP = @cEndIp;
			ELSE 
				UPDATE RDIG002 SET 
					STATUS = '2',
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;
		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaId_1 as cListaId_1,
		   @cListaId_2 as cListaId_2,
		   @cListaId_3 as cListaId_3,
		   @cListaId_4 as cListaId_4,
		   @cListaId_5 as cListaId_5,
		   
		   @cListaId_6 as cListaId_6,
		   @cListaId_7 as cListaId_7,
		   @cListaId_8 as cListaId_8,
		   @cListaId_9 as cListaId_9,
		   @cListaId_10 as cListaId_10
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

-----------------------------------------------------------------------------
-- CONEX REP V.08.00.07 || CONEX REP V.08.00.07 || CONEX REP V.08.00.07 || --
-----------------------------------------------------------------------------

if object_id('TELESSVR.sqlrep_fimExcAuto5', 'p') is null
    exec ('create procedure TELESSVR.sqlrep_fimExcAuto5 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlrep_fimExcAuto5  @cEndIp CHAR(15), @cStat CHAR(1) AS

declare @nCont smallint
declare @nErr smallint
declare @Aux char(12)
declare @IFUNC char(12)
declare @STATUS char(1)
declare @cNovoStat char(1)
declare @cStInc char(1)


	SET LOCK_TIMEOUT 5000
	SET @nCont = 0
	SET @nErr = 0
	SET @cNovoStat = @cStat
	
	DECLARE lexcf002_cur CURSOR FOR
				SELECT IFUNC, STATUS FROM REPAUTO012 
					WHERE END_IP = @cEndIp AND STATUS = '2'
					order by IFUNC;

	open lexcf002_cur
	fetch next from lexcf002_cur into @IFUNC, @STATUS
	while (@@fetch_status != -1)
	begin
		-- NOVO : EXCLUI LINHA SE FICOU COM STATUS '0'
		IF (@cStat = '0') BEGIN
			INSERT INTO HISTREPFUN (IFUNC, END_IP, INSEXC, MODO)	VALUES (@IFUNC, @cEndIp, 'E', 'A');		-- TIPO:'I'= INCLUSAO, 'E'=EXCLUSAO; MODO:'A'=AUTOMATICO, 'M'=MANUAL
			DELETE REPAUTO012 where IFUNC = @IFUNC AND END_IP = @cEndIp        --WHERE current of lexcf002_cur 
		END
		ELSE BEGIN
			--NOVO
			-- SE ESTIVER PENDENTE, DEVE VERIFICAR SE HÁ ALGUM COMANDO DE EXCLUSAO DESSE FUNCIONÁRIO PARA O EQUIPAMENTO A SER EXECUTADO.
			-- SE HOUVER, DEVE-SE IGNORAR ESTA PENDENCIA DE INCLUSAO E TORNA-LA STATUS '4', PARA QUE O GERENCIADOR DE CARGA AUTOMÁTICA ANULE ESTA PENDENCIA
			IF (@cStat = '3') BEGIN 
				SET @cStInc = null
				SET @cStInc = (SELECT STATUS  FROM REPAUTO011 
						WHERE IFUNC = @IFUNC and END_IP = @cEndIp  AND STATUS <> '0') 
				IF (@cStInc <> null)
					-- ENCONTROU COMANDO MAIS RECENTE DE INCLUSAO, ENTÃO NOVO VALOR DE 	REPAUTO012.STATUS SERÁ '4' PARA QUE ESTA CARGA SER DESCARTADA, E NÃO SERÁ TRATADA COMO PENDENCIA.					
					SET @cNovoStat = '4';
						
			END
			--FIM NOVO
		
			--update REPAUTO012 set STATUS = @cStat where current of lexcf002_cur 
			update REPAUTO012 set STATUS = @cNovoStat where current of lexcf002_cur 
		END			
			
		SET @nCont = @nCont+1
		-- fim NOVO

		fetch next from lexcf002_cur into @IFUNC, @STATUS
	end
	close lexcf002_cur
	deallocate lexcf002_cur
	
	IF EXISTS (select END_IP FROM REPLASTCOM WHERE END_IP = @cEndIp) 
		UPDATE REPLASTCOM SET DATA_INS = GETDATE() WHERE END_IP = @cEndIp;
	ELSE
		INSERT INTO REPLASTCOM (END_IP, DATA_INS) VALUES (@cEndIp, GETDATE());

	UPDATE REPAUTO002 SET STATUS = @cStat WHERE END_IP = @cEndIp;
	SET LOCK_TIMEOUT -1


	return @nCont	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqlrep_fimInsAuto4', 'p') is null
    exec ('create procedure TELESSVR.sqlrep_fimInsAuto4 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlrep_fimInsAuto4  @cEndIp CHAR(15), @cStat CHAR(1) AS

declare @nCont smallint
declare @nErr smallint
declare @Aux char(12)
declare @IFUNC char(12)
declare @STATUS char(1)
declare @cNovoStat char(1)
declare @cStExc char(1)


	SET @nCont = 0
	SET @nErr = 0
	SET @cNovoStat = @cStat
	
	SET LOCK_TIMEOUT 5000
	DECLARE lfim011_cur CURSOR FOR
				SELECT IFUNC, STATUS FROM REPAUTO011 
					WHERE END_IP = @cEndIp AND STATUS = '2'
					order by IFUNC;

	open lfim011_cur
	fetch next from lfim011_cur into @IFUNC, @STATUS
	while (@@fetch_status != -1) 
	begin
	
		-- NOVO : EXCLUI LINHA SE FICOU COM STATUS '0'
		IF (@cStat = '0')
			DELETE REPAUTO011 where IFUNC = @IFUNC AND END_IP = @cEndIp        --WHERE current of lfim011_cur 
		ELSE
		BEGIN
			-- *************  NOVO
			-- SE ESTIVER PENDENTE, DEVE VERIFICAR SE HÁ ALGUM COMANDO DE EXCLUSAO DESSE FUNCIONÁRIO PARA O EQUIPAMENTO A SER EXECUTADO.
			-- SE HOUVER, DEVE-SE IGNORAR ESTA PENDENCIA DE INCLUSAO E TORNA-LA STATUS '4', PARA QUE O GERENCIADOR DE CARGA AUTOMÁTICA ANULE ESTA PENDENCIA
			IF (@cStat = '3') 
			BEGIN 
				SET @cStExc = null
				SET @cStExc = (SELECT STATUS  FROM REPAUTO012 
						WHERE IFUNC = @IFUNC and END_IP = @cEndIp AND STATUS <> '0')

				IF (@cStExc != null)
					-- ENCONTROU COMANDO MAIS RECENTE DE EXCLUSAO, ENTÃO NOVO VALOR DE 	REPAUTO011.STATUS SERÁ '4', PARA ESTA CARGA SER DESCARTADA, E NÃO TRATARÁ COMO PENDENCIA.					
					SET @cNovoStat = '4';
			END
			-- *************  FIM NOVO
		
			--update REPAUTO011 set STATUS = @cStat where current of lfim011_cur 
			update REPAUTO011 set STATUS = @cNovoStat where current of lfim011_cur 		-- ******** NOVO
		END	
		SET @nCont = @nCont+1

		fetch next from lfim011_cur into @IFUNC, @STATUS
	end
	close lfim011_cur
	deallocate lfim011_cur
	
	UPDATE REPAUTO001 SET STATUS = @cStat WHERE END_IP = @cEndIp;
	SET LOCK_TIMEOUT -1

	return @nCont	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.Prep_RepAuto6', 'p') is null
    exec ('create procedure TELESSVR.Prep_RepAuto6 as select 1')
go

ALTER PROCEDURE TELESSVR.Prep_RepAuto6 @nQtd INT AS

DECLARE @nCont SMALLINT
DECLARE @nTemLocal SMALLINT
          
DECLARE @c_status CHAR(1)
DECLARE @c_ifunc CHAR(12)
DECLARE @c_endip CHAR(15)
DECLARE @c_grupo CHAR(5)

DECLARE @xc_status CHAR(1)
DECLARE @xc_ifunc CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @ret CHAR(1)

DECLARE @cAux CHAR(1)
DECLARE @cAux1 CHAR(1)
DECLARE @cTipo CHAR(1)
DECLARE @nContMax SMALLINT
--DECLARE @nQTD SMALLINT

SET DATEFORMAT YMD


	set @ret = 0
	--set @nQTD = 5 * @nTempo

	SET LOCK_TIMEOUT 5000
	SET DATEFORMAT YMD
	
	
	-- *************** PREPARACAO DE INCLUSAO/EXCLUSAO  FUNCIONARIOS NOS EQUIPAMENTOS (MONTAGEM DAS TABELAS AUXILIARES)
	BEGIN
	
		-- tabela temporaria TMP_T :  TOP(N) linhas de REPNAUTO000 com solicitação de processamento de Inclusao ('3') e Exclusão ('8')
		DELETE TMP_T;
		DELETE TMP_NREP001;
		DELETE TMP_NREP002;
		DELETE TMP_NREPGRPATV
		
		--TRUNCATE TABLE TMP_T;
		--TRUNCATE TABLE TMP_NREP001;
		--TRUNCATE TABLE TMP_NREP002;
		--TRUNCATE TABLE TMP_NREPGRPATV;
		
		--INSERT INTO TMP_T select top(5) IFUNC, STATUS, GRUPO from REPNAUTO000 WHERE STATUS = '3' or STATUS = '8' ORDER BY DATA_INS, IFUNC
		--INSERT INTO TMP_T select top(@nQTD) IFUNC, STATUS, GRUPO from REPNAUTO000 WHERE STATUS = '3' or STATUS = '8' ORDER BY DATA_INS, IFUNC
		INSERT INTO TMP_T (IFUNC, STATUS, GRUPO) select top(@nQtd) IFUNC, STATUS, GRUPO from REPNAUTO000 WHERE STATUS = '3' or STATUS = '8' ORDER BY DATA_INS, IFUNC
		
		-- cursor para matriculas X GRUPOS a carregar/excluir
		--DECLARE cur_auto000 CURSOR FOR (select * from TMP_T)
		DECLARE cur_auto000 CURSOR FOR (select IFUNC, STATUS, GRUPO from TMP_T)

		SET @nContMax = 0
		OPEN cur_auto000
		FETCH NEXT FROM cur_auto000 INTO @c_ifunc, @c_status, @c_grupo
		
		--WHILE (@@fetch_status != -1 AND @nContMax < 100)
		WHILE (@@fetch_status != -1 AND @nContMax < @nQtd)
		BEGIN   
			SET @nTemLocal = 0
			
			DELETE TMP_NREP000GRP
			--TRUNCATE TABLE TMP_NREP000GRP
			insert into TMP_NREP000GRP (IFUNC, GRUPO, END_IP, STATUS)		-- inclui em TMP_NREP000GRP TODOS OS REPS Q FAZEM PARTE DO GRUPO EM QUESTAO (NOVO OU VELHO) DO FUNCIONARIO
				select @c_ifunc,  @c_grupo, VIEWGRPREP.end_ip, @c_status
					from VIEWGRPREP
					where
						CAST(VIEWGRPREP.grupo AS INT) = CAST(@c_grupo AS INT)

			IF (@@ROWCOUNT != 0) BEGIN
				SET @nTemLocal = 1
			END
		
		
			IF (@nTemLocal = 1) BEGIN
				DELETE TMP_NREP000OUTROS;
				--TRUNCATE TABLE TMP_NREP000OUTROS;
				
				-- inclui em TMP_NREP000OUTROS TODOS OS REPS Q FAZEM PARTE De outros GRUPOs DO FUNCIONARIO
				INSERT into TMP_NREP000OUTROS (IFUNC, GRUPO,  END_IP, STATUS)		
					select @c_ifunc, VIEWGRPREP.Grupo, VIEWGRPREP.end_ip, @c_status
						from VIEWGRPREP
						where
							(CAST(VIEWGRPREP.grupo AS INT) != CAST(@c_grupo AS INT)) and
							(CAST(VIEWGRPREP.grupo AS INT) in (select CAST(Grupo AS INT) from REPGRPF where IFUNC = @c_ifunc)) and 
							(CAST(VIEWGRPREP.grupo AS INT) not in (SELECT CAST(Grupo AS INT) FROM TMP_NREPGRPATV where IFUNC = @c_ifunc) ) ;
				
				set @nCont = @@ROWCOUNT
				
				-- Insere em tabela resultante OS REGISTROS de TMP_NREP000GRP que não tem em TMP_NREP000OUTROS
				IF (@c_status = '3') BEGIN
					set @cTipo = '3'

					DECLARE Rtmp_eqptos cursor for (SELECT END_IP from TMP_NREP000GRP  
						WHERE IFUNC = @c_ifunc and 
							STATUS = @cTipo and  
							CAST(Grupo AS INT) = CAST(@c_grupo AS INT))
							
					OPEN Rtmp_eqptos
					FETCH next from Rtmp_eqptos into @xc_endip
					WHILE @@fetch_status != -1
					BEGIN
						--SET @cAux = null
						--SET @cAux = (SELECT STATUS FROM TMP_NREP000OUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )

						--IF (@cAux is null) BEGIN
						
						SET @nCont = 0;
						SET @nCont = (SELECT count(*) FROM TMP_NREP000OUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
						IF (@nCont = 0)					
						BEGIN
							SET @cAux = (SELECT STATUS from TMP_NREP001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
							
							IF (@cAux is null)  
								INSERT into TMP_NREP001 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo );
							ELSE
								IF (@cAux = '0') 
									UPDATE TMP_NREP001 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip
						END
							
						-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE EXCLUSAO, PARA EXCLUIR
						BEGIN
							SET @cAux = null
							SET @cAux = (SELECT STATUS from TMP_NREP002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
							IF (@cAux = '8') 
								DELETE FROM TMP_NREP002 where IFUNC = @c_ifunc and END_IP = @xc_endip;
						END
							
						-- **********************************************************************
						-- NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  						
						-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE EXCLUSAO E ESTA PENDENTE
						SET @cAux = null
						SET @cAux = (SELECT STATUS from REPAUTO012 
										where IFUNC = @c_ifunc and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))
						
						IF (@cAux = '3')  
							UPDATE REPAUTO012 SET STATUS = '4' 							-- A EXCLUSAO QUE ESTÁ PENDENTE FICARA COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
								WHERE IFUNC = @c_ifunc and END_IP =@xc_endip;
						
						ELSE		-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
						BEGIN
							-- PROCURA EM REPAUTO002 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
							SET @cAux1 = null
							SET @cAux1 = (SELECT STATUS FROM REPAUTO002 WHERE END_IP = @xc_endip  and  STATUS = '2' and DATEADD (SECOND, 30, DATA_LOAD) < getdate())											
							IF (@cAux1 = '2')					
								UPDATE REPAUTO012 SET STATUS = '4' 						-- sinaliza que REP NAO RESPONDEU AO COMANDO DE EXCLUSAO E FICARÁ COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
									WHERE IFUNC = @c_ifunc and END_IP = @xc_endip;
						END
							
						-- FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    
						-- **********************************************************************
							
						fetch next from Rtmp_eqptos into @xc_endip
					END 
					
					CLOSE Rtmp_eqptos
					DEALLOCATE Rtmp_eqptos
				END
				
				ELSE IF (@c_status = '8') begin
					set @cTipo = '8'

					DECLARE Rtmp_eqptos cursor for (SELECT END_IP from TMP_NREP000GRP  
						WHERE IFUNC = @c_ifunc and 
							STATUS = @cTipo and
							CAST(Grupo AS INT) = CAST(@c_grupo AS INT) 
							)
					OPEN Rtmp_eqptos
					FETCH next from Rtmp_eqptos into @xc_endip
					WHILE @@fetch_status != -1
					BEGIN
						--SET @cAux = null
						--SET @cAux = (SELECT STATUS FROM TMP_NREP000OUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
						--IF (@cAux is null) BEGIN
						
						SET @nCont = 0;
						SET @nCont = (SELECT count(*) FROM TMP_NREP000OUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip)
						IF (@nCont = 0)					
						BEGIN						
							SET @cAux = (SELECT STATUS from TMP_NREP002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
							
							IF (@cAux is null)  
								INSERT into TMP_NREP002 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo );
							ELSE
								IF (@cAux = '0') 
									UPDATE TMP_NREP002 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip
						END
							
						-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE INCLUSAO, PARA INCLUIR
						BEGIN
							SET @cAux = null
							SET @cAux = (SELECT STATUS from TMP_NREP001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
							IF (@cAux = '3') 
								DELETE FROM TMP_NREP002 where IFUNC = @c_ifunc and END_IP = @xc_endip;		-- DEVE-SE EXCLUIR DA TAB.EXCLUSAO TMP_NREP002, PORQUE O EQUIPAMENTO PERTENCE A OUTRO GRUPO QUE VAI INCLUI-LO
								--DELETE FROM TMP_NREP001 where IFUNC = @c_ifunc and END_IP = @xc_endip;	-- ERRADO
						END
								
						-- **********************************************************************
						-- NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  						
						-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE INCLUSAO E ESTA PENDENTE

						SET @cAux = null
						SET @cAux = (SELECT STATUS from REPAUTO011 
										where IFUNC = @c_ifunc and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))

						IF (@cAux = '3')  
							UPDATE REPAUTO011 SET STATUS = '4' 							-- A INCLUSAO QUE ESTÁ PENDENTE FICARA COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
								WHERE IFUNC = @c_ifunc and END_IP =@xc_endip;
						
						ELSE		-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DE EXECUTANDO E NAO OBTEVE RESPOSTA
						BEGIN
							-- PROCURA EM REPAUTO001 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
							SET @cAux1 = null
							SET @cAux1 = (SELECT STATUS FROM REPAUTO001 WHERE END_IP = @xc_endip  and  STATUS = '2' and DATEADD (SECOND, 30, DATA_LOAD) < getdate())	
							IF (@cAux1 = '2')					
								UPDATE REPAUTO011 SET STATUS = '4' 						-- sinaliza que REP NAO RESPONDEU AO COMANDO DE INCLUSAO E FICARÁ COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
									WHERE IFUNC = @c_ifunc and END_IP = @xc_endip;
						END
							
						-- FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    
						-- **********************************************************************
						
								
						fetch next from Rtmp_eqptos into @xc_endip
					END 
					CLOSE Rtmp_eqptos
					DEALLOCATE Rtmp_eqptos
				END
			END

			SET @nContMax = @nContMax + 1
			-- atualiza estado para tratado em REPNAUTO000, SE NÃO encontrou equipamento pertencente ao grupo e cai fora para tratar proximo funcionario
			UPDATE REPNAUTO000 SET STATUS = '0' 			
				WHERE IFUNC = @c_ifunc and CAST(Grupo AS INT) = CAST(@c_grupo AS INT)
			
			INSERT INTO TMP_NREPGRPATV (IFUNC, GRUPO) VALUES (@c_ifunc, @c_grupo)

			FETCH NEXT FROM cur_auto000 INTO @c_ifunc, @c_status, @c_grupo
		END
		
		CLOSE cur_auto000
		DEALLOCATE cur_auto000
	END
			

	-- ***************  TRATA OS IFUNCS INSERIDOS  ***************
	SET @nCont = (SELECT COUNT(*) FROM TMP_NREP001 WHERE STATUS = '3')
	
	IF (@nCont != 0) BEGIN
	
		-- ESTE BLOCO ABAIXO EU TIREI PORQUE O SQL_REPAUTOF() FARA ESTA PARTE DE INSERIR EM REPAUTO001 OS QUE NAO EXISTEM
		/*
		-- coloca o codin na tab. REPAUTO001 (CARGA LISTA) se eqpto  não existir
		insert into REPAUTO001 (END_IP, STATUS)
			select distinct end_ip, '0'
			from TMP_NREP001
			where  TMP_NREP001.STATUS = '3'	 and 
				TMP_NREP001.end_ip not in ( select end_ip from REPAUTO001 )
		
		*/
		
		
		-- insere ifunc-rep em tab. REPAUTO011, se não existir em tab.
		DECLARE cur_tmpauto000 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_NREP001 where STATUS = '3')
		OPEN cur_tmpauto000
		FETCH NEXT FROM cur_tmpauto000 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE REPAUTO011 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO REPAUTO011 (IFUNC, END_IP, STATUS) 
								values (@xc_ifunc, @xc_endip, '1');
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			--DELETE FROM REPAUTO012 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	-- DELETA DA TABELA DE EXCLUSAO
			
			DELETE FROM REPAUTO012 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1' OR STATUS = '4')	-- DELETA DA TABELA DE EXCLUSAO

			FETCH NEXT FROM cur_tmpauto000 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpauto000
		DEALLOCATE cur_tmpauto000
	END

	
	-- ***************   TRATA OS IFUNCS EXCLUIDOS ***************
	SET @nCont = (SELECT COUNT(*) FROM TMP_NREP002 WHERE STATUS = '8')
	
	if (@nCont != 0) BEGIN
	
		-- ESTE BLOCO ABAIXO EU TIREI PORQUE O SQL_REPAUTOF() FARA ESTA PARTE DE INSERIR EM REPAUTO001 OS QUE NAO EXISTEM
		/*
		-- coloca o codin na tab. REPAUTO002 (EXCLUSAO) se o eqpto não existir
		INSERT INTO REPAUTO002 (END_IP, STATUS) 
			select distinct end_ip, '0'
			from TMP_NREP002
			where TMP_NREP002.STATUS = '8'	and 
				  TMP_NREP002.end_ip not in ( select end_ip from REPAUTO002 )
		*/				
	
		-- insere ifunc-rep em tab. REPAUTO012, se não existir em tab.
		DECLARE cur_tmpauto000 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_NREP002 where STATUS = '8')
		OPEN cur_tmpauto000
		FETCH NEXT FROM cur_tmpauto000 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE REPAUTO012 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO REPAUTO012 (IFUNC, END_IP, STATUS) 
								values (@xc_ifunc, @xc_endip, '1');
			end

			-- deleta o ifunc da tabela de inclusao para o rep especifico do grupo
			DELETE FROM REPAUTO011 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1' OR STATUS = '4')	-- DELETA DA TABELA DE INCLUSAO

			FETCH NEXT FROM cur_tmpauto000 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpauto000
		DEALLOCATE cur_tmpauto000
	end

	/*
	DELETE TMP_T
	DELETE TMP_NREP000GRP

	DELETE TMP_NREP000OUTROS
	DELETE TMP_NREPGRPATV
	
	DELETE TMP_NREP001
	DELETE TMP_NREP002
	*/

	/*
	TRUNCATE TABLE TMP_T
	TRUNCATE TABLE TMP_NREP000GRP
	TRUNCATE TABLE TMP_NREP000OUTROS
	TRUNCATE TABLE TMP_NREPGRPATV
	TRUNCATE TABLE TMP_NREP001
	TRUNCATE TABLE TMP_NREP002
	*/
	SET LOCK_TIMEOUT -1



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.SQL_REPAUTOF2', 'p') is null
    exec ('create procedure TELESSVR.SQL_REPAUTOF2 as select 1')
go

ALTER PROCEDURE TELESSVR.SQL_REPAUTOF2 AS

DECLARE @c_status CHAR(1)
DECLARE @c_icard CHAR(12)

DECLARE @xc_status CHAR(1)
DECLARE @xc_icard CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @xc_tipobio CHAR(1)
DECLARE @ret CHAR(1)

DECLARE @z_endip CHAR(15)

SET DATEFORMAT YMD


	set @ret = 0
	
	-- exec TELESSVR.Prep_RepAuto3
	
	SET LOCK_TIMEOUT 5000
	
	-- VERIFICA SE HA FUNCIONARIOS A SEREM CARREGADOS
	BEGIN
		DECLARE cur_endip CURSOR FOR (
		select distinct A.END_IP 
			from REPAUTO011 A 
			WHERE (A.status != '0' and A.status != '2' and A.status != '4') AND				-- '4' = para resposta de nao implementado/sem resposta com sobreposicao comandos
				A.END_IP  NOT IN (SELECT END_IP FROM REPAUTO001 WHERE STATUS = '1') )
		OPEN cur_endip
		FETCH NEXT FROM cur_endip INTO @z_endip
		while @@fetch_status != -1
		begin
			IF NOT EXISTS (SELECT status FROM REPAUTO001 WHERE END_IP = @z_endip)
				insert into REPAUTO001 (END_IP, STATUS) VALUES (@z_endip, '1')

			ELSE
				UPDATE REPAUTO001 set status = '1'
					WHERE (end_ip = @z_endip and (status = '0' or status = '3' or status = '4'))			-- '4' = para resposta de nao implementado/sem resposta com sobreposicao comandos
				
			FETCH NEXT FROM cur_endip INTO @z_endip
		end
		CLOSE cur_endip
		deallocate cur_endip

		
	END


	-- VERIFICA SE HA FUNCIONARIOS A SEREM EXCLUIDOS
	BEGIN
		
		DECLARE cur_endip CURSOR FOR (
		select distinct A.END_IP 
					from REPAUTO012 A 
					WHERE (A.status != '0' and A.status != '2' and A.status != '4') AND
				A.END_IP  NOT IN (SELECT END_IP FROM REPAUTO002 WHERE STATUS = '1') )
		OPEN cur_endip
		FETCH NEXT FROM cur_endip INTO @z_endip
		while @@fetch_status != -1
		begin
			IF NOT EXISTS (SELECT status FROM REPAUTO002 WHERE END_IP = @z_endip)
				insert into REPAUTO002 (END_IP, STATUS) VALUES (@z_endip, '1')
			ELSE
				UPDATE REPAUTO002 set status = '1'
					WHERE (end_ip = @z_endip and (status = '0' or status = '3' or status = '4' ))
				
				
			FETCH NEXT FROM cur_endip INTO @z_endip
		end
		CLOSE cur_endip
		deallocate cur_endip
		
	END


	-- verifica se ha´equipamentos de REPAUTO001 com status '2' parados
	BEGIN
		DECLARE cur_endip CURSOR FOR (select distinct END_IP from REPAUTO001 where ((status = '2') and (DATEADD (MINUTE, 2, data_load)  < getdate())) )
		OPEN cur_endip
		FETCH NEXT FROM cur_endip INTO @z_endip
		while @@fetch_status != -1
		begin
			UPDATE REPAUTO011 set status = '1'
				WHERE (end_ip = @z_endip and status = '2')
				
			UPDATE REPAUTO001 set status = '1' 
					where ((end_ip = @z_endip ) and (status = '2') and (DATEADD (MINUTE, 2, data_load)  < getdate()) )
				
			FETCH NEXT FROM cur_endip INTO @z_endip
		end
		CLOSE cur_endip
		deallocate cur_endip
	END
	

	-- verifica se ha´equipamentos de REPAUTO002 com status '2' parados
	BEGIN
		DECLARE cur_endip CURSOR FOR (select distinct END_IP from REPAUTO002 where ((status = '2') and (DATEADD (MINUTE, 2, data_load)  < getdate())) )
		OPEN cur_endip
		FETCH NEXT FROM cur_endip INTO @z_endip
		while @@fetch_status != -1
		begin
			UPDATE REPAUTO012 set status = '1'
				WHERE (end_ip = @z_endip and status = '2')
				
			UPDATE REPAUTO002 set status = '1' 
					where ((end_ip = @z_endip ) and (status = '2') and (DATEADD (MINUTE, 2, data_load)  < getdate()) )
				
			FETCH NEXT FROM cur_endip INTO @z_endip
		end
		CLOSE cur_endip
		deallocate cur_endip
	END

	
	SET LOCK_TIMEOUT -1
	select @ret
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqlfim_rExcAutoDigit3', 'p') is null
    exec ('create procedure TELESSVR.sqlfim_rExcAutoDigit3 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlfim_rExcAutoDigit3 @cEndIp CHAR(15), @cStat CHAR(1), @cBioTipo CHAR(1) 
AS


declare @nCont smallint
declare @nErr smallint
declare @Aux char(12)
declare @cIcard char(12)
declare @STATUS char(1)
declare @cStInc char(1);
declare @cNovoStat char(1);


	SET LOCK_TIMEOUT 5000
	SET @nCont = 0
	SET @nErr = 0
	SET @cNovoStat = @cStat
	
	IF (@cBioTipo =  '6' or @cBioTipo = '7') BEGIN		-- SAGEM
		DECLARE Rlexcldig_cur CURSOR FOR
			SELECT IFUNC, STATUS FROM RDIG101 
				WHERE END_IP = @cEndIp AND STATUS = '2'
				ORDER by IFUNC;

		OPEN Rlexcldig_cur
		FETCH next from Rlexcldig_cur into @cIcard, @STATUS
		WHILE (@@fetch_status != -1)
		begin
			-- ******* NOVO
			-- SE ESTIVER PENDENTE, DEVE VERIFICAR SE HÁ ALGUM COMANDO DE INCLUSAO DESSA DIGITALO PARA O EQUIPAMENTO A SER EXECUTADO.
			-- SE HOUVER, DEVE-SE IGNORAR ESTA PENDENCIA DE EXCLUSAO E TORNA-LA STATUS '4', PARA QUE O GERENCIADOR DE CARGA AUTOMÁTICA ANULE ESTA PENDENCIA
			IF (@cStat = '3') BEGIN 
				SET @cStInc = null
				SET @cStInc = (SELECT STATUS FROM RDIG001 
						WHERE IFUNC = @cIcard and END_IP = @cEndIp AND STATUS <> '0') 
				IF (@cStInc <> null)
					-- ENCONTROU COMANDO MAIS RECENTE DE INCLUSAO, ENTÃO NOVO VALOR DE 	RDIG101.STATUS SERÁ '4' PARA QUE ESTA EXCLUSAO SEJA DESCARTADA, E NÃO SERÁ TRATADA COMO PENDENCIA.					
					SET @cNovoStat = '4';
			END
			-- ******* FIM NOVO
		
			--UPDATE RDIG101 set STATUS = @cStat where current of Rlexcldig_cur 
			UPDATE RDIG101 set STATUS = @cNovoStat where current of Rlexcldig_cur 				-- ************** NOVO
			
			SET @nCont = @nCont+1

			fetch next from Rlexcldig_cur into @cIcard, @STATUS
		end
		close Rlexcldig_cur
		deallocate Rlexcldig_cur
	END

	ELSE	
	BEGIN
		IF (@cBioTipo = '8') BEGIN		-- TSI1
			DECLARE Rlexcldig_cur CURSOR FOR
				SELECT IFUNC, STATUS FROM RDIG103 
					WHERE END_IP = @cEndIp AND STATUS = '2'
					ORDER by IFUNC;

			OPEN Rlexcldig_cur
			FETCH next from Rlexcldig_cur into @cIcard, @STATUS
			WHILE (@@fetch_status != -1)
			begin
				-- ******* NOVO
				-- SE ESTIVER PENDENTE, DEVE VERIFICAR SE HÁ ALGUM COMANDO DE INCLUSAO DESSA DIGITALO PARA O EQUIPAMENTO A SER EXECUTADO.
				-- SE HOUVER, DEVE-SE IGNORAR ESTA PENDENCIA DE EXCLUSAO E TORNA-LA STATUS '4', PARA QUE O GERENCIADOR DE CARGA AUTOMÁTICA ANULE ESTA PENDENCIA
				IF (@cStat = '3') BEGIN 
					SET @cStInc = null
					SET @cStInc = (SELECT STATUS FROM RDIG003 
							WHERE IFUNC = @cIcard and END_IP = @cEndIp AND STATUS <> '0' )
					IF (@cStInc <> null)
						-- ENCONTROU COMANDO MAIS RECENTE DE INCLUSAO, ENTÃO NOVO VALOR DE 	RDIG101.STATUS SERÁ '4' PARA QUE ESTA EXCLUSAO SEJA DESCARTADA, E NÃO SERÁ TRATADA COMO PENDENCIA.					
						SET @cNovoStat = '4';
				END
				-- ******* FIM NOVO

				--UPDATE RDIG103 set STATUS = @cStat where current of Rlexcldig_cur 
				UPDATE RDIG103 set STATUS = @cNovoStat where current of Rlexcldig_cur 				-- ************** NOVO
			
				SET @nCont = @nCont+1

				fetch next from Rlexcldig_cur into @cIcard, @STATUS
			end
			close Rlexcldig_cur
			deallocate Rlexcldig_cur
		END
		
		ELSE
			--IF (@cBioTipo = '9') BEGIN		-- VIRDI
			IF (@cBioTipo != '0') BEGIN		-- VIRDI / OUTROS
				DECLARE Rlexcldig_cur CURSOR FOR
					SELECT IFUNC, STATUS FROM RDIG104 
						WHERE END_IP = @cEndIp AND STATUS = '2'
						ORDER by IFUNC;

				OPEN Rlexcldig_cur
				FETCH next from Rlexcldig_cur into @cIcard, @STATUS
				WHILE (@@fetch_status != -1)
				begin
					-- ******* NOVO
					-- SE ESTIVER PENDENTE, DEVE VERIFICAR SE HÁ ALGUM COMANDO DE INCLUSAO DESSA DIGITALO PARA O EQUIPAMENTO A SER EXECUTADO.
					-- SE HOUVER, DEVE-SE IGNORAR ESTA PENDENCIA DE EXCLUSAO E TORNA-LA STATUS '4', PARA QUE O GERENCIADOR DE CARGA AUTOMÁTICA ANULE ESTA PENDENCIA
					IF (@cStat = '3') BEGIN 
						SET @cStInc = null
						SET @cStInc = (SELECT STATUS FROM RDIG004 
								WHERE IFUNC = @cIcard and END_IP = @cEndIp AND STATUS <> '0' )
						IF (@cStInc <> null)
							-- ENCONTROU COMANDO MAIS RECENTE DE INCLUSAO, ENTÃO NOVO VALOR DE 	RDIG101.STATUS SERÁ '4' PARA QUE ESTA EXCLUSAO SEJA DESCARTADA, E NÃO SERÁ TRATADA COMO PENDENCIA.					
							SET @cNovoStat = '4';
					END
					-- ******* FIM NOVO

					--UPDATE RDIG104 set STATUS = @cStat where current of Rlexcldig_cur 
					UPDATE RDIG104 set STATUS = @cNovoStat where current of Rlexcldig_cur 				-- ************** NOVO
			
					SET @nCont = @nCont+1

					fetch next from Rlexcldig_cur into @cIcard, @STATUS
				end
				close Rlexcldig_cur
				deallocate Rlexcldig_cur
			END
	END
	UPDATE RDIG102 SET STATUS = @cStat WHERE END_IP = @cEndIp;
	SET LOCK_TIMEOUT -1


	return @nCont	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqlload_rlistadig4', 'p') is null
    exec ('create procedure TELESSVR.sqlload_rlistadig4 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlload_rlistadig4 @cMatric CHAR(12), @cEndIp CHAR(15), @cNumRep CHAR(25), @cStatus CHAR(1) , @cErro CHAR(1)
AS

DECLARE @Ret smallint, @cBioTipo CHAR(1), @ERR INT  , @cAux char(12), @cAuxEndIP char(12)
DECLARE @cStExc CHAR(1), @cNovoStat CHAR(1)


	SET @Ret = 0
	SET LOCK_TIMEOUT 2000
	SET @cBioTipo = '0'
	SET @cNovoStat = @cStatus
	
	SELECT @cBioTipo = BIO_TIPO FROM RDIG002
		WHERE END_IP = @cEndIp;
		
	if (@@ROWCOUNT = 1) begin
		-- (SAGEM)
		IF (@cBioTipo = '6' or @cBioTipo = '7') BEGIN
		
			-- *************  NOVO
			-- SE ESTIVER PENDENTE, DEVE VERIFICAR SE HÁ ALGUM COMANDO DE EXCLUSAO DESSE FUNCIONÁRIO PARA O EQUIPAMENTO A SER EXECUTADO.
			-- SE HOUVER, DEVE-SE IGNORAR ESTA PENDENCIA DE INCLUSAO E TORNA-LA STATUS '4', PARA QUE O GERENCIADOR DE CARGA AUTOMÁTICA ANULE ESTA PENDENCIA
			IF (@cStatus = '3') BEGIN 
				SET @cStExc = null
				SET @cStExc = (SELECT STATUS  FROM RDIG101 
						WHERE IFUNC = @cMatric and END_IP = @cEndIp AND STATUS <> '0')

				IF (@cStExc != null)
					-- ENCONTROU COMANDO MAIS RECENTE DE EXCLUSAO, ENTÃO NOVO VALOR DE 	REPAUTO011.STATUS SERÁ '4', PARA ESTA CARGA SER DESCARTADA, E NÃO TRATARÁ COMO PENDENCIA.					
					SET @cNovoStat = '4';
			END
			-- *************  FIM NOVO
		
		
			--UPDATE RDIG001 SET STATUS = @cStatus where IFUNC = @cMatric and END_IP = @cEndIp;
			UPDATE RDIG001 SET STATUS = @cNovoStat where IFUNC = @cMatric and END_IP = @cEndIp;		-- ******** NOVO
		END
		
		--  (TSI1)
		ELSE IF (@cBioTipo = '8')  BEGIN
			-- *************  NOVO
			-- SE ESTIVER PENDENTE, DEVE VERIFICAR SE HÁ ALGUM COMANDO DE EXCLUSAO DESSE FUNCIONÁRIO PARA O EQUIPAMENTO A SER EXECUTADO.
			-- SE HOUVER, DEVE-SE IGNORAR ESTA PENDENCIA DE INCLUSAO E TORNA-LA STATUS '4', PARA QUE O GERENCIADOR DE CARGA AUTOMÁTICA ANULE ESTA PENDENCIA
			IF (@cStatus = '3') BEGIN 
				SET @cStExc = null
				SET @cStExc = (SELECT STATUS  FROM RDIG103 
						WHERE IFUNC = @cMatric and END_IP = @cEndIp AND STATUS <> '0')

				IF (@cStExc != null)
					-- ENCONTROU COMANDO MAIS RECENTE DE EXCLUSAO, ENTÃO NOVO VALOR DE 	REPAUTO011.STATUS SERÁ '4', PARA ESTA CARGA SER DESCARTADA, E NÃO TRATARÁ COMO PENDENCIA.					
					SET @cNovoStat = '4';
			END
			-- *************  FIM NOVO
		
			--UPDATE RDIG003 SET STATUS = @cStatus where IFUNC = @cMatric and END_IP = @cEndIp;
			UPDATE RDIG003 SET STATUS = @cNovoStat where IFUNC = @cMatric and END_IP = @cEndIp;		-- ******** NOVO
		END

		--  (VIRDI) E OUTROS
		--ELSE IF (@cBioTipo = '9')  
		ELSE IF (@cBioTipo != '0') BEGIN  
			-- *************  NOVO
			-- SE ESTIVER PENDENTE, DEVE VERIFICAR SE HÁ ALGUM COMANDO DE EXCLUSAO DESSE FUNCIONÁRIO PARA O EQUIPAMENTO A SER EXECUTADO.
			-- SE HOUVER, DEVE-SE IGNORAR ESTA PENDENCIA DE INCLUSAO E TORNA-LA STATUS '4', PARA QUE O GERENCIADOR DE CARGA AUTOMÁTICA ANULE ESTA PENDENCIA
			IF (@cStatus = '3') BEGIN 
				SET @cStExc = null
				SET @cStExc = (SELECT STATUS  FROM RDIG104 
						WHERE IFUNC = @cMatric and END_IP = @cEndIp AND STATUS <> '0')

				IF (@cStExc != null)
					-- ENCONTROU COMANDO MAIS RECENTE DE EXCLUSAO, ENTÃO NOVO VALOR DE 	REPAUTO011.STATUS SERÁ '4', PARA ESTA CARGA SER DESCARTADA, E NÃO TRATARÁ COMO PENDENCIA.					
					SET @cNovoStat = '4';
			END
			-- *************  FIM NOVO
		
			--UPDATE RDIG004 SET STATUS = @cStatus where IFUNC = @cMatric and END_IP = @cEndIp;
			UPDATE RDIG004 SET STATUS = @cNovoStat where IFUNC = @cMatric and END_IP = @cEndIp;		-- ******** NOVO
		END

	END

	UPDATE RDIG002 SET DATA_LOAD = getdate() where END_IP = @cEndIp


	-- NOVO
	IF (@cStatus = '0') begin
		INSERT INTO HISTREPDIG (IFUNC, END_IP, BIO_TIPO, INSEXC, MODO) VALUES (@cMatric, @cEndIp, @cBioTipo, 'I', 'A')	-- TIPO:'I'= INCLUSAO, 'E'=EXCLUSAO; MODO:'A'=AUTOMATICO, 'M'=MANUAL

		SELECT @cAuxEndIP = END_IP FROM REPLASTCOM WHERE END_IP = @cEndIp;
		IF (@@ROWCOUNT = 0) 
			INSERT INTO REPLASTCOM (END_IP, DATA_INS) VALUES (@cEndIp, GETDATE());
		ELSE
			UPDATE REPLASTCOM SET DATA_INS = GETDATE() WHERE END_IP = @cEndIp;

	end
	ELSE
		--IF (@cStatus = '4')  	-- ERRO DE CARGA (devido a memoria cheiia, minucia errada: que nao adianta enviar a digital novamente ao equipamento ), ou nao implementado
			INSERT INTO REPDIGLOAD001 (END_IP, REP, IFUNC, BIO_TIPO, NERRO) VALUES (@cEndIp, @cNumRep, @cMatric, @cBioTipo, @cErro);

	-- FIM NOVO



	SET LOCK_TIMEOUT -1
	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.Prep_RepDigit4', 'p') is null
    exec ('create procedure TELESSVR.Prep_RepDigit4 as select 1')
go

ALTER PROCEDURE TELESSVR.Prep_RepDigit4 @nQtd INT 
AS

DECLARE @nCont SMALLINT
DECLARE @nTemLocal SMALLINT
          
DECLARE @c_status CHAR(1)
DECLARE @c_ifunc CHAR(12)
DECLARE @c_endip CHAR(15)
DECLARE @c_grupo CHAR(5)
DECLARE @c_biotipo CHAR(1)

DECLARE @xc_status CHAR(1)
DECLARE @xc_ifunc CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @ret CHAR(1)
DECLARE @xc_biotipo CHAR(1)

DECLARE @cAux CHAR(1)
DECLARE @cAux1 CHAR(1)
DECLARE @cTipo CHAR(1)

SET DATEFORMAT YMD


	set @ret = 0

	SET LOCK_TIMEOUT 5000
	
	-- *************** PREPARACAO DE INCLUSAO/EXCLUSAO  FUNCIONARIOS NOS EQUIPAMENTOS (MONTAGEM DAS TABELAS AUXILIARES)
	BEGIN
	
		DELETE TMP_TD;
		DELETE TMP_NREPGRPATV;
		
		DELETE TMP_REPSAG001
		DELETE TMP_REPSAG002
	
		DELETE TMP_REPSUP001
		DELETE TMP_REPSUP002
		
		DELETE TMP_REPVRD001
		DELETE TMP_REPVRD002
		
		-- tabela temporaria TMP_TD compostas de todas as linhas de REPNDIGAUTO000 com solicitação de processamento de Inclusao ('3') e Exclusão ('8')
		--INSERT INTO TMP_TD select top(5) IFUNC, STATUS, GRUPO, BIO_TIPO from REPNDIGAUTO000 WHERE STATUS = '3' or STATUS = '8' ORDER BY DATA_INS, IFUNC
		INSERT INTO TMP_TD select top(@nQtd) IFUNC, STATUS, GRUPO, BIO_TIPO from REPNDIGAUTO000 WHERE STATUS = '3' or STATUS = '8' ORDER BY DATA_INS, IFUNC
		
		-- cursor para matriculas X GRUPOS a carregar/excluir
		DECLARE cur_autod000 CURSOR FOR (select IFUNC, STATUS, GRUPO, BIO_TIPO from TMP_TD)

		OPEN cur_autod000
		FETCH NEXT FROM cur_autod000 INTO @c_ifunc, @c_status, @c_grupo, @c_biotipo
		
		WHILE @@fetch_status != -1
		BEGIN   
			SET @nTemLocal = 0
			DELETE FROM TMP_NREPDIGGRP
			
			-- VERIFICA SE VALOR DE REPNDIGAUTO000.BIO_TIPO tem valor '0'.
			-- SE VALOR '0', indica que a preparacao das tabelas é para todos tipo de biometria
			-- SE VALOR é específico para TIPO DE LEITOR BIO, só vai ENTRAR EM tab. TMP_NREPDIGGRP os equipamentos dessa biometria

			IF (@c_biotipo = '0') BEGIN
				-- inclui em TMP_NREPDIGGRP TODOS OS REPS Q FAZEM PARTE DO GRUPO EM QUESTAO (NOVO OU VELHO) DO FUNCIONARIO 
				insert into TMP_NREPDIGGRP (IFUNC, GRUPO, END_IP, STATUS, BIO_TIPO)		
					select distinct @c_ifunc,  @c_grupo, VIEWGRPREP.end_ip, @c_status, VIEWGRPREP.BIO_TIPO
						from VIEWGRPREP
						where
							CAST(VIEWGRPREP.grupo AS INT) = CAST(@c_grupo AS INT) and
							--(VIEWGRPREP.bio_tipo = '6' or VIEWGRPREP.bio_tipo = '7'  or VIEWGRPREP.bio_tipo = '8' or VIEWGRPREP.bio_tipo = '9');
							--(VIEWGRPREP.bio_tipo != '0') ;
							((VIEWGRPREP.bio_tipo != '0') AND (VIEWGRPREP.bio_tipo != 'A'));
			END
			ELSE BEGIN
				insert into TMP_NREPDIGGRP (IFUNC, GRUPO, END_IP, STATUS, BIO_TIPO)		
					select distinct @c_ifunc,  @c_grupo, VIEWGRPREP.end_ip, @c_status, @c_biotipo
						from VIEWGRPREP
						where
							CAST(VIEWGRPREP.grupo AS INT) = CAST(@c_grupo AS INT) and
							VIEWGRPREP.bio_tipo = @c_biotipo
				
			END			
			
			
			IF (@@ROWCOUNT != 0) BEGIN
				SET @nTemLocal = 1
			END
		
		
			IF (@nTemLocal = 1) BEGIN
				DELETE FROM TMP_NREPDIGOUTROS;

				IF (@c_biotipo = '0') BEGIN
					-- inclui em TMP_NREPDIGOUTROS TODOS OS REPS Q FAZEM PARTE De outros GRUPOs DO FUNCIONARIO
					INSERT into TMP_NREPDIGOUTROS (IFUNC, GRUPO,  END_IP, BIO_TIPO, STATUS)		
						select distinct @c_ifunc, VIEWGRPREP.Grupo, VIEWGRPREP.end_ip, VIEWGRPREP.bio_tipo, @c_status
							from VIEWGRPREP, REPGRPF
							where
								(CAST(VIEWGRPREP.grupo AS INT) != CAST(@c_grupo AS INT)) and
								(CAST(VIEWGRPREP.grupo AS INT) in (select CAST(Grupo AS INT) from REPGRPF where IFUNC = @c_ifunc)) and 
								(CAST(VIEWGRPREP.grupo AS INT) not in (SELECT CAST(Grupo AS INT) FROM TMP_NREPDIGATV where IFUNC = @c_ifunc) ) and 
								--(VIEWGRPREP.bio_tipo = '6' or VIEWGRPREP.bio_tipo = '7'  or VIEWGRPREP.bio_tipo = '8' or VIEWGRPREP.bio_tipo = '9');
								--(VIEWGRPREP.bio_tipo != '0');
								((VIEWGRPREP.bio_tipo != '0') AND (VIEWGRPREP.bio_tipo != 'A'));
				END
				ELSE BEGIN
					INSERT into TMP_NREPDIGOUTROS (IFUNC, GRUPO,  END_IP, BIO_TIPO, STATUS)		
						select distinct @c_ifunc, VIEWGRPREP.Grupo, VIEWGRPREP.end_ip, @c_biotipo, @c_status
							from VIEWGRPREP, REPGRPF
							where
								(CAST(VIEWGRPREP.grupo AS INT) != CAST(@c_grupo AS INT)) and
								(CAST(VIEWGRPREP.grupo AS INT) in (select CAST(Grupo AS INT) from REPGRPF where IFUNC = @c_ifunc)) and 
								(CAST(VIEWGRPREP.grupo AS INT) not in (SELECT CAST(Grupo AS INT) FROM TMP_NREPDIGATV where IFUNC = @c_ifunc) ) and 
								(VIEWGRPREP.bio_tipo = @c_biotipo);
				END			

				set @nCont = @@ROWCOUNT
				
				-- Insere em tabela resultante OS REGISTROS de TMP_NREPDIGGRP que não tem em TMP_NREPDIGOUTROS
				IF (@c_status = '3') BEGIN		-- INCLUINDO
					set @cTipo = '3'

					DECLARE Rtmp_digeqptos cursor for (SELECT END_IP, BIO_TIPO from TMP_NREPDIGGRP  
						WHERE IFUNC = @c_ifunc and 
							STATUS = @cTipo and  
							CAST(Grupo AS INT) = CAST(@c_grupo AS INT) )
							
					OPEN Rtmp_digeqptos
					FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					WHILE @@fetch_status != -1
					BEGIN
						SET @nCont = 0;
						SET @nCont = (SELECT count(*) FROM TMP_NREPDIGOUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
						IF (@nCont = 0)					
						BEGIN
							-- trata equipamento SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') 
							begin
								SET @cAux = (SELECT STATUS FROM TMP_REPSAG001 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
								IF (@cAux  is null) 
									INSERT into TMP_REPSAG001 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo);
								ELSE
									IF (@cAux = '0') 
										UPDATE TMP_REPSAG001 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip;
							end
							ELSE 
								-- trata equipamento SUPREMA
								IF (@xc_biotipo = '8') begin
									SET @cAux = (SELECT STATUS FROM TMP_REPSUP001 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
									IF (@cAux  is null) 
										INSERT into TMP_REPSUP001 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo);
									ELSE
										IF (@cAux = '0') 
											UPDATE TMP_REPSUP001 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip;
								end											
							ELSE 
								-- trata equipamento VIRDI /e outros
								IF (@xc_biotipo != 'A') 		-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
								begin
									-- trata equipamento VIRDI / OUTROS
									SET @cAux = (SELECT STATUS FROM TMP_REPVRD001 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
									IF (@cAux  is null) 
										INSERT into TMP_REPVRD001 (IFUNC, END_IP, BIO_TIPO, STATUS)	VALUES  (@c_ifunc, @xc_endip, @xc_biotipo, @cTipo);
									ELSE
										IF (@cAux = '0') 
											UPDATE TMP_REPVRD001 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip and BIO_TIPO = @xc_biotipo;
								end
						END									
							
						-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE EXCLUSAO, PARA EXCLUIR
						BEGIN
							-- SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') begin
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPSAG002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '8') 
									DELETE FROM TMP_REPSAG002 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							end
							-- SUPREMA
							ELSE IF (@xc_biotipo = '8') begin
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPSUP002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '8') 
									DELETE FROM TMP_REPSUP002 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							end
							-- VIRDI / OUTROS
							ELSE 
								IF (@xc_biotipo != 'A') begin	-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
									SET @cAux = null
									SET @cAux = (SELECT STATUS from TMP_REPVRD002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
									IF (@cAux = '8') 
										DELETE FROM TMP_REPVRD002 where IFUNC = @c_ifunc and END_IP = @xc_endip;
								end
						END
						
						
						-- **********************************************************************
						-- NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  						
						-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE EXCLUSAO E ESTA PENDENTE

						-- SAGEM
						IF (@xc_biotipo = '6' or @xc_biotipo = '7') BEGIN
							SET @cAux = null
							SET @cAux = (SELECT STATUS FROM RDIG101
								WHERE IFUNC = @c_ifunc and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))

							IF (@cAux = '3') 		-- SITUAÇÃO PENDENTE 
									UPDATE RDIG101 SET STATUS = '4' 							-- A EXCLUSAO QUE ESTÁ PENDENTE FICARA COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
										WHERE IFUNC = @c_ifunc  and END_IP = @xc_endip;

							ELSE BEGIN
								IF (@cAux = '2') BEGIN	 	-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
									-- PROCURA EM RDIG102 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
									SET @cAux1 = null
									SET @cAux1 = (SELECT STATUS from RDIG102 
										where END_IP = @xc_endip and 
											  STATUS = '2' and 
											  (DATEADD (SECOND, 30, DATA_LOAD) < getdate()) AND	
											  ((BIO_TIPO = '6') OR (BIO_TIPO = '7')))		-- O COMANDO FOI FEITO HA MAIS DE 30 SEGUNDOS
												  
									IF (@cAux1 != null)
										UPDATE RDIG101 SET STATUS = '4' 						-- sinaliza que REP NAO RESPONDEU AO COMANDO DE EXCLUSAO E FICARÁ COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
											WHERE IFUNC = @c_ifunc and END_IP = @xc_endip;

								END
							END
						END			

						-- SUPREMA
						ELSE BEGIN
							IF (@xc_biotipo = '8') BEGIN
								SET @cAux = null
								SET @cAux = (SELECT STATUS FROM RDIG103
									WHERE IFUNC = @c_ifunc and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))

								IF (@cAux = '3') 		-- SITUAÇÃO PENDENTE 
									UPDATE RDIG103 SET STATUS = '4' 							-- A EXCLUSAO QUE ESTÁ PENDENTE FICARA COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
										WHERE IFUNC = @c_ifunc  and END_IP = @xc_endip;

								ELSE BEGIN
									IF (@cAux = '2') BEGIN   			-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
										-- PROCURA EM RDIG102 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
										SET @cAux1 = null
										SET @cAux1 = (SELECT STATUS from RDIG102 
											where END_IP = @xc_endip and 
												  STATUS = '2' and 
												  (DATEADD (SECOND, 30, DATA_LOAD) < getdate()) AND	
												  (BIO_TIPO = '8'))		-- O COMANDO FOI FEITO HA MAIS DE 30 SEGUNDOS
										IF (@cAux1 != null)
											UPDATE RDIG103 SET STATUS = '4' 						-- sinaliza que REP NAO RESPONDEU AO COMANDO DE EXCLUSAO E FICARÁ COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
												WHERE IFUNC = @c_ifunc and END_IP = @xc_endip;

									END
								END			
							END							
								

						-- OUTRAS BIOMETRIAS
						ELSE 
							IF (@xc_biotipo != 'A') BEGIN
								SET @cAux = null
								SET @cAux = (SELECT STATUS FROM RDIG104
									WHERE IFUNC = @c_ifunc and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))

								IF (@cAux = '3') 		-- SITUAÇÃO PENDENTE 
									UPDATE RDIG104 SET STATUS = '4' 							-- A EXCLUSAO QUE ESTÁ PENDENTE FICARA COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
										WHERE IFUNC = @c_ifunc  and END_IP = @xc_endip;

								ELSE BEGIN
									IF (@cAux = '2') BEGIN				-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
										-- PROCURA EM RDIG102 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
										SET @cAux1 = null
										SET @cAux1 = (SELECT STATUS from RDIG102 
											where END_IP = @xc_endip and 
												  STATUS = '2' and 
												  (DATEADD (SECOND, 30, DATA_LOAD) < getdate()) AND	
												  ((BIO_TIPO != '6') and (BIO_TIPO != '7') and (BIO_TIPO != '8') and (BIO_TIPO != 'A'))) 		-- O COMANDO FOI FEITO HA MAIS DE 30 SEGUNDOS
										IF (@cAux1 != null)
											UPDATE RDIG104 SET STATUS = '4' 						-- sinaliza que REP NAO RESPONDEU AO COMANDO DE EXCLUSAO E FICARÁ COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
												WHERE IFUNC = @c_ifunc and END_IP = @xc_endip;

									END			
								END
							END
						END 
						-- FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    
						-- **********************************************************************
								
						FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					END 
					
					CLOSE Rtmp_digeqptos
					DEALLOCATE Rtmp_digeqptos
				END
				
				ELSE IF (@c_status = '8') BEGIN		-- EXCLUINDO
					set @cTipo = '8'

					DECLARE Rtmp_digeqptos cursor for (SELECT END_IP, BIO_TIPO from TMP_NREPDIGGRP  
						WHERE IFUNC = @c_ifunc and 
							STATUS = @cTipo and  
							CAST(Grupo AS INT) = CAST(@c_grupo AS INT) )
					OPEN Rtmp_digeqptos
					FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					WHILE @@fetch_status != -1
					BEGIN

						SET @nCont = 0;
						SET @nCont = (SELECT count(*) FROM TMP_NREPDIGOUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
						IF (@nCont = 0)	BEGIN			
							-- trata equipamento SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') begin
								SET @cAux = (SELECT STATUS from TMP_REPSAG002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux is null)  
									INSERT into TMP_REPSAG002 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo );

								ELSE
									IF (@cAux = '0') 
										UPDATE TMP_REPSAG002 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip
							END
							ELSE 
								-- trata equipamento SUPREMA
								IF (@xc_biotipo = '8') begin
									SET @cAux = (SELECT STATUS FROM TMP_REPSUP002 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
									IF (@cAux  is null) 
										INSERT into TMP_REPSUP002 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo);
									ELSE
										IF (@cAux = '0') 
											UPDATE TMP_REPSUP002 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip;
								end											
								ELSE 
									-- trata equipamento VIRDI / OUTROS
									IF (@xc_biotipo != 'A') 		-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
									begin
										SET @cAux = (SELECT STATUS FROM TMP_REPVRD002 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
										IF (@cAux  is null) 
											INSERT into TMP_REPVRD002 (IFUNC, END_IP, BIO_TIPO, STATUS)	VALUES  (@c_ifunc, @xc_endip, @xc_biotipo, @cTipo);
										ELSE
											IF (@cAux = '0') 
												UPDATE TMP_REPVRD002 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip and BIO_TIPO = @xc_biotipo;
									end											
						END
							
						-- verifica se funcionario x ip ja está em tabela de inclusao, para incluir
						BEGIN
							-- SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') BEGIN
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPSAG001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '3') 
									DELETE FROM TMP_REPSAG001 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							END
							-- SUPREMA
							ELSE IF (@xc_biotipo = '8') BEGIN
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPSUP001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '3') 
									DELETE FROM TMP_REPSUP001 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							END
							-- VIRDI / OUTROS
							ELSE  IF (@xc_biotipo != 'A') BEGIN					-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPVRD001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '3') 
									DELETE FROM TMP_REPVRD001 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							END
						END
							
						-- **********************************************************************
						-- NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  						
						-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE INCLUSAO E ESTA PENDENTE

						-- SAGEM
						IF (@xc_biotipo = '6' or @xc_biotipo = '7') BEGIN
							SET @cAux = null
							SET @cAux = (SELECT STATUS FROM RDIG001
									WHERE IFUNC = @c_ifunc and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))

							IF (@cAux = '3') 		-- SITUAÇÃO PENDENTE 
								UPDATE RDIG001 SET STATUS = '4' 
									WHERE IFUNC = @c_ifunc and END_IP = @xc_endip

							ELSE IF (@cAux = '2') BEGIN	 		-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
								-- PROCURA EM RDIG002 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
								SET @cAux1 = null
								SET @cAux1 = (SELECT STATUS from RDIG002 
										where END_IP = @xc_endip and 
											  STATUS = '2' and 
											  (DATEADD (SECOND, 30, DATA_LOAD) < getdate()) AND	
											  ((BIO_TIPO = '6') OR (BIO_TIPO = '7'))) 		-- O COMANDO FOI FEITO HA MAIS DE 30 SEGUNDOS
								IF (@cAux != null)		
									UPDATE RDIG001 SET STATUS = '4' 
										WHERE IFUNC = @c_ifunc and END_IP = @xc_endip

							END
						END
						
						-- SUPREMA
						ELSE IF (@xc_biotipo = '8') BEGIN
							SET @cAux = null
							SET @cAux = (SELECT STATUS FROM RDIG003
									WHERE IFUNC = @c_ifunc and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))

							IF (@cAux = '3') 		-- SITUAÇÃO PENDENTE 
								UPDATE RDIG003 SET STATUS = '4' 
									WHERE IFUNC = @c_ifunc and END_IP = @xc_endip

							ELSE IF (@cAux = '2') BEGIN	 		-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
								-- PROCURA EM RDIG002 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
								SET @cAux1 = null
								SET @cAux1 = (SELECT STATUS from RDIG002 
										where END_IP = @xc_endip and 
											  STATUS = '2' and 
											  (DATEADD (SECOND, 30, DATA_LOAD) < getdate()) AND	
											  (BIO_TIPO = '8'))		-- O COMANDO FOI FEITO HA MAIS DE 30 SEGUNDOS
											
								IF (@cAux != null)	
									UPDATE RDIG003 SET STATUS = '4' 
										WHERE IFUNC = @c_ifunc and END_IP = @xc_endip
							END			
						END
						
						-- OUTRAS BIOMETRIAS
						ELSE IF (@xc_biotipo != 'A') BEGIN
							SET @cAux = null
							SET @cAux = (SELECT STATUS FROM RDIG004
									WHERE IFUNC = @c_ifunc and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))

							IF (@cAux = '3') 		-- SITUAÇÃO PENDENTE 
								UPDATE RDIG004 SET STATUS = '4' 
									WHERE IFUNC = @c_ifunc and END_IP = @xc_endip

							ELSE IF (@cAux = '2') BEGIN				 -- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
								-- PROCURA EM RDIG002 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
								SET @cAux1 = null
								SET @cAux1 = (SELECT STATUS from RDIG002 
										where END_IP = @xc_endip and 
											  STATUS = '2' and 
											  (DATEADD (SECOND, 30, DATA_LOAD) < getdate()) AND	
											  ((BIO_TIPO != '6') and (BIO_TIPO != '7') and (BIO_TIPO != '8') and (BIO_TIPO != 'A'))) 		-- O COMANDO FOI FEITO HA MAIS DE 30 SEGUNDOS
								IF (@cAux != null)	
									UPDATE RDIG004 SET STATUS = '4' 
										WHERE IFUNC = @c_ifunc and END_IP = @xc_endip

							END

						END
						
						-- FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    
						-- **********************************************************************
							
						FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					END 
					CLOSE Rtmp_digeqptos
					DEALLOCATE Rtmp_digeqptos
				END
			END

			-- atualiza estado para tratado em REPNDIGAUTO000, SE NÃO encontrou equipamento pertencente ao grupo e cai fora para tratar proximo funcionario
			UPDATE REPNDIGAUTO000 SET STATUS = '0' 			
				WHERE IFUNC = @c_ifunc and 
					BIO_TIPO = @c_biotipo and 
					CAST(Grupo AS INT) = CAST(@c_grupo AS INT)
			
			INSERT INTO TMP_NREPDIGATV (IFUNC, GRUPO, BIO_TIPO) VALUES (@c_ifunc, @c_grupo, @c_biotipo)

			FETCH NEXT FROM cur_autod000 INTO @c_ifunc, @c_status, @c_grupo, @c_biotipo
		END
		
		CLOSE cur_autod000
		DEALLOCATE cur_autod000
	END
			

	-- trata SAGEM
	-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSAG001 - INCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPSAG001 WHERE STATUS = '3')
	
	IF (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG002 (CARGA LISTA) se eqpto  não existir
		insert into RDIG002 (END_IP, STATUS, BIO_TIPO)
			select distinct end_ip, '0', '6' 
			from TMP_REPSAG001
			where TMP_REPSAG001.end_ip not in ( select end_ip from RDIG002 ) and 
					TMP_REPSAG001.STATUS = '3'	
		
		-- insere ifunc-rep em tab. RDIG001, se não existir em tab.
		DECLARE cur_tmpautoSAG001 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSAG001 where STATUS = '3' or STATUS = '1')
		OPEN cur_tmpautoSAG001
		FETCH NEXT FROM cur_tmpautoSAG001 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG001 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG001 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '6');
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			DELETE FROM RDIG101 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	-- DELETA DA TABELA DE EXCLUSAO

			FETCH NEXT FROM cur_tmpautoSAG001 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSAG001
		DEALLOCATE cur_tmpautoSAG001
	END

	
		-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSAG002 - EXCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPSAG002 WHERE STATUS = '8')
	if (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG102 (EXCLUSAO) o codin não existir
		INSERT INTO RDIG102 (END_IP, STATUS, BIO_TIPO) 
			select distinct end_ip, '0', '6'
			from TMP_REPSAG002
			where TMP_REPSAG002.end_ip not in ( select end_ip from RDIG102 ) and 
					TMP_REPSAG002.STATUS = '8'	
	
		-- insere ifunc-rep em tab. RDIG101, se não existir em tab.
		DECLARE cur_tmpautoSAG002 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSAG002 where STATUS = '8')
		OPEN cur_tmpautoSAG002
		FETCH NEXT FROM cur_tmpautoSAG002 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG101 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG101 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '6');
			end

			-- deleta o ifunc da tabela de INclusao para o rep especifico do grupo
			DELETE FROM RDIG001 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoSAG002 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSAG002
		DEALLOCATE cur_tmpautoSAG002
	end



	-- trata SUPREMA
	-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSUP001 - INCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPSUP001 WHERE STATUS = '3')
	
	IF (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG002 (CARGA LISTA) se eqpto  não existir
		insert into RDIG002 (END_IP, STATUS, BIO_TIPO)
			select distinct end_ip, '0', '8' 
			from TMP_REPSUP001
			where TMP_REPSUP001.end_ip not in ( select end_ip from RDIG002 ) and 
					TMP_REPSUP001.STATUS = '3'	
		
		-- insere ifunc-rep em tab. RDIG003, se não existir em tab.
		DECLARE cur_tmpautoSUP001 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSUP001 where STATUS = '3' or STATUS = '1')
		OPEN cur_tmpautoSUP001
		FETCH NEXT FROM cur_tmpautoSUP001 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG003 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG003 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '8');
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			DELETE FROM RDIG103 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoSUP001 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSUP001
		DEALLOCATE cur_tmpautoSUP001
	END

	
		-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSUP002 - EXCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPSUP002 WHERE STATUS = '8')
	
	if (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG102 (EXCLUSAO) o codin não existir
		INSERT INTO RDIG102 (END_IP, STATUS, BIO_TIPO) 
			select distinct end_ip, '0', '8'
			from TMP_REPSUP002
			where TMP_REPSUP002.end_ip not in ( select end_ip from RDIG102 ) and 
					TMP_REPSUP002.STATUS = '8'	
	
		-- insere ifunc-rep em tab. RDIG103, se não existir em tab.
		DECLARE cur_tmpautoSUP002 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSUP002 where STATUS = '8')
		OPEN cur_tmpautoSUP002
		FETCH NEXT FROM cur_tmpautoSUP002 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG103 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG103 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '8');
			end

			-- deleta o ifunc da tabela de INclusao para o rep especifico do grupo
			DELETE FROM RDIG003 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoSUP002 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSUP002
		DEALLOCATE cur_tmpautoSUP002
	END
	
	
	-- trata VIRDI / OUTRAS LEITORAS
	-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPVRD001 - INCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPVRD001 WHERE STATUS = '3')
	
	IF (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG002 (CARGA LISTA) se eqpto  não existir
		insert into RDIG002 (END_IP, STATUS, BIO_TIPO)
			--select distinct end_ip, '0', '9' 
			select distinct end_ip, '0', bio_tipo  
			from TMP_REPVRD001
			where TMP_REPVRD001.end_ip not in ( select end_ip from RDIG002 ) and 
					TMP_REPVRD001.STATUS = '3'	
		
		-- insere ifunc-rep em tab. RDIG004, se não existir em tab.
		DECLARE cur_tmpautoVRD001 CURSOR FOR (SELECT IFUNC, END_IP, STATUS, BIO_TIPO from TMP_REPVRD001 where STATUS = '3' or STATUS = '1')
		OPEN cur_tmpautoVRD001
		FETCH NEXT FROM cur_tmpautoVRD001 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		while @@fetch_status != -1
		begin
			UPDATE RDIG004 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG004 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', @xc_biotipo );
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			DELETE FROM RDIG104 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoVRD001 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		end
		CLOSE cur_tmpautoVRD001
		DEALLOCATE cur_tmpautoVRD001
	END

	
		-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPVRD002 - EXCLUSAO)
	SET @nCont = (SELECT COUNT(*) FROM TMP_REPVRD002 WHERE STATUS = '8')
	
	if (@nCont != 0) BEGIN
		-- coloca o codin na tab. RDIG102 (EXCLUSAO) o codin não existir
		INSERT INTO RDIG102 (END_IP, STATUS, BIO_TIPO) 
			--select distinct end_ip, '0', '9'
			select distinct end_ip, '0', bio_tipo 
			from TMP_REPVRD002
			where TMP_REPVRD002.end_ip not in ( select end_ip from RDIG102 ) and 
					TMP_REPVRD002.STATUS = '8'	
	
		-- insere ifunc-rep em tab. RDIG104, se não existir em tab.
		DECLARE cur_tmpautoVRD002 CURSOR FOR (SELECT IFUNC, END_IP, STATUS, BIO_TIPO from TMP_REPVRD002 where STATUS = '8')
		OPEN cur_tmpautoVRD002
		FETCH NEXT FROM cur_tmpautoVRD002 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		while @@fetch_status != -1
		begin
			UPDATE RDIG104 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG104 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								--values (@xc_ifunc, @xc_endip, '1', '9');
								values (@xc_ifunc, @xc_endip, '1', @xc_biotipo );
			end

			-- deleta o ifunc da tabela de INclusao para o rep especifico do grupo
			DELETE FROM RDIG004 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoVRD002 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		end
		CLOSE cur_tmpautoVRD002
		DEALLOCATE cur_tmpautoVRD002
	end	

	SET LOCK_TIMEOUT -1

GO

if object_id('TELESSVR.trata4_RepSagem', 'p') is null
    exec ('create procedure TELESSVR.trata4_RepSagem as select 1')
go

ALTER PROCEDURE TELESSVR.trata4_RepSagem 
AS


DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)

DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000


	-- ********************   ARRUMAR SITUAÇÕES PARA SAGEM    -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA (status '4')
	DECLARE Rcur_troubleIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG001 
			WHERE STATUS = '4'
		)
	OPEN Rcur_troubleIns1
	FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE Rcur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from RDIG001 
				WHERE (IFUNC = @z_mat and STATUS = '4')
			)
		OPEN Rcur_troubleIns2
		FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			--DELETE RDIG001 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')	-- vai excluir registro porque nao adianta reenviar 
			UPDATE RDIG001 set status = '0' WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')	-- vai alterar status porque nao adianta reenviar 

			UPDATE RDIG002 set status = '1' WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip
		END


		CLOSE Rcur_troubleIns2
		deallocate Rcur_troubleIns2

		FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	END
	
	CLOSE Rcur_troubleIns1
	deallocate Rcur_troubleIns1


	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS SAGEM (DA TAB.CONTDIG_SAGEM CADASTRO)
	-- delete registro de RDIG001 se nao houver cadastro de BIO SAGEM desta matricula
	DECLARE Rcur_autoIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG001 
			WHERE STATUS = '3'
		)
	OPEN Rcur_autoIns1
	FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		-- VERIFICA SE HÁ CADASTRO DO BIO SAGEM DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_SAGEM WHERE ICARD = @z_mat;
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO SAGEM desta matricula
			DECLARE Rcur_autoIns2 CURSOR FOR 
				(SELECT END_IP from RDIG001 
					WHERE (IFUNC = @z_mat and STATUS = '3')
				)
			OPEN Rcur_autoIns2
			FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				DELETE RDIG001 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '3')

				UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip
			END


			CLOSE Rcur_autoIns2
			deallocate Rcur_autoIns2
		END

		FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat
	END
	
	CLOSE Rcur_autoIns1
	deallocate Rcur_autoIns1



	-- ******************** ALTERA STATUS DE TODOS OS CODINS PARA CARGA DE DIGITAIS, SE ESSES NÃO ESTIVEREM COM CARGA DE DIGITAIS OU ESTIVEREM PENDENTES
	-- nao altera status se o equipamento responde 'NAO IMPLEMENTADO'
	DECLARE Rcur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG001 
			--WHERE ( status != '0' and status != '2' and			-- biometrias pendentes na carga
			WHERE ( status != '0' and status != '2' and status != '4' and			-- biometrias pendentes na carga
					(BIO_TIPO = '6' OR BIO_TIPO = '7')
				  )
		)
	OPEN Rcur_endip
	FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status
	
	WHILE @@fetch_status != -1
	begin
		UPDATE RDIG002 set status = '1'						-- FORCA RECARGA DAS BIOMETRIAS PENDENTES, ATIVANDO DIG002
			WHERE (END_IP = @z_endip and 
					(STATUS = '0' or STATUS = '3' or STATUS = '4') and 		-- status '0':carregado, '3':pendente, '4':rep nao aceita carga digital
					BIO_TIPO = @z_biotipo)
		FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status
	end

	CLOSE Rcur_endip
	deallocate Rcur_endip




	-- ********************   TRATA EQUIPAMENTOS SAGEM QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos SAGEM q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos SAGEM que tiveram carga de aplicativo ('5') de devem voltar ao estado de repouso. OBS: nao está fazenda a recarga de biometria automaticamente.
	
	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from RDIG002 
			WHERE ((BIO_TIPO = '6' or BIO_TIPO = '7')
					and
				   (status = '5' or status = '6' OR		-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())) 
				  )
		)
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status
	
	WHILE @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE RDIG001 set STATUS = '1'			-- status = 1 (A carregar)
				WHERE (end_ip = @z_endip and status = '2' and BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')
					
			UPDATE RDIG002 set status = '1'  		-- FORÇA A RECARGA PARA AQUELS QUE DERAM PROBLEMA
				where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)
		end

		else if (@z_status = '5' or @z_status = '6') begin
			UPDATE RDIG002 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)		-- NAO FAZ RECARGA DE BIOMETRIAS SAGEM APOS CARGA DE APLICATIVO
		end;
		
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_dig02
	DEALLOCATE Rcur_dig02
	

	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUAÇÃO
	-- para BIOMETRIAS  SAGEM DE DIG001 que ficaram em estado carregando '2', e o equipamento está em estado de repouso	, forca o equipamento a carrega-lo novamente
	
	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.STATUS from RDIG002 A 
			INNER JOIN RDIG001 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				(A.BIO_TIPO = '6') or (A.BIO_TIPO = '7')) 
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG001 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and (BIO_TIPO = '6' or BIO_TIPO = '7');
		UPDATE RDIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip and (BIO_TIPO = '6' or BIO_TIPO = '7');
		
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status;
	END
	CLOSE Rcur_dig02
	deallocate Rcur_dig02
	

	


	-- ********************   ARRUMAR SITUAÇÕES PARA SAGEM    -  EXCLUSAO

	-- ***************  NOVO
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA EXCLUSAO E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A EXCLUSAO (status '4')
	DECLARE Rcur_troubleExc1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG101 
			WHERE STATUS = '4'
		)
	OPEN Rcur_troubleExc1
	FETCH NEXT FROM Rcur_troubleExc1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
	
		-- PROCURA POR TODOS OS EQUIPAMENTOS CUJA EXCLUSAO DE DIGITAL DESTA MATRICULA ESTEJA COM ESTADO '4'
		DECLARE Rcur_troubleExc2 CURSOR FOR 
			(SELECT END_IP from RDIG101 
				WHERE (IFUNC = @z_mat and STATUS = '4')
			)
		OPEN Rcur_troubleExc2
		FETCH NEXT FROM Rcur_troubleExc2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			--DELETE RDIG101 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')	-- vai excluir registro porque nao adianta reenviar 
			UPDATE RDIG101 set status = '0' WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')	-- vai alterar status porque nao adianta reenviar 

			UPDATE RDIG102 set status = '1' WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM Rcur_troubleExc2 INTO @z_endip
		END


		CLOSE Rcur_troubleExc2
		deallocate Rcur_troubleExc2

		FETCH NEXT FROM Rcur_troubleExc1 INTO @z_mat
	END
	
	CLOSE Rcur_troubleExc1
	deallocate Rcur_troubleExc1

	-- *************** FIM NOVO

	
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins Sagem para exclusao de biometria, se esses não estiverem com exclusao de biometria ou estiverem pendentes

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO  from RDIG101 
			--WHERE ( STATUS != '0' and STATUS != '2' and 
			WHERE ( STATUS != '0' and STATUS != '2' and STATUS != '4' and 
					(BIO_TIPO = '6' or BIO_TIPO = '7')
				  )
		)
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG102 set status = '1'
			WHERE (END_IP = @z_endip) and 
				--(STATUS = '0' or STATUS = '3') and 
				(STATUS = '0' or STATUS = '3' or STATUS = '4') and 
				(BIO_TIPO = '6' or BIO_TIPO = '7')

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1



	
	
	-- ********************   TRATA EQUIPAMENTOS SAGEM QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG102 
			WHERE ( (BIO_TIPO = '6' or BIO_TIPO = '7')
					and   
					(status = '5' or status = '6' or 													-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin

			UPDATE RDIG101 set status = '1'
				WHERE (END_IP = @z_endip and STATUS = '2' and BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')

			UPDATE RDIG102 set status = '1' 
					where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)
		end
		
		else if (@z_status = '5' OR @z_status = '6') begin
			UPDATE RDIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1



	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUAÇÃO
	-- para digitais de RDIG101 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.status from RDIG102 A 
			INNER JOIN RDIG101 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				(A.BIO_TIPO = '6' or A.BIO_TIPO = '7'))
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG101 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and (BIO_TIPO = '6' or BIO_TIPO = '7');
		UPDATE RDIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip AND (BIO_TIPO = '6' or BIO_TIPO = '7');

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status;
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1

	SET LOCK_TIMEOUT -1

GO

if object_id('TELESSVR.trata4_Reptsi1', 'p') is null
    exec ('create procedure TELESSVR.trata4_Reptsi1 as select 1')
go

ALTER PROCEDURE TELESSVR.trata4_Reptsi1 
AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)

DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000


	-- ********************   ARRUMAR SITUAÇÕES PARA TSI1    -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA  (status '4')
	DECLARE Rcur_troubleIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG003 
			WHERE STATUS = '4'
		)
	OPEN Rcur_troubleIns1
	FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE Rcur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from RDIG003 
				WHERE (IFUNC = @z_mat and STATUS = '4')
			)
		OPEN Rcur_troubleIns2
		FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			--DELETE RDIG003 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')
			UPDATE RDIG003 SET STATUS = '0' WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')

			UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip
		END


		CLOSE Rcur_troubleIns2
		deallocate Rcur_troubleIns2

		FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	END
	
	CLOSE Rcur_troubleIns1
	deallocate Rcur_troubleIns1



	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS TSI1 (DA TAB.CONTDIG_TSI1 CADASTRO)
	-- delete registro de RDIG003 se nao houver cadastro de BIO TSI1 desta matricula
	DECLARE Rcur_autoIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG003 
			WHERE STATUS = '3'
		)
	OPEN Rcur_autoIns1
	FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		-- VERIFICA SE HÁ CADASTRO DO BIO TSI1 DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_TSI1 WHERE ICARD = @z_mat;
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO TSI1 desta matricula
			DECLARE Rcur_autoIns2 CURSOR FOR 
				(SELECT END_IP from RDIG003 
					WHERE (IFUNC = @z_mat and STATUS = '3')
				)
			OPEN Rcur_autoIns2
			FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				DELETE RDIG003 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '3')

				UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip
			END


			CLOSE Rcur_autoIns2
			deallocate Rcur_autoIns2
		END

		FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat
	END
	
	CLOSE Rcur_autoIns1
	deallocate Rcur_autoIns1



	-- ******************** ALTERA STATUS DE TODOS OS CODINS PARA CARGA DE DIGITAIS, SE ESSES NÃO ESTIVEREM COM CARGA DE DIGITAIS OU ESTIVEREM PENDENTES
	-- nao altera status se o equipamento responde 'NAO IMPLEMENTADO'
	DECLARE Rcur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG003 
			--WHERE (STATUS != '0' and STATUS != '2' AND BIO_TIPO = '8')		-- biometrias pendentes na carga
			WHERE (STATUS != '0' and STATUS != '2' and STATUS != '4' AND 
				   BIO_TIPO = '8')		-- biometrias pendentes na carga
		)
	OPEN Rcur_endip
	FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status 
	
	while @@fetch_status != -1
	begin
		IF (@z_status != '4') begin
			UPDATE RDIG002 set status = '1'
				WHERE (END_IP = @z_endip and 
						--(STATUS = '0' or STATUS= '3') and 
						(STATUS = '0' or STATUS= '3' or STATUS= '4') and 		-- status '0':carregado, '3':pendente, '4':rep nao aceita carga digital
						BIO_TIPO = @z_biotipo)
		end
		FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_endip
	deallocate Rcur_endip



	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos TSI1 q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos TSI1 q tiveram carga de aplicativo 
	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from RDIG002 
			WHERE ((BIO_TIPO = '8')
					and 
				   (status = '5' or status = '6' or 		-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())) 
				  )
		)
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status

	WHILE @@fetch_status != -1
	begin
		-- OBSERVACAO: PARA BIOMETRIA TSI1, A CARGA DE APLICATIVO NO EQUIPAMENTO NAO APAGA AS BIOMETRIAS, POIS BIOMETRIA TSI1 FICA NO LEITOR E NAO NO EQUIPAMENTO,
		-- LOGO NAO É NECESSARIO FAZER A RECARGA DE BIOMETRIA
		IF (@z_status = '2') begin		-- situação q estava fazendo a carga e deu problema

			UPDATE RDIG003 set STATUS = '1'			-- status = 1 : a carregar
				WHERE (END_IP = @z_endip and STATUS = '2'  and BIO_TIPO = @z_biotipo) 

			UPDATE RDIG002 set status = '1' 
				where (END_IP = @z_endip and BIO_TIPO = @z_biotipo)
		end

		ELSE begin
			IF (@z_status = '5' OR @z_status = '6') begin		-- HOUVE CARGA DE APLICATIVO, MAS NAO VAI RECARREGAR AS BIOMETRIAS
				UPDATE RDIG002 set status = '0' 
					WHERE (end_ip = @z_endip  and BIO_TIPO = @z_biotipo)
			end
		end
		
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end

	CLOSE Rcur_dig02
	DEALLOCATE Rcur_dig02
	


	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUAÇÃO
	-- para BIOMETRIAS  TSI1 DE RDIG003 que ficaram em estado carregando '2', e o equipamento está em estado de repouso	, forca o equipamento a carrega-lo novamente

	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.status from RDIG002 A 
			INNER JOIN RDIG003 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = '8')
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG003 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' AND BIO_TIPO = '8';
		UPDATE RDIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip  and BIO_TIPO = '8';
			
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status;
	END
	CLOSE Rcur_dig02
	deallocate Rcur_dig02
	


	-- ********************   ARRUMAR SITUAÇÕES PARA   TSI1   -  EXCLUSAO
	-- ********************* NOVO	
	-- ***********************  TRATA AS BIOMETRIAS SAGEM QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A EXCLUSAO  (status '4')
	DECLARE Rcur_troubleExc1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG103 
			WHERE STATUS = '4'
		)
	OPEN Rcur_troubleExc1
	FETCH NEXT FROM Rcur_troubleExc1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		
		DECLARE Rcur_troubleExc2 CURSOR FOR 
			(SELECT END_IP from RDIG103 
				WHERE (IFUNC = @z_mat and STATUS = '4')
			)
		OPEN Rcur_troubleExc2
		FETCH NEXT FROM Rcur_troubleExc2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			--DELETE RDIG103 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')
			UPDATE RDIG103 SET STATUS = '0' WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')

			UPDATE RDIG102 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM Rcur_troubleExc2 INTO @z_endip
		END


		CLOSE Rcur_troubleExc2
		deallocate Rcur_troubleExc2

		FETCH NEXT FROM Rcur_troubleExc1 INTO @z_mat
	END
	
	CLOSE Rcur_troubleExc1
	deallocate Rcur_troubleExc1


	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins Sagem para exclusao de biometria, se esses não estiverem com exclusao de biometria ou estiverem pendentes

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO from RDIG103 
			--WHERE (STATUS != '0' and STATUS != '2' and BIO_TIPO = '8')
			WHERE (STATUS != '0' and STATUS != '2' and STATUS != '4' and BIO_TIPO = '8')		-- statys 4 indica resposta do rep de nao implementado
		)
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG102 set STATUS = '1'
			WHERE (END_IP = @z_endip) and 
			  	  --(STATUS = '0' or STATUS = '3') and 
			  	  (STATUS = '0' or STATUS = '3' or STATUS = '4') and 		-- statys 4 indica resposta do rep de nao implementado
				  (BIO_TIPO = '8')

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1
	


	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG102 
			WHERE ( (BIO_TIPO = '8')
					and   
					(status = '5' or status = '6' or 													-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip,  @z_biotipo, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE RDIG103 set status = '1'
				WHERE (END_IP = @z_endip) and (status = '2') and (BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')

			UPDATE RDIG102 set status = '1' 
				WHERE (END_IP = @z_endip  and BIO_TIPO = @z_biotipo)
		end
				
		else if (@z_status = '5' OR @z_status = '6') begin
			UPDATE RDIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;
				
		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1



	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUAÇÃO
	-- para digitais de RDIG103 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.status from RDIG102 A 
			INNER JOIN RDIG103 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = '8')
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG103 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and BIO_TIPO = '8';
		UPDATE RDIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip and BIO_TIPO = '8';
	
		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status;
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1

	SET LOCK_TIMEOUT -1
	
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.trata3_RepOutrosBios', 'p') is null
    exec ('create procedure TELESSVR.trata3_RepOutrosBios as select 1')
go

ALTER PROCEDURE TELESSVR.trata3_RepOutrosBios 
AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)

DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000


	-- ********************   ARRUMAR SITUAÇÕES PARA VIRDI / OUTRAS BIOS   -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS  QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA  (status '4')
	DECLARE Rcur_troubleIns1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG004 
			WHERE STATUS = '4'
		)
	OPEN Rcur_troubleIns1
	FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE Rcur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from RDIG004 
				WHERE (IFUNC = @z_mat and STATUS = '4')
			)
		OPEN Rcur_troubleIns2
		FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			--DELETE RDIG004 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')
			UPDATE RDIG004 SET STATUS = '0' WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')

			UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM Rcur_troubleIns2 INTO @z_endip
		END


		CLOSE Rcur_troubleIns2
		deallocate Rcur_troubleIns2

		FETCH NEXT FROM Rcur_troubleIns1 INTO @z_mat
	END
	
	CLOSE Rcur_troubleIns1
	deallocate Rcur_troubleIns1


	-- ***********************  TRATA AS BIOMETRIAS VIRDI QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS VIRDI (DA TAB.CONTDIG_OUTROS CADASTRO)
	-- delete registro de RDIG004 se nao houver cadastro de BIO VIRDI desta matricula
	
	DECLARE Rcur_autoIns1 CURSOR FOR 
		(SELECT distinct IFUNC, BIO_TIPO from RDIG004 
			WHERE STATUS = '3'
		)
	OPEN Rcur_autoIns1
	FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat, @z_biotipo
	WHILE (@@fetch_status != -1) BEGIN
		
		-- VERIFICA SE HÁ CADASTRO DO BIO VIRDI DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_OUTROS WHERE ICARD = @z_mat and BIO_TIPO = @z_biotipo;
		
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO VIRDI desta matricula
			
			DECLARE Rcur_autoIns2 CURSOR FOR 
				(SELECT END_IP from RDIG004 
					WHERE (IFUNC = @z_mat and STATUS = '3' and BIO_TIPO = @z_biotipo)
				)
			OPEN Rcur_autoIns2
			FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				DELETE RDIG004 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '3')

				UPDATE RDIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM Rcur_autoIns2 INTO @z_endip
			END


			CLOSE Rcur_autoIns2
			deallocate Rcur_autoIns2
		END

		FETCH NEXT FROM Rcur_autoIns1 INTO @z_mat, @z_biotipo
	END
	
	CLOSE Rcur_autoIns1
	deallocate Rcur_autoIns1



	-- ******************** ALTERA STATUS DE TODOS OS CODINS PARA CARGA DE DIGITAIS, SE ESSES NÃO ESTIVEREM COM CARGA DE DIGITAIS OU ESTIVEREM PENDENTES
	-- nao altera status se o equipamento responde 'NAO IMPLEMENTADO'
	DECLARE Rcur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG004 
			--WHERE (STATUS != '0' and STATUS != '2' AND BIO_TIPO = '9')		-- biometrias pendentes na carga
			WHERE (STATUS != '0' and STATUS != '2' )		-- biometrias pendentes na carga
		)
	OPEN Rcur_endip
	FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status 
	
	while @@fetch_status != -1
	begin
		IF (@z_status != '4') begin
			UPDATE RDIG002 set status = '1'
				WHERE (END_IP = @z_endip and 
						--(STATUS = '0' or STATUS= '3') and 
						(STATUS = '0' or STATUS= '3' or STATUS= '4') and 		-- status '0':carregado, '3':pendente, '4':rep nao aceita carga digital
						BIO_TIPO = @z_biotipo)
		end
		FETCH NEXT FROM Rcur_endip INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_endip
	deallocate Rcur_endip



	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos VIRDI q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos VIRDI q tiveram carga de aplicativo 
	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from RDIG002 
			WHERE (((BIO_TIPO != '6') and (BIO_TIPO != '7') and (BIO_TIPO != '8')) 
					and 
				   (status = '5' or status = '6' or		-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())) 
				  )
		)
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status

	WHILE @@fetch_status != -1
	begin
		-- OBSERVACAO: PARA BIOMETRIA VIRDI, A CARGA DE APLICATIVO NO EQUIPAMENTO NAO APAGA AS BIOMETRIAS, POIS BIOMETRIA VIRDI FICA NO LEITOR E NAO NO EQUIPAMENTO,
		-- LOGO NAO É NECESSARIO FAZER A RECARGA DE BIOMETRIA
		IF (@z_status = '2') begin		-- situação q estava fazendo a carga e deu problema

			UPDATE RDIG004 set STATUS = '1'			-- status = 1 : a carregar
				WHERE (END_IP = @z_endip and STATUS = '2'  and BIO_TIPO = @z_biotipo) 

			UPDATE RDIG002 set status = '1' 
				where (END_IP = @z_endip and BIO_TIPO = @z_biotipo)
		end

		ELSE begin
			IF (@z_status = '5' OR @z_status = '6') begin		-- HOUVE CARGA DE APLICATIVO, MAS NAO VAI RECARREGAR AS BIOMETRIAS
				UPDATE RDIG002 set status = '0' 
					WHERE (end_ip = @z_endip  and BIO_TIPO = @z_biotipo)
			end
		end
		
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end

	CLOSE Rcur_dig02
	DEALLOCATE Rcur_dig02
	


	-- ***********************  TRATA AS BIOMETRIAS VIRDI QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUAÇÃO
	-- para BIOMETRIAS  VIRDI DE RDIG004 que ficaram em estado carregando '2', e o equipamento está em estado de repouso	, forca o equipamento a carrega-lo novamente

	DECLARE Rcur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.status, A.BIO_TIPO from RDIG002 A 
			INNER JOIN RDIG004 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = B.BIO_TIPO)
	OPEN Rcur_dig02
	FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG004 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' AND BIO_TIPO = @z_biotipo;
		UPDATE RDIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip  and BIO_TIPO = @z_biotipo;
			
		FETCH NEXT FROM Rcur_dig02 INTO @z_endip, @z_status, @z_biotipo;
	END
	CLOSE Rcur_dig02
	deallocate Rcur_dig02
	


	-- ********************   ARRUMAR SITUAÇÕES PARA   VIRDI   -  EXCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS  QUE FICARAM PENDENTES NA EXCLUSAO E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A EXCLUSAO  (status '4')
	DECLARE Rcur_troubleExc1 CURSOR FOR 
		(SELECT distinct IFUNC from RDIG104 
			WHERE STATUS = '4'
		)
	OPEN Rcur_troubleExc1
	FETCH NEXT FROM Rcur_troubleExc1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		
		DECLARE Rcur_troubleExc2 CURSOR FOR 
			(SELECT END_IP from RDIG104 
				WHERE (IFUNC = @z_mat and STATUS = '4')
			)
		OPEN Rcur_troubleExc2
		FETCH NEXT FROM Rcur_troubleExc2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			--DELETE RDIG104 WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')
			UPDATE RDIG104 SET STATUS = '0' WHERE (END_IP = @z_endip and IFUNC = @z_mat and STATUS = '4')

			UPDATE RDIG102 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM Rcur_troubleExc2 INTO @z_endip
		END


		CLOSE Rcur_troubleExc2
		deallocate Rcur_troubleExc2

		FETCH NEXT FROM Rcur_troubleExc1 INTO @z_mat
	END
	
	CLOSE Rcur_troubleExc1
	deallocate Rcur_troubleExc1


	-- ***********************  TRATA AS BIOMETRIAS VIRDI QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins VIRDI para exclusao de biometria, se esses não estiverem com exclusao de biometria ou estiverem pendentes

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO from RDIG104 
			--WHERE (STATUS != '0' and STATUS != '2' and BIO_TIPO = '9')
			WHERE (STATUS != '0' and STATUS != '2' and STATUS != '4')		-- statys 4 indica resposta do rep de nao implementado
		)
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG102 set STATUS = '1'
			WHERE (END_IP = @z_endip) and 
			  	  --(STATUS = '0' or STATUS = '3') and 
			  	  (STATUS = '0' or STATUS = '3' or STATUS = '4') and 		-- statys 4 indica resposta do rep de nao implementado
				  (BIO_TIPO = @z_biotipo)

		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1
	


	-- ********************   TRATA EQUIPAMENTOS VIRDI QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from RDIG102 
			WHERE (((BIO_TIPO != '6') and (BIO_TIPO != '7') and (BIO_TIPO != '8')) 
					and   
					(status = '5' or status = '6' or 														-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip,  @z_biotipo, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE RDIG104 set status = '1'
				WHERE (END_IP = @z_endip) and (status = '2') and (BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')

			UPDATE RDIG102 set status = '1' 
				WHERE (END_IP = @z_endip  and BIO_TIPO = @z_biotipo)
		end
				
		else if (@z_status = '5' or @z_status = '6') begin
			UPDATE RDIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;
				
		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1



	-- ***********************  TRATA AS BIOMETRIAS VIRDI QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUAÇÃO
	-- para digitais de RDIG104 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE Rcur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.status, A.BIO_TIPO from RDIG102 A 
			INNER JOIN RDIG104 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = B.BIO_TIPO)
	OPEN Rcur_autoExc1
	FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE RDIG104 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and BIO_TIPO = @z_biotipo;
		UPDATE RDIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip and BIO_TIPO = @z_biotipo;
	
		FETCH NEXT FROM Rcur_autoExc1 INTO @z_endip, @z_status, @z_biotipo;
	END
	CLOSE Rcur_autoExc1
	deallocate Rcur_autoExc1

	SET LOCK_TIMEOUT -1
	
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.P_RepGerDigital4', 'p') is null
    exec ('create procedure TELESSVR.P_RepGerDigital4 as select 1')
go

ALTER PROCEDURE TELESSVR.P_RepGerDigital4  @nQtd INT
AS

DECLARE @ret CHAR(1)


	SET DATEFORMAT YMD


	set @ret = 0
	
	-- prepara automatico digitais sagem RDIG001 / RDIG101
	exec TELESSVR.AntePrep3_RSagem	@nQtd
	
	-- prepara automatico digitais tsi1 RDIG003 / RDIG103
	exec TELESSVR.AntePrep3_RTsi1 @nQtd	

	-- prepara automatico digitais virdi E OUTROS RDIG004 / RDIG104
	exec TELESSVR.AntePrep2_ROutrosBios @nQtd


	--exec TELESSVR.Prep_RepDigit3 @nQtd
	exec TELESSVR.Prep_RepDigit4 @nQtd


	-- trata biometria sagem
	--exec TELESSVR.trata3_RepSagem	
	exec TELESSVR.trata4_RepSagem	

	-- trata biometria tsi1
	--exec TELESSVR.trata3_RepTsi1		
	exec TELESSVR.trata4_RepTsi1		
	
	-- trata biometria virdi/outros
	--exec TELESSVR.trata2_RepOutrosBios		
	exec TELESSVR.trata3_RepOutrosBios		
	
	
	select @ret
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

-----------------------------------------------------------------------------
-- CONEX REP V.08.00.09 || CONEX REP V.08.00.09 || CONEX REP V.08.00.09 || --
-----------------------------------------------------------------------------

-- OBS: HOUVE ALTERACAO SOMENTE NA APLICACAO DO CONEX


-----------------------------------------------------------------------------
-- CONEX REP V.08.01.01 || CONEX REP V.08.01.01 || CONEX REP V.08.01.01 || --
-----------------------------------------------------------------------------


/* *********** DAT08REP *********** */

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DAT08REP_IND1')
    DROP INDEX TELESSVR.DAT08REP.DAT08REP_IND1;
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DAT08REP_IND2')
    DROP INDEX TELESSVR.DAT08REP.DAT08REP_IND2;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'DAT08REP' AND UPPER(COLUMN_NAME) = 'LACES')
    ALTER TABLE TELESSVR.DAT08REP ALTER COLUMN  LACES     CHAR(5)
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'DAT08REP' AND UPPER(COLUMN_NAME) = 'PLANTA')
    ALTER TABLE TELESSVR.DAT08REP ALTER COLUMN  PLANTA	 CHAR(5) 
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DAT08REP_IND1')
    CREATE UNIQUE INDEX DAT08REP_IND1 ON TELESSVR.DAT08REP (GRUPO, LACES, PLANTA);
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'DAT08REP_IND2')
    CREATE UNIQUE INDEX DAT08REP_IND2 ON TELESSVR.DAT08REP (GRUPO, LACES, PLANTA);
GO


/* *********** DAT07 *********** */
ALTER TABLE TELESSVR.DAT07 drop constraint bio_tipo1;
ALTER TABLE TELESSVR.DAT07 with nocheck add constraint bio_tipo1 CHECK (BIO_TIPO IN ('0','1','2','3','4','5', '6', '7','8', '9','A','C'));
GO



-- *****************   TABELA CONTDIG_OUTROS  (CADASTRO BIOMETRIAS  )

IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTDIG_OUTROS' AND UPPER(COLUMN_NAME) = 'DIGITALBIN_PAD')
    ALTER TABLE TELESSVR.CONTDIG_OUTROS ADD DIGITALBIN_PAD VARBINARY(MAX)
GO

IF NOT EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'CONTDIG_OUTROS' AND UPPER(COLUMN_NAME) = 'DIGITALBIN_ALT')
    ALTER TABLE TELESSVR.CONTDIG_OUTROS ADD DIGITALBIN_ALT VARBINARY(MAX)
GO

ALTER TABLE TELESSVR.CONTDIG_OUTROS DROP CONSTRAINT  digoutros_TPDIG;
ALTER TABLE TELESSVR.CONTDIG_OUTROS with nocheck add CONSTRAINT digoutros_TPDIG CHECK (BIO_TIPO IN ('9','C'))	-- C=suprema Iso ViaV
GO




-- ************************ REPVIAV001 ******************
IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'REPVIAV001')
	BEGIN
		CREATE TABLE TELESSVR.REPVIAV001 (
			REP		CHAR(17)	NOT NULL,
			IDENT		CHAR(14)	NOT NULL CONSTRAINT repviav001_01 CHECK (IDENT not like '%[^0-9]%'),
			STATUS	CHAR(1)		DEFAULT '0' NOT NULL  CONSTRAINT repviav001_02 CHECK (STATUS IN ('0','1','2')) -- 0=a validar, 1=alarme, 2=tratado
		)
	END
GO

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'REPVIAV001_IND1')
    DROP INDEX TELESSVR.REPVIAV001.REPVIAV001_IND1;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'REPVIAV001_IND1')
    CREATE UNIQUE INDEX REPVIAV001_IND1 ON TELESSVR.REPVIAV001 (REP);
GO


if object_id('TELESSVR.sqlratu_binarybios', 'p') is null
    exec ('create procedure TELESSVR.sqlratu_binarybios as select 1')
go

ALTER PROCEDURE TELESSVR.sqlratu_binarybios @matric VARCHAR(12), @cBioTipo CHAR(1), @nTipoPadAlt CHAR(1), @cTemplate VARCHAR(MAX), @tam INT
AS
DECLARE @cAuxMat VARCHAR(12)
DECLARE @cTemplBin VARBINARY(MAX)
DECLARE @nRetorno int
	

	SET @cTemplBin = CONVERT(varbinary(max), @cTemplate, @tam);

    set @nRetorno = 1
    IF NOT EXISTS (SELECT ICARD FROM CONTDIG_OUTROS WHERE ICARD = @matric and BIO_TIPO = @cBioTipo) BEGIN 			-- identificador  do biometrico 
		set @nRetorno = 0
	END


    IF (@nRetorno = 0) BEGIN		-- nao ha nenhum cadastro do ICARD+BIOTIPO
    	IF (@nTipoPadAlt = '0')		-- padrao
				INSERT INTO CONTDIG_OUTROS (ICARD, BIO_TIPO, DIGITALBIN_PAD, STATUS, STATUS_REP)  
					VALUES (@matric, @cBioTipo, @cTemplBin, '1', '1')
		ELSE IF (@nTipoPadAlt = '1')	-- alternativo
				INSERT INTO CONTDIG_OUTROS (ICARD, BIO_TIPO, DIGITALBIN_ALT, STATUS, STATUS_REP)  
					VALUES (@matric, @cBioTipo, @cTemplBin,'1', '1')

		IF (@@ROWCOUNT = 0)
			set @nRetorno = 0
	END

	ELSE begin							-- ha cadastrao da digital, vai atualizar
    	IF (@nTipoPadAlt = '0') 			-- Padrao
			UPDATE CONTDIG_OUTROS 
				SET DIGITALBIN_PAD = @cTemplBin, 
					Status = '1',
					Status_Rep = '1' 
				WHERE Icard = @matric AND 				-- matricula
			  		  BIO_TIPO = @cBioTipo; 					-- identificador  do biometrico 
		ELSE IF (@nTipoPadAlt = '1')		-- Alternativo
			UPDATE CONTDIG_OUTROS 
				SET DIGITALBIN_ALT = @cTemplBin, 
					Status = '1',
					Status_Rep = '1' 
				WHERE Icard = @matric AND 				-- matricula
					  BIO_TIPO = @cBioTipo; 					-- identificador  do biometrico 
		IF (@@ROWCOUNT = 0)
			set @nRetorno = 0
	end
	
    return @nRetorno

	
	SET LOCK_TIMEOUT -1
	


SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqlrnivel_biomet2', 'p') is null
    exec ('create procedure TELESSVR.sqlrnivel_biomet2 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlrnivel_biomet2 @cEndIp CHAR(15), @cBlueb CHAR(2), @cCodin CHAR(2) AS

DECLARE @cBioTipo AS CHAR(1)

DECLARE @Retfun SMALLINT, @Pad int, @Alt int, @cNivel char(2)

	set @cBioTipo = '0'
	set @cNivel = '2'

	IF EXISTS (SELECT * FROM DAT07 WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
	begin
	   	SELECT @cBioTipo = BIO_TIPO 
		FROM DAT07
		WHERE END_IP = @cEndIp and 
			  BLUEB = @cBlueb and 
			  CODIN = @cCodin

		IF ((@cBioTipo = '4') or (@cBioTipo = '5')) begin
			IF EXISTS (SELECT *	FROM GEOMOK001 
						WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
				SELECT @cNivel = NIVEL
					FROM GEOMOK001
					WHERE END_IP = @cEndIp and 
						  BLUEB = @cBlueb and 
						  CODIN = @cCodin
			ELSE
				SET @cNivel = '4'
			end
		ELSE begin 
			IF ((@cBioTipo = '6') or (@cBioTipo = '7') or (@cBioTipo = '9')) begin
				IF EXISTS (SELECT *	FROM GEOMOK001 
							WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
					SELECT @cNivel = NIVELSAG
						FROM GEOMOK001
						WHERE END_IP = @cEndIp and 
							  BLUEB = @cBlueb and 
							  CODIN = @cCodin
				ELSE
					SET @cNivel = '5'
			end
			ELSE begin
				IF ((@cBioTipo = '8') or (@cBioTipo = 'C')) begin
					IF EXISTS (SELECT *	FROM GEOMOK001 
								WHERE END_IP = @cEndIp and BLUEB = @cBlueb and CODIN = @cCodin)
						SELECT @cNivel = NIVEL
							FROM GEOMOK001
							WHERE END_IP = @cEndIp and 
								  BLUEB = @cBlueb and 
								  CODIN = @cCodin
					ELSE
						SET @cNivel = '3'
				end
			end
		end
	end
	
	SET @Retfun = convert(int, @cNivel)
		
	SELECT @cBioTipo, @Retfun
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqlrproc_binarybios', 'p') is null
    exec ('create procedure TELESSVR.sqlrproc_binarybios as select 1')
go

ALTER PROCEDURE TELESSVR.sqlrproc_binarybios @cMatric char(12), @cEndIp char(15), @cNumRep char(17),
@nQtdBytes INT, @cBioTipo CHAR(1)


AS
DECLARE @Retfun int, @Pad int, @Alt int, @nTotal int, @i int, @tam int, @pos int, @cVDigit char(1), @cDigPadChar VARCHAR(MAX), @cDigAltChar VARCHAR(MAX)

DECLARE @Ret INT, @nTotalPad INT , @nTotalAlt INT , @nTamPad INT, @nTamAlt INT
DECLARE @cDigPadBin VARBINARY(MAX), @cDigAltBin VARBINARY(MAX)



BEGIN
	SET @Retfun = 3
	SET @Pad = 0
	SET @Alt = 0
	
	SET @nTotalPad = 0
	SET @nTotalAlt = 0
	
	SET @nTamPad = 0
	SET @nTamAlt = 0

	-- PROCURA PELO PADRAO
	IF EXISTS (SELECT * FROM CONTDIG_OUTROS  WHERE ICARD = @cMatric AND BIO_TIPO = @cBioTipo)		
	begin
		--SELECT @cDigPadBin = CONVERT(varbinary(max), DIGITAL_PAD, LEN(DIGITAL_PAD)), 
		--	   @cDigAltBin = CONVERT(varbinary(max), DIGITAL_ALT, LEN(DIGITAL_ALT)),
		--	   @nTamPad = LEN(DIGITAL_PAD),
		--	   @nTamAlt = LEN(DIGITAL_ALT)
		--	FROM CONTDIG_OUTROS  WHERE ICARD = @cMatric AND BIO_TIPO = @cBioTipo

		SELECT @cDigPadBin = DIGITALBIN_PAD, 
			   @cDigAltBin = DIGITALBIN_ALT,
			   @nTamPad = LEN(DIGITALBIN_PAD),
			   @nTamAlt = LEN(DIGITALBIN_ALT)
			FROM CONTDIG_OUTROS  WHERE ICARD = @cMatric AND BIO_TIPO = @cBioTipo


		IF (@nTamPad IS NULL) 
			SET @nTotalPad = 0
		ELSE begin
			SET @nTotalPad = @nTamPad
			SET @Pad = 1
		end
		
		IF (@nTamAlt IS NULL) 
			SET @nTotalAlt = 0
		ELSE begin
			SET @nTotalAlt = @nTamAlt
			SET @Alt = 1				
		end
	end
	-- PREPARA RESULTADO	
	if (@Pad = 1) begin
	    if (@Alt = 1) 
			SET @Retfun = 0;   -- tem padrao e tem alternativo
		else 
			SET @Retfun = 1;   -- tem padrao e nao tem alternativo
	end 
	if (@Pad = 0) begin
	    if (@Alt = 1) 
			SET @Retfun = 2;   -- nao tem padrao e tem alternativo
		else 
			SET @Retfun = 3;   -- nao tem padrao e nao tem alternativo
	end
	
    IF (@Retfun = 3)		-- digital nao cadastrado
    	INSERT INTO REPDIGLOAD001 (END_IP, REP, IFUNC, BIO_TIPO, DATA_INS) 
			VALUES (@cEndIp, @cNumRep, @cMatric, '9', getdate());
	
	
	SELECT @Retfun, @cDigPadBin, @cDigAltBin, @nTotalPad, @nTotalAlt	
	    
	
END
GO

if object_id('TELESSVR.sqlrperm_ConxViaV', 'p') is null
    exec ('create procedure TELESSVR.sqlrperm_ConxViaV as select 1')
go

ALTER PROCEDURE TELESSVR.sqlrperm_ConxViaV @cNumRep CHAR(17), @cCnpjEqpto CHAR(14)
AS

DECLARE @Ret int
DECLARE @cCnpjTab CHAR(20)
DECLARE @cStatus CHAR(1)

	
	SET @Ret = 1			-- assume que tem permissao de conexao
	
	
	IF EXISTS (select * from REPVIAV001 WHERE REP = @cNumRep)
	begin
		SELECT @cCnpjTab = IDENT, @cStatus = STATUS 
			FROM REPVIAV001 
			WHERE REP = @cNumRep 
			
		IF (@cStatus = '0') begin
			
			-- valida Num.Rep e CNPJ provenientes do Rep com o que está cadastrado
			IF (@cCnpjEqpto != @cCnpjTab) begin
				UPDATE REPVIAV001 SET STATUS = '1' WHERE REP = @cNumRep
				SET @Ret = 0
			end
		end			
		
		ELSE IF (@cStatus = '1') begin 		-- JA ESTA ALARMADO E NAO FOI TRATADO
			SET @Ret = 0
		end
		
		ELSE IF (@cStatus = '2') begin		-- FOI TRATADO, ENTAO VAI PERMITIR CONEXAO PARA POSSIVEL ALTERACAO DE CNPJ DO EQUIPAMENTO
			UPDATE REPVIAV001 SET STATUS = '0' WHERE REP = @cNumRep
			SET @Ret = 1
		end
	end		

	
	SELECT @Ret;

	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO





-----------------------------------------------------------------------------
-- Inclusion date:  04/02/2021 - 09:25
-- Change date:     04/02/2021 - 09:25
-- Sequence:        0069
-- Redmine:         @6761
-----------------------------------------------------------------------------

/*
{ 
  "database"    : "MSSQL",
  "owner"       : "TELESSVR",
  "type"        : "TRIGGER",
  "name"        : "SITCOLETOR_ALARME",
  "description" : "",
  "version"     : "1.0.4.2",
  "log"         : {
                    "1.0.4.2" : { "author" : "Alex Siqueira", "created" : "17/03/2021", "issue" : "@6761", "description" : "Versão 1.0.4.0 errada. Nas colunas HORACOLEALAR e HORAALAR os valores estão em SEGUNDO" },
					"1.0.4.0" : { "author" : "Alex Siqueira", "created" : "23/02/2021", "issue" : "@6761", "description" : "Gravar Hora em Minutos"}
                  }
}
*/
IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.SITCOLETOR_ALARME'))
	DROP TRIGGER TELESSVR.SITCOLETOR_ALARME
GO

CREATE TRIGGER TELESSVR.SITCOLETOR_ALARME ON TELESSVR.SITCOLETOR FOR UPDATE, INSERT AS
DECLARE
    @V_ALARME_OFF INTEGER = 302,
    @V_DATETIME DATETIME
BEGIN
--VERSION_CONTROL 1.0.4.2 VERSION_CONTROL

    SELECT @V_DATETIME = GETDATE()      
	
    INSERT INTO SURICATO.TBALARSTRATA
    (
        DATACOLEALAR,
        HORACOLEALAR,
        SEQUCOLEALAR,
        DATAALAR,
        HORAALAR,
        CODIPLAN,
        CODICOLE,
        CODISIND,
        TIPOALAR,
        STATALAR,
        DATARECOALAR,
        HORARECOALAR,
        USUARECECHAV,
        DESCRECOUSUA,
        TIPORECOREAL,
        ENDEENTRCOLE
    )
    SELECT 
        CONVERT(DATE, CONVERT( VARCHAR, @V_DATETIME, 101 ), 101),
        ( DATEPART(HOUR, @V_DATETIME ) * 60 * 60 ) + ( DATEPART(MINUTE, @V_DATETIME) * 60 ) + ( DATEPART(SECOND, @V_DATETIME) ),
        0,
        CONVERT(DATE, CONVERT( VARCHAR, @V_DATETIME, 101 ), 101),
        ( DATEPART(HOUR, @V_DATETIME ) * 60 * 60 ) + ( DATEPART(MINUTE, @V_DATETIME) * 60 ) + ( DATEPART(SECOND, @V_DATETIME) ),
        CODIPLAN,
        CODICOLE,
        @V_ALARME_OFF,
        CASE INSERTED.STATUS WHEN 0 THEN 1 ELSE 0 END,
        0,
        CONVERT(DATETIME,'12/31/1900 00:00:00', 101),
        0,
        NULL,
        '',
        NULL,
        NULL
      FROM
        SURICATO.TBCODIN
      INNER JOIN INSERTED ON
        NUMEENDECOLE = INSERTED.ENDIP
      INNER JOIN DELETED ON
        NUMEENDECOLE = DELETED.ENDIP
      WHERE
        INSERTED.STATUS <> DELETED.STATUS
		
END
GO

 -----------------------------------------------------------------------------
-- Inclusion date:  03/02/2021 - 08:38
-- Change date:     03/02/2021 - 08:38
-- Sequence:        0188
-- Redmine:         @7132
-----------------------------------------------------------------------------

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'LISTA')
	BEGIN
		CREATE TABLE TELESSVR.LISTA
		(
			INCLUSAO   DATETIME DEFAULT CURRENT_TIMESTAMP,
			END_IP     VARCHAR(15) NOT NULL,
			ARQUIVO    VARCHAR(100) NOT NULL,
			LINHA      VARCHAR(100) NOT NULL
		)
	END
GO

IF NOT EXISTS(SELECT * FROM SYS.INDEXES WHERE UPPER(NAME) = 'INDEX1_LISTA')
	CREATE INDEX INDEX1_LISTA ON TELESSVR.LISTA (END_IP, ARQUIVO)
GO
IF NOT EXISTS(SELECT * FROM SYS.INDEXES WHERE UPPER(NAME) = 'INDEX2_LISTA')
	CREATE INDEX INDEX2_LISTA ON TELESSVR.LISTA (INCLUSAO)
GO

/*
{ 
  "database"    : "MSSQL",
  "owner"       : "TELESSVR",
  "type"        : "TRIGGER",
  "name"        : "CONTDIG_OUTROS_TBTEMPL",
  "description" : "TRIGGER DE ATUALIZAÇÃO E INCLUSÃO NA CONTDIG_OUTROS",
  "version"     : "1.0.5.0",
  "log"         : {
                   "1.0.5.0" : { "author" : "Alex Siqueira", "created" : "03/08/2020", "issue" : "@6574", "description" : "Gravar Blob para Blob"},
				   "1.0.4.0" : { "author" : "Alex Siqueira", "created" : "04/06/2019", "issue" : "@3585", "description" : "Suporte ao Sensor Biométrico VIRDI"}
                  }
}
*/

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID('TELESSVR.CONTDIG_OUTROS_TBTEMPL'))
  DROP TRIGGER TELESSVR.CONTDIG_OUTROS_TBTEMPL
GO

CREATE TRIGGER TELESSVR.CONTDIG_OUTROS_TBTEMPL ON TELESSVR.CONTDIG_OUTROS FOR INSERT, UPDATE
AS

BEGIN
--VERSION_CONTROL 1.0.5.0 VERSION_CONTROL

  DECLARE @L_ICARD CHAR(12)
  DECLARE @L_TITULAR VARBINARY(MAX)
  DECLARE @L_ALTERNATIVO VARBINARY(MAX)
  DECLARE @L_IDPESSOA NUMERIC(9,0)
  DECLARE @L_BIO_TIPO CHAR(1)


  IF UPPER( CURRENT_USER ) = 'SURICATO'
    RETURN;


  DECLARE CCONTDIG_OUTROS_TBTEMPL CURSOR
    FOR SELECT 
            ICARD, 
			DIGITALBIN_PAD, 
			DIGITALBIN_ALT, 
			BIO_TIPO
          FROM INSERTED

  OPEN CCONTDIG_OUTROS_TBTEMPL

  FETCH NEXT FROM CCONTDIG_OUTROS_TBTEMPL INTO @L_ICARD, @L_TITULAR, @L_ALTERNATIVO, @L_BIO_TIPO

  WHILE @@FETCH_STATUS = 0
  BEGIN
  
    SELECT @L_IDPESSOA = SURICATO.GETIDPESSOA( @L_ICARD )
    
    IF @L_IDPESSOA > 0
    BEGIN
    
      IF EXISTS ( SELECT 1 FROM SURICATO.TBTEMPL WHERE IDPESSOA = @L_IDPESSOA AND TIPOBIOM = @L_BIO_TIPO )
      BEGIN
        UPDATE SURICATO.TBTEMPL SET TEMPTITU1 = @L_TITULAR, TEMPALTE1 = @L_ALTERNATIVO WHERE IDPESSOA = @L_IDPESSOA AND TIPOBIOM = @L_BIO_TIPO
      END
      ELSE
      BEGIN
        INSERT INTO SURICATO.TBTEMPL( IDPESSOA, TEMPTITU1, QUALTEMPTITU, TEMPALTE1, QUALTEMPALTE, TIPOBIOM, STATUS ) SELECT @L_IDPESSOA, @L_TITULAR, 0,@L_ALTERNATIVO, 0, @L_BIO_TIPO, 1
      END
      
    END

    FETCH NEXT FROM CCONTDIG_OUTROS_TBTEMPL INTO @L_ICARD, @L_TITULAR, @L_ALTERNATIVO, @L_BIO_TIPO

  END
	
  CLOSE CCONTDIG_OUTROS_TBTEMPL
	
  DEALLOCATE CCONTDIG_OUTROS_TBTEMPL
  

END
GO

-----------------------------------------------------------------------------
-- Inclusion date:  29/01/2021 - 09:30
-- Change date:     29/01/2021 - 09:30
-- Sequence:        0189
-- Redmine:         @7211
-----------------------------------------------------------------------------


IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID('TELESSVR.TRG_INSERT_TBBIOAUTOM_BIOMET'))
	DROP TRIGGER TELESSVR.TRG_INSERT_TBBIOAUTOM_BIOMET
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID('TELESSVR.TRG_INSERT_TBBIOAUTOM_SAGEM'))
	DROP TRIGGER TELESSVR.TRG_INSERT_TBBIOAUTOM_SAGEM
GO

IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID('TELESSVR.TRG_INSERT_TBBIOAUTOM_OP4'))
	DROP TRIGGER TELESSVR.TRG_INSERT_TBBIOAUTOM_OP4
GO

-----------------------------------------------------------------------------
-- Inclusion date:  26/01/2021 - 09:38
-- Change date:     26/01/2021 - 09:38
-- Sequence:        0234
-- Redmine:         @6574
-----------------------------------------------------------------------------

/*
{ 
  "database"    : "MSSQL",
  "owner"       : "TELESSVR",
  "type"        : "TRIGGER",
  "name"        : "CONTDIG_OUTROS_TBTEMPL",
  "description" : "TRIGGER DE ATUALIZAÇÃO E INCLUSÃO NA CONTDIG_OUTROS",
  "version"     : "1.0.5.0",
  "log"         : {
                   "1.0.5.0" : { "author" : "Alex Siqueira", "created" : "03/08/2020", "issue" : "@6574", "description" : "Gravar Blob para Blob"},
				   "1.0.4.0" : { "author" : "Alex Siqueira", "created" : "04/06/2019", "issue" : "@3585", "description" : "Suporte ao Sensor Biométrico VIRDI"}
                  }
}
*/

IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE OBJECT_ID = OBJECT_ID('TELESSVR.CONTDIG_OUTROS_TBTEMPL'))
  DROP TRIGGER TELESSVR.CONTDIG_OUTROS_TBTEMPL
GO

CREATE TRIGGER TELESSVR.CONTDIG_OUTROS_TBTEMPL ON TELESSVR.CONTDIG_OUTROS FOR INSERT, UPDATE
AS

BEGIN
--VERSION_CONTROL 1.0.5.0 VERSION_CONTROL

  DECLARE @L_ICARD CHAR(12)
  DECLARE @L_TITULAR VARBINARY(MAX)
  DECLARE @L_ALTERNATIVO VARBINARY(MAX)
  DECLARE @L_IDPESSOA NUMERIC(9,0)
  DECLARE @L_BIO_TIPO CHAR(1)


  IF UPPER( CURRENT_USER ) = 'SURICATO'
    RETURN;


  DECLARE CCONTDIG_OUTROS_TBTEMPL CURSOR
    FOR SELECT 
            ICARD, 
			DIGITALBIN_PAD, 
			DIGITALBIN_ALT, 
			BIO_TIPO
          FROM INSERTED

  OPEN CCONTDIG_OUTROS_TBTEMPL

  FETCH NEXT FROM CCONTDIG_OUTROS_TBTEMPL INTO @L_ICARD, @L_TITULAR, @L_ALTERNATIVO, @L_BIO_TIPO

  WHILE @@FETCH_STATUS = 0
  BEGIN
  
    SELECT @L_IDPESSOA = SURICATO.GETIDPESSOA( @L_ICARD )
    
    IF @L_IDPESSOA > 0
    BEGIN
    
      IF EXISTS ( SELECT 1 FROM SURICATO.TBTEMPL WHERE IDPESSOA = @L_IDPESSOA AND TIPOBIOM = @L_BIO_TIPO )
      BEGIN
        UPDATE SURICATO.TBTEMPL SET TEMPTITU1 = @L_TITULAR, TEMPALTE1 = @L_ALTERNATIVO WHERE IDPESSOA = @L_IDPESSOA AND TIPOBIOM = @L_BIO_TIPO
      END
      ELSE
      BEGIN
        INSERT INTO SURICATO.TBTEMPL( IDPESSOA, TEMPTITU1, QUALTEMPTITU, TEMPALTE1, QUALTEMPALTE, TIPOBIOM, STATUS ) SELECT @L_IDPESSOA, @L_TITULAR, 0,@L_ALTERNATIVO, 0, @L_BIO_TIPO, 1
      END
      
    END

    FETCH NEXT FROM CCONTDIG_OUTROS_TBTEMPL INTO @L_ICARD, @L_TITULAR, @L_ALTERNATIVO, @L_BIO_TIPO

  END
	
  CLOSE CCONTDIG_OUTROS_TBTEMPL
	
  DEALLOCATE CCONTDIG_OUTROS_TBTEMPL
  

END
GO

-----------------------------------------------------------------------------
-- Inclusion date:  22/03/2021 - 10:00
-- Change date:     22/03/2021 - 10:10
-- Sequence:        0286
-- Redmine:         @9814, @9815
-----------------------------------------------------------------------------

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'LISTA')
	BEGIN
		CREATE TABLE TELESSVR.LISTA
		(
			INCLUSAO   DATETIME DEFAULT CURRENT_TIMESTAMP,
			END_IP     VARCHAR(15) NOT NULL,
			ARQUIVO    VARCHAR(100) NOT NULL,
			LINHA      VARCHAR(100) NOT NULL
		)
	END
GO

IF NOT EXISTS(SELECT * FROM SYS.INDEXES WHERE UPPER(NAME) = 'INDEX1_LISTA')
	CREATE INDEX INDEX1_LISTA ON TELESSVR.LISTA (END_IP, ARQUIVO)
GO
IF NOT EXISTS(SELECT * FROM SYS.INDEXES WHERE UPPER(NAME) = 'INDEX2_LISTA')
	CREATE INDEX INDEX2_LISTA ON TELESSVR.LISTA (INCLUSAO)
GO



-----------------------------------------------------------------------------
-- Inclusion date:  12/03/2021 - 09:00
-- Change date:     12/03/2021 - 09:00
-- Sequence:        0313
-- Redmine:         @6945 
-----------------------------------------------------------------------------

IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'LISTA')
	BEGIN
		CREATE TABLE TELESSVR.LISTA (
			INCLUSAO   DATE DEFAULT CURRENT_TIMESTAMP,
			END_IP     VARCHAR(15)  NOT NULL,
			ARQUIVO    VARCHAR(100) NOT NULL,
			LINHA      VARCHAR(100)  NOT NULL
		)
		CREATE INDEX INDEX1_LISTA ON TELESSVR.LISTA (END_IP ASC, ARQUIVO ASC)
	END
GO


-----------------------------------------------------------------------------------
-- 2.10.11.2 || 2.10.11.2 || 2.10.11.2 || 2.10.11.2 || 2.10.11.2 || 2.10.11.2 || --
-----------------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- CONEX REP V.08.02.05 || CONEX REP V.08.02.05 || CONEX REP V.08.02.05 || --
-----------------------------------------------------------------------------


-- *****************   LISTA  
IF NOT EXISTS (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE UPPER(TABLE_NAME) = 'LISTA')
	BEGIN
		CREATE TABLE TELESSVR.LISTA (
		  INCLUSAO DATETIME 	default getdate(),
		  END_IP   VARCHAR(15) not null,
		  ARQUIVO  VARCHAR(100) not null,
		  LINHA    VARCHAR(100) not null
		)
	END
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'LISTA_IND1')
    CREATE UNIQUE INDEX LISTA_IND1 on TELESSVR.LISTA (END_IP, ARQUIVO, LINHA)
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'LISTA_IND1')
    CREATE INDEX LISTA_IND2 on TELESSVR.LISTA (INCLUSAO)
GO

-- *****************   REPAUTOBIOF  

ALTER TABLE TELESSVR.REPAUTOBIOF drop constraint ct1_REPAUTOBIOF
ALTER TABLE TELESSVR.REPAUTOBIOF ADD CONSTRAINT ct1_REPAUTOBIOF CHECK ((QTD_FUNC >= 0) and (QTD_FUNC <= 10000))
GO

-- *****************   TMP_REPVRD001

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'TMP_REPVRD001_IND1')
    DROP INDEX TELESSVR.TMP_REPVRD001.TMP_REPVRD001_IND1;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'TMP_REPVRD001_IND1')
    CREATE UNIQUE INDEX TMP_REPVRD001_IND1 ON TELESSVR.TMP_REPVRD001 (IFUNC, END_IP, BIO_TIPO);
GO

-- *****************   TMP_REPVRD002 

IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'TMP_REPVRD002_IND1')
    DROP INDEX TELESSVR.TMP_REPVRD002.TMP_REPVRD002_IND1;
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'TMP_REPVRD002')
    CREATE UNIQUE INDEX TMP_REPVRD002_IND1 ON TELESSVR.TMP_REPVRD002 (IFUNC, END_IP, BIO_TIPO);
GO


if object_id('TELESSVR.sqlrep_autoIns4', 'p') is null
    exec ('create procedure TELESSVR.sqlrep_autoIns4 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlrep_autoIns4 @cEndIp CHAR(15), @nMax INT AS
declare @nTotal INT
declare @cStat001 char(1)
declare @IFUNC char(12)
declare @STATUS char(1)
--declare @cListaF VARCHAR(27000)
declare @cListaF VARCHAR(MAX)

	SET @nTotal = 0
	
	SET @cListaF = ''
	
	SET LOCK_TIMEOUT 5000
	-- procura pelo equipamento
	IF EXISTS (SELECT * FROM REPAUTO001 WITH (Index = REPAUTO001_IND1) WHERE END_IP = @cEndIp)
	BEGIN
	    SELECT @cStat001 = STATUS
			FROM REPAUTO001
			WHERE END_IP = @cEndIp

		IF (@cStat001 = '1') BEGIN
		
			UPDATE REPAUTO001 SET 
				STATUS = '2', 
				DATA_LOAD = getdate()
			WHERE END_IP = @cEndIp;
		
		
			DECLARE linsf001_cur CURSOR FOR
				SELECT TOP(@nMax) IFUNC, STATUS FROM REPAUTO011 
					--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
					WHERE END_IP = @cEndIp AND STATUS != '0' 
					order by IFUNC;

			open linsf001_cur
			fetch next from linsf001_cur into @IFUNC, @STATUS
			while (@@fetch_status != -1) and (@nTotal < @nMax) 
			
			begin
				SET @cListaF = @cListaF + @IFUNC
				--UPDATE REPAUTO011 set STATUS = '2' where current of linsf001_cur
				UPDATE REPAUTO011 set STATUS = '2' 
					where IFUNC = @IFUNC AND END_IP = @cEndIp
				set @nTotal = @nTotal + 1

				fetch next from linsf001_cur into @IFUNC, @STATUS
			end
			close linsf001_cur
			deallocate linsf001_cur
			
					
			IF (@nTotal = 0) 
				UPDATE REPAUTO001 SET STATUS = '0' WHERE END_IP = @cEndIp;
			ELSE 
				UPDATE REPAUTO001 SET 
					STATUS = '2', 
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;
		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaF as cListaF
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO



if object_id('TELESSVR.sqlrep_autoExc4', 'p') is null
    exec ('create procedure TELESSVR.sqlrep_autoExc4 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlrep_autoExc4  @cEndIp CHAR(15), @nMax INT AS

declare @nTotal INT
declare @cStat002 char(1)
declare @IFUNC char(12)
declare @STATUS char(1)
--declare @cListaF VARCHAR(250)
declare @cListaF VARCHAR(MAX)
declare @cBio CHAR(1);
declare @nQtdPendDig int;


	SET @nTotal = 0
    SET @cBio = '0';
    SET @nQtdPendDig = 0;
	
	SET @cListaF = ''

	SET LOCK_TIMEOUT 5000
	-- procura pelo equipamento
	IF EXISTS (SELECT 1 FROM REPAUTO002 WHERE END_IP = @cEndIp)
	BEGIN
	    SELECT @cStat002 = STATUS
			FROM REPAUTO002
			WHERE END_IP = @cEndIp

		IF (@cStat002 = '1') 
		BEGIN
			-- NOVO
			-- ANTES DE ENVIAR EXCLUSAO DE FUNCIONARIOS, DEVE-SE VERIFICAR SE HÁ EXCLUSAO DE DIGITAIS AINDA A SER FEITA EM RDIG10X
			BEGIN
				SET @cBio = (SELECT BIO_TIPO FROM DAT07 WHERE END_IP = @cEndIp)
			
				IF ((@cBio = '6') or (@cBio = '7')) 
					SELECT TOP(1) @nQtdPendDig = 1 FROM RDIG101 WHERE END_IP = @cEndIp AND STATUS <> '0' 
				ELSE IF (@cBio = '8') 
					SELECT TOP(1) @nQtdPendDig = 1 FROM RDIG103 WHERE END_IP = @cEndIp AND STATUS <> '0' 
				ELSE IF (@cBio <> '0') 
					SELECT TOP(1) @nQtdPendDig = 1 FROM RDIG104 WHERE END_IP = @cEndIp AND STATUS <> '0' 
				ELSE
					SET @nQtdPendDig = 0
			END 
		
			IF (@nQtdPendDig = 0)      	-- NAO HA EXCLUSAO DE DIGITAIS A FAZER, PODE EXCLUIR FUNCIONARIOS
			BEGIN
				UPDATE REPAUTO002 SET 
					STATUS = '2', 
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;

				DECLARE linsf002_cur CURSOR FOR
					SELECT TOP(@nMax) IFUNC, STATUS FROM REPAUTO012 
						--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
						WHERE END_IP = @cEndIp AND STATUS != '0'
						order by IFUNC;

				open linsf002_cur
				fetch next from linsf002_cur into @IFUNC, @STATUS
				while (@@fetch_status != -1) and (@nTotal < @nMax) 
				begin
					SET @cListaF = @cListaF + @IFUNC
					--UPDATE REPAUTO012 set STATUS = '2' where current of linsf002_cur
					UPDATE REPAUTO012 set STATUS = '2' where IFUNC = @IFUNC AND END_IP = @cEndIp
					set @nTotal = @nTotal + 1

					fetch next from linsf002_cur into @IFUNC, @STATUS
				end
				close linsf002_cur
				deallocate linsf002_cur

				IF (@nTotal = 0) 
					UPDATE REPAUTO002 SET STATUS = '0' WHERE END_IP = @cEndIp;
				ELSE 
					UPDATE REPAUTO002 SET 
						STATUS = '2', 
						DATA_LOAD = getdate()
					WHERE END_IP = @cEndIp;
			END
		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaF as cListaF
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


if object_id('TELESSVR.sqller_RautoLoadDigit5', 'p') is null
    exec ('create procedure TELESSVR.sqller_RautoLoadDigit5 as select 1')
go

ALTER PROCEDURE TELESSVR.sqller_RautoLoadDigit5  @cEndIp VARCHAR(15), @nMax INT  
AS

declare @nTotal int
declare @cStat002 char(1)
declare @cBio_Tipo char(1)
declare @ICARD varchar(12)
declare @OLD_ICARD varchar(12)
declare @STATUS char(1)
declare @cListaId VARCHAR(MAX)
declare @nQtdPendFun int

	SET @nTotal = 0
	SET @cListaId = ''
	SET @nQtdPendFun = 0

	--SET LOCK_TIMEOUT 5000

	-- procura pelo equipamento
	IF EXISTS (SELECT 1 FROM RDIG002  WHERE END_IP = @cEndIp and STATUS = '1')
	BEGIN
	    SELECT @cStat002 = STATUS, @cBio_Tipo = BIO_TIPO
			FROM RDIG002
			WHERE END_IP = @cEndIp

		IF (@cStat002 = '1') BEGIN
			-- NOVO
			-- ANTES DE ENVIAR CARGA DE LISTA BIOMETRIA, DEVE-SE VERIFICAR SE HÁ CARGA DE FUNCIONARIOS AINDA A SER FEITA EM REPAUTO011
			--SELECT TOP(1) @nQtdPendFun = 1 FROM REPAUTO011 WHERE END_IP = @cEndIp AND STATUS <> '0' 
			--IF (@nQtdPendFun = 0) BEGIN      	-- NAO TEM FUNCIONARIOS A SEREM CARREGADOS , pode enviar lista de biometria
			IF NOT EXISTS (SELECT 1 FROM REPAUTO011 WHERE END_IP = @cEndIp AND STATUS != '0' )
			BEGIN
				-- SAGEM
				IF (@cBio_Tipo = '6' or @cBio_Tipo = '7') BEGIN		
					DECLARE Rldigit_cur CURSOR FOR
						SELECT  TOP(@nMax) IFUNC, STATUS FROM RDIG001 
							--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
							WHERE END_IP = @cEndIp AND STATUS != '0' 
								order by IFUNC;

					open Rldigit_cur
					fetch next from Rldigit_cur into @ICARD, @STATUS
					while (@@fetch_status != -1) and (@nTotal < @nMax) 
					begin
						SET @cListaId = @cListaId + @ICARD
						SET @OLD_ICARD =  @ICARD

						-- COMO O CURSOR TEM O WHERE STATUS <> '2',
						-- ESTE UPDATE SERÁ COLOCADO APOS O FETCH , PARA NAO INTEFERIR NO CURSOR (NAO SEJA PROCESSADO NOVAMENTE DENTRO DO WHILE)
						--UPDATE RDIG001 set STATUS = '2' where current of Rldigit_cur
						set @nTotal = @nTotal + 1

						fetch next from Rldigit_cur into @ICARD, @STATUS
						-- ESTE UPDATE ESTÁ DEPOIS DO FETCH, MAS DENTRO DO WHILE PORQUE ESTÁ ALTERANDO CAMPO QUE FAZ PARTE DO REQUISITO DA CRIACAO DO CURSOR
						UPDATE RDIG001 set STATUS = '2' where IFUNC = @OLD_ICARD AND END_IP = @cEndIp
					end
					close Rldigit_cur
					deallocate Rldigit_cur
				END

				-- TSI1
				IF (@cBio_Tipo = '8') BEGIN		
					DECLARE Rldigit_cur CURSOR FOR
						SELECT TOP(@nMax) IFUNC, STATUS FROM RDIG003 
							WHERE (END_IP = @cEndIp) and (STATUS != '0') 
						ORDER by IFUNC;

					open Rldigit_cur
					fetch next from Rldigit_cur into @ICARD, @STATUS
					--while (@@fetch_status != -1) and (@nTotal < 200) 
					while (@@fetch_status != -1) and (@nTotal < @nMax) 
					begin
						SET @cListaId = @cListaId + @ICARD
						SET @OLD_ICARD =  @ICARD

						-- COMO O CURSOR TEM O WHERE STATUS <> '2',
						-- ESTE UPDATE SERÁ COLOCADO APOS O FETCH , PARA NAO INTEFERIR NO CURSOR (NAO SEJA PROCESSADO NOVAMENTE DENTRO DO WHILE)
						--UPDATE RDIG003 set STATUS = '2' where current of Rldigit_cur
						set @nTotal = @nTotal + 1

						fetch next from Rldigit_cur into @ICARD, @STATUS
						-- ESTE UPDATE ESTÁ DEPOIS DO FETCH, MAS DENTRO DO WHILE PORQUE ESTÁ ALTERANDO CAMPO QUE FAZ PARTE DO REQUISITO DA CRIACAO DO CURSOR
						UPDATE RDIG003 set STATUS = '2' where IFUNC = @OLD_ICARD AND END_IP = @cEndIp
					end
					close Rldigit_cur
					deallocate Rldigit_cur
				END

				-- VIRDI E OUTROS
				IF (@cBio_Tipo != '0') BEGIN		
					DECLARE Rldigit_cur CURSOR FOR
						SELECT TOP(@nMax) IFUNC, STATUS FROM RDIG004 
							--WHERE (END_IP = @cEndIp) and (STATUS != '0') and (STATUS != '2')
							WHERE (END_IP = @cEndIp) and (STATUS != '0') 
						ORDER by IFUNC;

					open Rldigit_cur
					fetch next from Rldigit_cur into @ICARD, @STATUS
					--while (@@fetch_status != -1) and (@nTotal < 200) 
					while (@@fetch_status != -1) and (@nTotal < @nMax) 
					begin
						SET @cListaId = @cListaId + @ICARD
						SET @OLD_ICARD =  @ICARD

						-- COMO O CURSOR TEM O WHERE STATUS <> '2',
						-- ESTE UPDATE SERÁ COLOCADO APOS O FETCH , PARA NAO INTEFERIR NO CURSOR (NAO SEJA PROCESSADO NOVAMENTE DENTRO DO WHILE)
						--UPDATE RDIG004 set STATUS = '2' where current of Rldigit_cur
						set @nTotal = @nTotal + 1

						fetch next from Rldigit_cur into @ICARD, @STATUS

						-- ESTE UPDATE ESTÁ DEPOIS DO FETCH, MAS DENTRO DO WHILE PORQUE ESTÁ ALTERANDO CAMPO QUE FAZ PARTE DO REQUISITO DA CRIACAO DO CURSOR
						UPDATE RDIG004 set STATUS = '2' where IFUNC = @OLD_ICARD AND END_IP = @cEndIp
					end
					close Rldigit_cur
					deallocate Rldigit_cur
				END


				IF (@nTotal = 0) 
					UPDATE RDIG002 SET STATUS = '0' WHERE END_IP = @cEndIp;
				ELSE 
					UPDATE RDIG002 SET 
						STATUS = '2',
						DATA_LOAD = getdate()
					WHERE END_IP = @cEndIp;
			END
		END
	END
	--SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaId as cListaId
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO
	
if object_id('TELESSVR.sqller_RautoExclDigit5', 'p') is null
    exec ('create procedure TELESSVR.sqller_RautoExclDigit5 as select 1')
go

ALTER PROCEDURE TELESSVR.sqller_RautoExclDigit5 @cEndIp VARCHAR(15), @nMax INT   
AS

declare @nTotal INT
declare @cStatus char(1)
declare @cBio_Tipo char(1)
declare @ICARD varchar(12)
declare @OLD_ICARD varchar(12)
declare @STATUS char(1)
declare @cListaId VARCHAR(MAX)

	SET @nTotal = 0
	SET @cListaId = ''

	SET LOCK_TIMEOUT 2000

	-- procura pelo equipamento
	IF EXISTS (SELECT * FROM RDIG102  WHERE END_IP = @cEndIp AND STATUS = '1')
	BEGIN
	    SELECT @cStatus = STATUS, @cBio_Tipo = BIO_TIPO
			FROM RDIG102 NOLOCK
			WHERE END_IP = @cEndIp

		IF (@cStatus = '1') BEGIN
			-- SAGEM
			IF (@cBio_Tipo = '6' or @cBio_Tipo = '7') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT TOP(@nMax) IFUNC, STATUS FROM RDIG101 
						--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
						WHERE END_IP = @cEndIp AND STATUS != '0'
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 200) 
				while (@@fetch_status != -1) and (@nTotal < @nMax) 
				begin
					SET @cListaId = @cListaId + @ICARD
					SET @OLD_ICARD =  @ICARD
					
					-- COMO O CURSOR TEM O WHERE STATUS <> '2',
					-- E ESTE UPDATE E´SET STATUS = 2, O UPDATE SERÁ COLOCADO APOS O FETCH , PARA NAO INTEFERIR NO CURSOR (NAO SEJA PROCESSADO NOVAMENTE DENTRO DO WHILE)
					--UPDATE RDIG101 set STATUS = '2' where current of Rldigit_cur
					set @nTotal = @nTotal + 1

					fetch next from Rldigit_cur into @ICARD, @STATUS
					UPDATE RDIG101 set STATUS = '2' where IFUNC = @OLD_ICARD AND END_IP = @cEndIp
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			-- TSI1	
			ELSE IF (@cBio_Tipo = '8') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT TOP(@nMax) IFUNC, STATUS FROM RDIG103 
						--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
						WHERE END_IP = @cEndIp AND STATUS != '0' 
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 200) 		-- no máximo 200
				while (@@fetch_status != -1) and (@nTotal < @nMax)
				begin
					SET @cListaId = @cListaId + @ICARD
					SET @OLD_ICARD =  @ICARD
					
					-- COMO O CURSOR TEM O WHERE STATUS <> '2',
					-- ESTE UPDATE SERÁ COLOCADO APOS O FETCH , PARA NAO INTEFERIR NO CURSOR (NAO SEJA PROCESSADO NOVAMENTE DENTRO DO WHILE)
					--UPDATE RDIG103 set STATUS = '2' where current of Rldigit_cur
					set @nTotal = @nTotal + 1

					fetch next from Rldigit_cur into @ICARD, @STATUS
					UPDATE RDIG103 set STATUS = '2' where IFUNC = @OLD_ICARD AND END_IP = @cEndIp
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END
			
			-- VIRDI	
			ELSE 
				--IF (@cBio_Tipo = '9') BEGIN		
				IF (@cBio_Tipo != '0') BEGIN		
				DECLARE Rldigit_cur CURSOR FOR
					SELECT TOP(@nMax) IFUNC, STATUS FROM RDIG104 
						--WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
						WHERE END_IP = @cEndIp AND STATUS != '0' 
							order by IFUNC;

				open Rldigit_cur
				fetch next from Rldigit_cur into @ICARD, @STATUS
				--while (@@fetch_status != -1) and (@nTotal < 200) 
				while (@@fetch_status != -1) and (@nTotal < @nMax) 
				begin
					SET @cListaId = @cListaId + @ICARD
					SET @OLD_ICARD =  @ICARD
					
					-- COMO O CURSOR TEM O WHERE STATUS <> '2',
					-- E ESTE UPDATE E´SET STATUS = 2, O UPDATE SERÁ COLOCADO APOS O FETCH , PARA NAO INTEFERIR NO CURSOR (NAO SEJA PROCESSADO NOVAMENTE DENTRO DO WHILE)
					--UPDATE RDIG104 set STATUS = '2' where current of Rldigit_cur
					set @nTotal = @nTotal + 1

					fetch next from Rldigit_cur into @ICARD, @STATUS
					UPDATE RDIG104 set STATUS = '2' where IFUNC = @OLD_ICARD AND END_IP = @cEndIp
				end
				close Rldigit_cur
				deallocate Rldigit_cur
			END

			
			IF (@nTotal = 0) 
				UPDATE RDIG102 SET STATUS = '0' WHERE END_IP = @cEndIp;
			ELSE 
				UPDATE RDIG102 SET 
					STATUS = '2',
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;

		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaId as cListaId
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO
	

if object_id('TELESSVR.sqlproc_PisNome3', 'p') is null
    exec ('create procedure TELESSVR.sqlproc_PisNome3 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlproc_PisNome3 @cEndIp CHAR(15), @nMax int, @cUltPis CHAR(12), @cTipoCarga CHAR(1)
AS
DECLARE @nTotal int
DECLARE @cPis CHAR(12), @cNome VARCHAR(52)
DECLARE @cLisPis VARCHAR(MAX)
DECLARE @cLisNome VARCHAR(MAX)

	SET LOCK_TIMEOUT 5000

	SET @nTotal = 0

	SET @cLisPis = ''
	SET @cLisNome = ''



	-- cursor para PIX X NOME 
	--DECLARE cur_PisNome CURSOR FOR select  PIS, NOME from REPAUXEMPR WHERE END_IP = @cEndIp AND TIPO = @cTipoCarga AND PIS > @cUltPis order by PIS  
	DECLARE cur_PisNome CURSOR FOR select  DISTINCT TOP (@nMax) PIS, NOME from REPAUXEMPR WHERE END_IP = @cEndIp AND TIPO = @cTipoCarga AND PIS > @cUltPis order by PIS  

	OPEN cur_PisNome
	FETCH NEXT FROM cur_PisNome INTO @cPis, @cNome
	WHILE (@@fetch_status != -1) and (@nTotal < @nMax) 
	begin

		SET @cLisPis  = @cLisPis + @cPis
		SET @cLisNome = @cLisNome + @cNome + ';'
		SET	@nTotal = @nTotal + 1
		
		FETCH NEXT FROM cur_PisNome INTO @cPis, @cNome
	end
	CLOSE cur_PisNome
	DEALLOCATE cur_PisNome

	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal,
		@cLisPis, 
		@cLisNome 

	GO
			

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


if object_id('TELESSVR.sqlrep_fimExcAuto5A', 'p') is null
    exec ('create procedure TELESSVR.sqlrep_fimExcAuto5A as select 1')
go

ALTER PROCEDURE TELESSVR.sqlrep_fimExcAuto5A  @cEndIp CHAR(15), @cStat CHAR(1) AS

declare @nCont smallint
declare @nErr smallint
declare @Aux char(12)
declare @IFUNC char(12)
declare @STATUS char(1)
declare @cNovoStat char(1)
declare @cStInc char(1)


	SET LOCK_TIMEOUT 5000
	SET @nCont = 0
	SET @nErr = 0
	SET @cNovoStat = @cStat
	
	DECLARE lexcf002_cur CURSOR FOR
				SELECT IFUNC, STATUS FROM REPAUTO012 
					WHERE END_IP = @cEndIp AND STATUS = '2'
					order by IFUNC;

	open lexcf002_cur
	fetch next from lexcf002_cur into @IFUNC, @STATUS
	while (@@fetch_status != -1)
	begin
		-- NOVO : EXCLUI LINHA SE FICOU COM STATUS '0'
		IF (@cStat = '0') BEGIN
			--INSERT INTO HISTREPFUN (IFUNC, END_IP, INSEXC, MODO)	VALUES (@IFUNC, @cEndIp, 'E', 'A');		-- TIPO:'I'= INCLUSAO, 'E'=EXCLUSAO; MODO:'A'=AUTOMATICO, 'M'=MANUAL
			DELETE REPAUTO012 where IFUNC = @IFUNC AND END_IP = @cEndIp        --WHERE current of lexcf002_cur 
		END
		ELSE BEGIN
			--NOVO
			-- SE ESTIVER PENDENTE, DEVE VERIFICAR SE HÁ ALGUM COMANDO DE EXCLUSAO DESSE FUNCIONÁRIO PARA O EQUIPAMENTO A SER EXECUTADO.
			-- SE HOUVER, DEVE-SE IGNORAR ESTA PENDENCIA DE INCLUSAO E TORNA-LA STATUS '4', PARA QUE O GERENCIADOR DE CARGA AUTOMÁTICA ANULE ESTA PENDENCIA
			IF (@cStat = '3') BEGIN 
				SET @cStInc = null
				SET @cStInc = (SELECT STATUS  FROM REPAUTO011 
						WHERE IFUNC = @IFUNC and END_IP = @cEndIp  AND STATUS <> '0') 
				IF (@cStInc <> null)
					-- ENCONTROU COMANDO MAIS RECENTE DE INCLUSAO, ENTÃO NOVO VALOR DE 	REPAUTO012.STATUS SERÁ '4' PARA QUE ESTA CARGA SER DESCARTADA, E NÃO SERÁ TRATADA COMO PENDENCIA.					
					SET @cNovoStat = '4';
						
			END
			--FIM NOVO
		
			--update REPAUTO012 set STATUS = @cStat where current of lexcf002_cur 
			update REPAUTO012 set STATUS = @cNovoStat where current of lexcf002_cur 
		END			
			
		SET @nCont = @nCont+1
		-- fim NOVO

		fetch next from lexcf002_cur into @IFUNC, @STATUS
	end
	close lexcf002_cur
	deallocate lexcf002_cur
	
	IF EXISTS (select END_IP FROM REPLASTCOM WHERE END_IP = @cEndIp) 
		UPDATE REPLASTCOM SET DATA_INS = GETDATE() WHERE END_IP = @cEndIp;
	ELSE
		INSERT INTO REPLASTCOM (END_IP, DATA_INS) VALUES (@cEndIp, GETDATE());

	UPDATE REPAUTO002 SET STATUS = @cStat WHERE END_IP = @cEndIp;
	SET LOCK_TIMEOUT -1


	return @nCont	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqlrep_ExistLisTab', 'p') is null
    exec ('create procedure TELESSVR.sqlrep_ExistLisTab as select 1')
go

ALTER PROCEDURE TELESSVR.sqlrep_ExistLisTab @cEndIp CHAR(15), @cNomeArq VARCHAR(100), @cTipo CHAR(1)
AS

DECLARE @nTotal INT, @nCont INT

	SET @nTotal = 0
	SET @nCont = 0

	-- verifica se há dados na lista a serem enviados ao equipamento
	SELECT TOP(1) @nCont = 1 FROM LISTA WHERE END_IP = @cEndIp AND upper(ARQUIVO) = upper(@cNomeArq)

	IF (@nCont = 1) 
		IF (@cTipo = '1') 
			-- CONTA quantidade de linhas
			SET @nTotal = (SELECT count(*) FROM LISTA WHERE END_IP = @cEndIp AND upper(ARQUIVO) = upper(@cNomeArq) ) 			
			

	
	SELECT @nCont,
		   @nTotal

	GO
			

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


if object_id('TELESSVR.sqlrep_LeFuncTab', 'p') is null
    exec ('create procedure TELESSVR.sqlrep_LeFuncTab as select 1')
go

ALTER PROCEDURE TELESSVR.sqlrep_LeFuncTab @cEndIp CHAR(15), @cNomeArq VARCHAR(100), @cMatProc CHAR(12), @nMax INT
AS

DECLARE @nCont INT
DECLARE @cFunc CHAR(12)
DECLARE @cUltMat CHAR(12)
DECLARE @cListaMat VARCHAR(MAX)


DECLARE cur_lista CURSOR FOR 
	SELECT TOP (@nMax) LINHA from LISTA 
		WHERE END_IP = @cEndIp AND 
			  upper(ARQUIVO) = upper(@cNomeArq) AND 
			  LINHA > @cMatProc order by LINHA 
	
	SET @cListaMat = '';
	SET @cFunc = '';
	SET @nCont = 0;
	
	OPEN cur_lista
	FETCH NEXT FROM cur_lista INTO @cFunc

	WHILE (@@fetch_status != -1) and (@nCont < @nMax) 
	begin
		SET @cListaMat = @cListaMat + @cFunc
		SET	@nCont = @nCont + 1
		SET @cUltMat = @cFunc
		
		FETCH NEXT FROM cur_lista INTO @cFunc
	end

	CLOSE cur_lista
	DEALLOCATE cur_lista
	
	
	
	SELECT @nCont,
		   @cListaMat,
		   @cUltMat

	GO
			

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


if object_id('TELESSVR.Prep_RepAuto7', 'p') is null
    exec ('create procedure TELESSVR.Prep_RepAuto7 as select 1')
go

ALTER PROCEDURE TELESSVR.Prep_RepAuto7 @nQtd INT AS

DECLARE @nCont SMALLINT
DECLARE @nTemLocal SMALLINT
          
DECLARE @c_status CHAR(1)
DECLARE @c_ifunc CHAR(12)
DECLARE @c_endip CHAR(15)
DECLARE @c_grupo CHAR(5)

DECLARE @xc_status CHAR(1)
DECLARE @xc_ifunc CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @ret CHAR(1)

DECLARE @cAux CHAR(1)
DECLARE @cAux1 CHAR(1)
DECLARE @cTipo CHAR(1)
DECLARE @nContMax SMALLINT
--DECLARE @nQTD SMALLINT

SET DATEFORMAT YMD


	set @ret = 0
	--set @nQTD = 5 * @nTempo

	--SET LOCK_TIMEOUT 5000
	SET DATEFORMAT YMD
	
	
	-- *************** PREPARACAO DE INCLUSAO/EXCLUSAO  FUNCIONARIOS NOS EQUIPAMENTOS (MONTAGEM DAS TABELAS AUXILIARES)
	BEGIN
	
		-- tabela temporaria TMP_T :  TOP(N) linhas de REPNAUTO000 com solicitação de processamento de Inclusao ('3') e Exclusão ('8')
		--DELETE TMP_T;
		DELETE TMP_NREP001;
		DELETE TMP_NREP002;
		DELETE TMP_NREPGRPATV
		
		DECLARE cur_auto000 CURSOR FOR select top(@nQtd) IFUNC, STATUS, GRUPO 
			from REPNAUTO000 WHERE STATUS = '3' or STATUS = '8' ORDER BY DATA_INS, IFUNC

		SET @nContMax = 0

		OPEN cur_auto000
		FETCH NEXT FROM cur_auto000 INTO @c_ifunc, @c_status, @c_grupo
		
		WHILE (@@fetch_status != -1 AND @nContMax < @nQtd)
		BEGIN   
			SET @nTemLocal = 0
			
			DELETE TMP_NREP000GRP
			-- inclui em TMP_NREP000GRP TODOS OS REPS Q FAZEM PARTE DO GRUPO EM QUESTAO (NOVO OU VELHO) DO FUNCIONARIO
			insert into TMP_NREP000GRP (IFUNC, GRUPO, END_IP, STATUS)		
				select @c_ifunc,  @c_grupo, VIEWGRPREP.end_ip, @c_status
					from VIEWGRPREP
					where
						CAST(VIEWGRPREP.grupo AS INT) = CAST(@c_grupo AS INT)

			IF (@@ROWCOUNT != 0) BEGIN
				SET @nTemLocal = 1
			END
		
		
			IF (@nTemLocal = 1) 
			BEGIN
				-- Insere em tabela OS REGISTROS de TMP_NREP000GRP 
				IF (@c_status = '3') 
				BEGIN
					set @cTipo = '3'

					DECLARE Rtmp_eqptos cursor for 
						(SELECT END_IP from TMP_NREP000GRP  
							WHERE IFUNC = @c_ifunc and 
								  STATUS = @cTipo and  
								  CAST(Grupo AS INT) = CAST(@c_grupo AS INT))
							
					OPEN Rtmp_eqptos
					FETCH next from Rtmp_eqptos into @xc_endip
					WHILE @@fetch_status != -1
					BEGIN			
						/*
						SET @cAux = null
						SET @cAux = (SELECT STATUS from TMP_NREP001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
						IF (@cAux is null)  
						*/
						IF NOT EXISTS (SELECT 1 from TMP_NREP001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
							INSERT into TMP_NREP001 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo );


						-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE EXCLUSAO, PARA EXCLUIR
						/*
						SET @cAux = null
						SET @cAux = (SELECT STATUS from TMP_NREP002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
						IF (@cAux = '8') 
						*/
						IF EXISTS (SELECT 1 from TMP_NREP002 where IFUNC = @c_ifunc and END_IP = @xc_endip  and STATUS = '8')
							DELETE FROM TMP_NREP002 where IFUNC = @c_ifunc and END_IP = @xc_endip and STATUS = '8';
							
						-- **********************************************************************
						-- NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO
						-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE EXCLUSAO E ESTA PENDENTE
						SET @cAux = null
						SET @cAux = (SELECT STATUS from REPAUTO012 
										where IFUNC = @c_ifunc and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))
						
						IF (@cAux = '3')  
							UPDATE REPAUTO012 SET STATUS = '4' 							-- A EXCLUSAO QUE ESTÁ PENDENTE FICARA COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
								WHERE IFUNC = @c_ifunc and END_IP =@xc_endip;
						
						ELSE 
							IF (@cAux = '2')  		-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
							BEGIN
								-- PROCURA EM REPAUTO002 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
								/*
								SET @cAux1 = null
								SET @cAux1 = (SELECT STATUS FROM REPAUTO002 WHERE END_IP = @xc_endip  and  STATUS = '2' and DATEADD (SECOND, 30, DATA_LOAD) < getdate())											
								IF (@cAux1 = '2')					
								*/
								IF EXISTS (SELECT 1 FROM REPAUTO002 
											WHERE END_IP = @xc_endip  AND  
												  STATUS = '2' AND 
												  DATEADD (SECOND, 30, DATA_LOAD) < getdate())
									UPDATE REPAUTO012 SET STATUS = '4' 						-- sinaliza que REP NAO RESPONDEU AO COMANDO DE EXCLUSAO E FICARÁ COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
										WHERE IFUNC = @c_ifunc and END_IP = @xc_endip;
							END
							
						-- FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    
						-- **********************************************************************
			
						fetch next from Rtmp_eqptos into @xc_endip
					END 
					
					CLOSE Rtmp_eqptos
					DEALLOCATE Rtmp_eqptos
				END
			
				ELSE 
					IF (@c_status = '8') 
					BEGIN
						set @cTipo = '8'

						DELETE TMP_NREP000OUTROS;

						-- inclui em TMP_NREP000OUTROS TODOS OS REPS Q FAZEM PARTE De outros GRUPOs DO FUNCIONARIO
						/* ERRADO
						INSERT into TMP_NREP000OUTROS (IFUNC, GRUPO,  END_IP, STATUS)		
							select @c_ifunc, VIEWGRPREP.Grupo, VIEWGRPREP.end_ip, @c_status
								from VIEWGRPREP
								where
									(CAST(VIEWGRPREP.grupo AS INT) != CAST(@c_grupo AS INT)) and
									(CAST(VIEWGRPREP.grupo AS INT) in (select CAST(Grupo AS INT) from REPGRPF where IFUNC = @c_ifunc)) and 
									(CAST(VIEWGRPREP.grupo AS INT) not in (SELECT CAST(Grupo AS INT) FROM TMP_NREPGRPATV where IFUNC = @c_ifunc) ) ;
						*/

						INSERT into TMP_NREP000OUTROS (IFUNC, GRUPO,  END_IP, STATUS)		
							select @c_ifunc, VIEWGRPREP.Grupo, VIEWGRPREP.end_ip, @c_status
								from VIEWGRPREP, REPGRPF 
								where
									(REPGRPF.IFUNC = @c_ifunc) and 
									(CAST(REPGRPF.grupo AS INT) = CAST(VIEWGRPREP.grupo AS INT)) and
									(CAST(VIEWGRPREP.grupo AS INT) != CAST(@c_grupo AS INT)) and
									(CAST(VIEWGRPREP.grupo AS INT) not in (SELECT CAST(Grupo AS INT) FROM TMP_NREPGRPATV where IFUNC = @c_ifunc) ) ;

						set @nCont = @@ROWCOUNT

						DECLARE Rtmp_eqptos cursor for 
							(SELECT END_IP from TMP_NREP000GRP  
								WHERE IFUNC = @c_ifunc and 
									  STATUS = @cTipo and  
									  CAST(Grupo AS INT) = CAST(@c_grupo AS INT))

						OPEN Rtmp_eqptos
						FETCH next from Rtmp_eqptos into @xc_endip
						WHILE @@fetch_status != -1
						BEGIN
							/*
							SET @nCont = 0;
							SET @nCont = (SELECT count(*) FROM TMP_NREP000OUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
							IF (@nCont = 0)					
							*/
							IF NOT EXISTS ( SELECT 1 FROM TMP_NREP000OUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
							BEGIN	
								/*
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_NREP002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux is null)  
								*/
								-- INSERE FUNCIONARIO X IP EM LISTA DE EXCLUSAO
								IF NOT EXISTS (SELECT 1 from TMP_NREP002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
									INSERT into TMP_NREP002 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo );

								-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE INCLUSAO, PARA EXCLUIR
								IF EXISTS (SELECT 1 from TMP_NREP001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
									DELETE FROM TMP_NREP001 where IFUNC = @c_ifunc and END_IP = @xc_endip;		


								-- **********************************************************************
								-- NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  						
								-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE INCLUSAO E ESTA PENDENTE

								SET @cAux = null
								SET @cAux = (SELECT STATUS from REPAUTO011 
												where IFUNC = @c_ifunc and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))

								IF (@cAux = '3')  
									UPDATE REPAUTO011 SET STATUS = '4' 							-- A INCLUSAO QUE ESTÁ PENDENTE FICARA COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
										WHERE IFUNC = @c_ifunc and END_IP =@xc_endip;

								ELSE		-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DE EXECUTANDO E NAO OBTEVE RESPOSTA
									IF (@cAux = '2')  		-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
									BEGIN
										-- PROCURA EM REPAUTO001 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
										/*
										SET @cAux1 = null
										SET @cAux1 = (SELECT STATUS FROM REPAUTO001 WHERE END_IP = @xc_endip  and  STATUS = '2' and DATEADD (SECOND, 30, DATA_LOAD) < getdate())	
										IF (@cAux1 = '2')					
										*/
										IF EXISTS (SELECT 1 FROM REPAUTO001 WHERE END_IP = @xc_endip  and  STATUS = '2' and DATEADD (SECOND, 30, DATA_LOAD) < getdate())	
											UPDATE REPAUTO011 SET STATUS = '4' 						-- sinaliza que REP NAO RESPONDEU AO COMANDO DE INCLUSAO E FICARÁ COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
												WHERE IFUNC = @c_ifunc and END_IP = @xc_endip;
									END

								-- FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    
								-- **********************************************************************

							END
							fetch next from Rtmp_eqptos into @xc_endip
						END 
					
					CLOSE Rtmp_eqptos
					DEALLOCATE Rtmp_eqptos
			
					INSERT INTO TMP_NREPGRPATV (IFUNC, GRUPO) VALUES (@c_ifunc, @c_grupo)
					
				END
			END

			SET @nContMax = @nContMax + 1
			
			-- atualiza estado para tratado em REPNAUTO000, SE NÃO encontrou equipamento pertencente ao grupo e cai fora para tratar proximo funcionario
			UPDATE REPNAUTO000 SET STATUS = '0' 			
				WHERE IFUNC = @c_ifunc and CAST(Grupo AS INT) = CAST(@c_grupo AS INT)
			

			FETCH NEXT FROM cur_auto000 INTO @c_ifunc, @c_status, @c_grupo
		END
		
		CLOSE cur_auto000
		DEALLOCATE cur_auto000
	END
			

	-- ***************  TRATA OS IFUNCS INSERIDOS  ***************
	/*
	SET @nCont = (SELECT COUNT(*) FROM TMP_NREP001 WHERE STATUS = '3')
	IF (@nCont != 0) BEGIN
	*/
	IF EXISTS (SELECT 1 FROM TMP_NREP001 WHERE STATUS = '3')
	BEGIN
		-- ESTE BLOCO ABAIXO EU TIREI PORQUE O SQL_REPAUTOF() FARA ESTA PARTE DE INSERIR EM REPAUTO001 OS QUE NAO EXISTEM
		/*
		-- coloca o codin na tab. REPAUTO001 (CARGA LISTA) se eqpto  não existir
		insert into REPAUTO001 (END_IP, STATUS)
			select distinct end_ip, '0'
			from TMP_NREP001
			where  TMP_NREP001.STATUS = '3'	 and 
				TMP_NREP001.end_ip not in ( select end_ip from REPAUTO001 )
		
		*/
		
		-- insere ifunc-rep em tab. REPAUTO011, se não existir em tab.
		DECLARE cur_tmpauto000 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_NREP001 where STATUS = '3')
		OPEN cur_tmpauto000
		FETCH NEXT FROM cur_tmpauto000 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE REPAUTO011 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO REPAUTO011 (IFUNC, END_IP, STATUS) 
								values (@xc_ifunc, @xc_endip, '1');
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			IF EXISTS (SELECT 1 FROM REPAUTO012 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1' OR STATUS = '4'))	-- DELETA DA TABELA DE EXCLUSAO
				DELETE FROM REPAUTO012 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip 	-- DELETA DA TABELA DE EXCLUSAO

			FETCH NEXT FROM cur_tmpauto000 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpauto000
		DEALLOCATE cur_tmpauto000
	END

	
	-- ***************   TRATA OS IFUNCS EXCLUIDOS ***************
	/*
	SET @nCont = (SELECT COUNT(*) FROM TMP_NREP002 WHERE STATUS = '8')
	if (@nCont != 0) BEGIN
	*/
	
	IF EXISTS (SELECT 1 FROM TMP_NREP002 WHERE STATUS = '8')
	BEGIN
	
		-- ESTE BLOCO ABAIXO EU TIREI PORQUE O SQL_REPAUTOF() FARA ESTA PARTE DE INSERIR EM REPAUTO001 OS QUE NAO EXISTEM
		/*
		-- coloca o codin na tab. REPAUTO002 (EXCLUSAO) se o eqpto não existir
		INSERT INTO REPAUTO002 (END_IP, STATUS) 
			select distinct end_ip, '0'
			from TMP_NREP002
			where TMP_NREP002.STATUS = '8'	and 
				  TMP_NREP002.end_ip not in ( select end_ip from REPAUTO002 )
		*/				
	
		-- insere ifunc-rep em tab. REPAUTO012, se não existir em tab.
		DECLARE cur_tmpauto000 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_NREP002 where STATUS = '8')
		OPEN cur_tmpauto000
		FETCH NEXT FROM cur_tmpauto000 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE REPAUTO012 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO REPAUTO012 (IFUNC, END_IP, STATUS) 
								values (@xc_ifunc, @xc_endip, '1');
			end

			-- deleta o ifunc da tabela de inclusao para o rep especifico do grupo
			IF EXISTS (SELECT 1 FROM REPAUTO011 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1' OR STATUS = '4'))	-- DELETA DA TABELA DE INCLUSAO
				DELETE FROM REPAUTO011 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip 	-- DELETA DA TABELA DE INCLUSAO

			FETCH NEXT FROM cur_tmpauto000 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpauto000
		DEALLOCATE cur_tmpauto000
	
	END

	--SET LOCK_TIMEOUT -1
GO

if object_id('TELESSVR.SQL_REPAUTOF3', 'p') is null
    exec ('create procedure TELESSVR.SQL_REPAUTOF3 as select 1')
go

ALTER PROCEDURE TELESSVR.SQL_REPAUTOF3 AS

DECLARE @c_status CHAR(1)
DECLARE @c_icard CHAR(12)

DECLARE @xc_status CHAR(1)
DECLARE @xc_icard CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @xc_tipobio CHAR(1)
DECLARE @ret CHAR(1)

DECLARE @z_endip CHAR(15)
DECLARE @nQtdPend INT

SET DATEFORMAT YMD


	set @ret = 0
	SET @nQtdPend = 0
	
	--SET LOCK_TIMEOUT 5000

	--SELECT TOP(1) @nQtdPend = 1 FROM  REPNAUTO000 WHERE STATUS <> '0'
	--IF (@nQtdPend = 0) begin
	
	IF NOT EXISTS (SELECT 1 FROM  REPNAUTO000 WHERE STATUS <> '0')
	BEGIN
		-- VERIFICA SE HA FUNCIONARIOS A SEREM CARREGADOS
		BEGIN
			DECLARE cur_endip CURSOR FOR (
			select distinct A.END_IP 
				from REPAUTO011 A 
				WHERE (A.status != '0' and A.status != '2' and A.status != '4') AND				-- '4' = para resposta de nao implementado/sem resposta com sobreposicao comandos
					A.END_IP  NOT IN (SELECT END_IP FROM REPAUTO001 WHERE STATUS = '1') )
			OPEN cur_endip
			FETCH NEXT FROM cur_endip INTO @z_endip
			while @@fetch_status != -1
			begin
				IF NOT EXISTS (SELECT status FROM REPAUTO001 WHERE END_IP = @z_endip)
					insert into REPAUTO001 (END_IP, STATUS) VALUES (@z_endip, '1')

				ELSE
					UPDATE REPAUTO001 set status = '1'
						WHERE (end_ip = @z_endip and (status = '0' or status = '3' or status = '4'))			-- '4' = para resposta de nao implementado/sem resposta com sobreposicao comandos

				FETCH NEXT FROM cur_endip INTO @z_endip
			end
			CLOSE cur_endip
			deallocate cur_endip


		END


		-- VERIFICA SE HA FUNCIONARIOS A SEREM EXCLUIDOS
		BEGIN

			DECLARE cur_endip CURSOR FOR (
			select distinct A.END_IP 
						from REPAUTO012 A 
						WHERE (A.status != '0' and A.status != '2' and A.status != '4') AND
					A.END_IP  NOT IN (SELECT END_IP FROM REPAUTO002 WHERE STATUS = '1') )
			OPEN cur_endip
			FETCH NEXT FROM cur_endip INTO @z_endip
			while @@fetch_status != -1
			begin
				IF NOT EXISTS (SELECT status FROM REPAUTO002 WHERE END_IP = @z_endip)
					insert into REPAUTO002 (END_IP, STATUS) VALUES (@z_endip, '1')
				ELSE
					UPDATE REPAUTO002 set status = '1'
						WHERE (end_ip = @z_endip and (status = '0' or status = '3' or status = '4' ))


				FETCH NEXT FROM cur_endip INTO @z_endip
			end
			CLOSE cur_endip
			deallocate cur_endip

		END


		-- verifica se ha´equipamentos de REPAUTO001 com status '2' parados
		BEGIN
			DECLARE cur_endip CURSOR FOR (select distinct END_IP from REPAUTO001 where ((status = '2') and (DATEADD (MINUTE, 2, data_load)  < getdate())) )
			OPEN cur_endip
			FETCH NEXT FROM cur_endip INTO @z_endip
			while @@fetch_status != -1
			begin
				UPDATE REPAUTO011 set status = '1'
					WHERE (end_ip = @z_endip and status = '2')

				UPDATE REPAUTO001 set status = '1' 
						where ((end_ip = @z_endip ) and (status = '2') and (DATEADD (MINUTE, 2, data_load)  < getdate()) )

				FETCH NEXT FROM cur_endip INTO @z_endip
			end
			CLOSE cur_endip
			deallocate cur_endip
		END


		-- verifica se ha´equipamentos de REPAUTO002 com status '2' parados
		BEGIN
			DECLARE cur_endip CURSOR FOR (select distinct END_IP from REPAUTO002 where ((status = '2') and (DATEADD (MINUTE, 2, data_load)  < getdate())) )
			OPEN cur_endip
			FETCH NEXT FROM cur_endip INTO @z_endip
			while @@fetch_status != -1
			begin
				UPDATE REPAUTO012 set status = '1'
					WHERE (end_ip = @z_endip and status = '2')

				UPDATE REPAUTO002 set status = '1' 
						where ((end_ip = @z_endip ) and (status = '2') and (DATEADD (MINUTE, 2, data_load)  < getdate()) )

				FETCH NEXT FROM cur_endip INTO @z_endip
			end
			CLOSE cur_endip
			deallocate cur_endip
		END
	
	END

	--SET LOCK_TIMEOUT -1
	select @ret
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


if object_id('TELESSVR.Prep_RepDigit5', 'p') is null
    exec ('create procedure TELESSVR.Prep_RepDigit5 as select 1')
go

ALTER PROCEDURE TELESSVR.Prep_RepDigit5 @nQtd INT 
AS

DECLARE @nCont SMALLINT
DECLARE @nTemLocal SMALLINT
          
DECLARE @c_status CHAR(1)
DECLARE @c_ifunc CHAR(12)
DECLARE @c_endip CHAR(15)
DECLARE @c_grupo CHAR(5)
DECLARE @c_biotipo CHAR(1)

DECLARE @xc_status CHAR(1)
DECLARE @xc_ifunc CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @ret CHAR(1)
DECLARE @xc_biotipo CHAR(1)

DECLARE @cAux CHAR(1)
DECLARE @cAux1 CHAR(1)
DECLARE @cTipo CHAR(1)

SET DATEFORMAT YMD


	set @ret = 0

	--SET LOCK_TIMEOUT 5000
	
	-- *************** PREPARACAO DE INCLUSAO/EXCLUSAO  FUNCIONARIOS NOS EQUIPAMENTOS (MONTAGEM DAS TABELAS AUXILIARES)
	BEGIN
	
		DELETE TMP_TD;
		DELETE TMP_NREPGRPATV;
		
		DELETE TMP_REPSAG001
		DELETE TMP_REPSAG002
	
		DELETE TMP_REPSUP001
		DELETE TMP_REPSUP002
		
		DELETE TMP_REPVRD001
		DELETE TMP_REPVRD002
		
		-- tabela temporaria TMP_TD compostas de todas as linhas de REPNDIGAUTO000 com solicitação de processamento de Inclusao ('3') e Exclusão ('8')
		--INSERT INTO TMP_TD select top(@nQtd) IFUNC, STATUS, GRUPO, BIO_TIPO from REPNDIGAUTO000 WHERE STATUS = '3' or STATUS = '8' ORDER BY DATA_INS, IFUNC
		
		-- cursor para matriculas X GRUPOS a carregar/excluir
		DECLARE cur_autod000 CURSOR FOR select top(@nQtd) IFUNC, STATUS, GRUPO, BIO_TIPO from REPNDIGAUTO000 WHERE STATUS = '3' or STATUS = '8' ORDER BY DATA_INS, IFUNC

		OPEN cur_autod000
		FETCH NEXT FROM cur_autod000 INTO @c_ifunc, @c_status, @c_grupo, @c_biotipo
		
		WHILE @@fetch_status != -1
		BEGIN   
			SET @nTemLocal = 0
			DELETE FROM TMP_NREPDIGGRP
			
			-- VERIFICA SE VALOR DE REPNDIGAUTO000.BIO_TIPO tem valor '0'.
			-- SE VALOR '0', indica que a preparacao das tabelas é para todos tipo de biometria
			-- SE VALOR é específico para TIPO DE LEITOR BIO, só vai ENTRAR EM tab. TMP_NREPDIGGRP os equipamentos dessa biometria

			IF (@c_biotipo = '0') BEGIN
				-- inclui em TMP_NREPDIGGRP TODOS OS REPS Q FAZEM PARTE DO GRUPO EM QUESTAO (NOVO OU VELHO) DO FUNCIONARIO 
				insert into TMP_NREPDIGGRP (IFUNC, GRUPO, END_IP, STATUS, BIO_TIPO)		
					--select distinct @c_ifunc,  @c_grupo, VIEWGRPREP.end_ip, @c_status, VIEWGRPREP.BIO_TIPO
					select @c_ifunc,  @c_grupo, VIEWGRPREP.end_ip, @c_status, VIEWGRPREP.BIO_TIPO
						from VIEWGRPREP
						where
							CAST(VIEWGRPREP.grupo AS INT) = CAST(@c_grupo AS INT) and
							((VIEWGRPREP.bio_tipo != '0') AND (VIEWGRPREP.bio_tipo != 'A'));
			END
			ELSE BEGIN
				insert into TMP_NREPDIGGRP (IFUNC, GRUPO, END_IP, STATUS, BIO_TIPO)		
					--select distinct @c_ifunc,  @c_grupo, VIEWGRPREP.end_ip, @c_status, @c_biotipo
					select @c_ifunc,  @c_grupo, VIEWGRPREP.end_ip, @c_status, @c_biotipo
						from VIEWGRPREP
						where
							CAST(VIEWGRPREP.grupo AS INT) = CAST(@c_grupo AS INT) and
							VIEWGRPREP.bio_tipo = @c_biotipo
				
			END			
			
			
			IF (@@ROWCOUNT != 0) BEGIN
				SET @nTemLocal = 1
			END
		
		
			IF (@nTemLocal = 1) BEGIN
				-- Insere em tabela OS REGISTROS de TMP_NREPDIGGRP 
				IF (@c_status = '3') BEGIN		-- INCLUINDO
					set @cTipo = '3'

					DECLARE Rtmp_digeqptos cursor for (SELECT END_IP, BIO_TIPO from TMP_NREPDIGGRP  
						WHERE IFUNC = @c_ifunc and 
							STATUS = @cTipo and  
							CAST(Grupo AS INT) = CAST(@c_grupo AS INT) )
							
					OPEN Rtmp_digeqptos
					FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					WHILE @@fetch_status != -1
					BEGIN
						-- trata equipamento SAGEM
						IF (@xc_biotipo = '6' or @xc_biotipo = '7') 
						begin
							SET @cAux = null
							SET @cAux = (SELECT STATUS FROM TMP_REPSAG001 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
							IF (@cAux  is null) 
								INSERT into TMP_REPSAG001 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo);
							ELSE
								IF (@cAux = '0') 
									UPDATE TMP_REPSAG001 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip;
							
						end

						ELSE begin
							-- trata equipamento SUPREMA
							IF (@xc_biotipo = '8') begin
								SET @cAux = null
								SET @cAux = (SELECT STATUS FROM TMP_REPSUP001 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
								IF (@cAux  is null) 
									INSERT into TMP_REPSUP001 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo);
								ELSE
									IF (@cAux = '0') 
										UPDATE TMP_REPSUP001 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip;
							end											
							
							ELSE begin
								-- trata equipamento VIRDI /e outros
								IF (@xc_biotipo != 'A') 		-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
								begin
									-- trata equipamento VIRDI / OUTROS
									SET @cAux = null
									SET @cAux = (SELECT STATUS FROM TMP_REPVRD001 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip AND BIO_TIPO = @xc_biotipo)
									IF (@cAux  is null) 
										INSERT into TMP_REPVRD001 (IFUNC, END_IP, BIO_TIPO, STATUS)	VALUES  (@c_ifunc, @xc_endip, @xc_biotipo, @cTipo);
									ELSE
										IF (@cAux = '0') 
											UPDATE TMP_REPVRD001 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip and BIO_TIPO = @xc_biotipo;
								end
							end
						end													
							
						-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE EXCLUSAO, PARA EXCLUIR
						-- SAGEM
						IF (@xc_biotipo = '6' or @xc_biotipo = '7') begin
							--SET @cAux = null
							--SET @cAux = (SELECT STATUS from TMP_REPSAG002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
							--IF (@cAux = '8') 
							IF EXISTS (SELECT 1 from TMP_REPSAG002 where IFUNC = @c_ifunc and END_IP = @xc_endip AND STATUS = '8')
								DELETE FROM TMP_REPSAG002 where IFUNC = @c_ifunc and END_IP = @xc_endip;
						end

						-- SUPREMA
						ELSE IF (@xc_biotipo = '8') begin
							--SET @cAux = null
							--SET @cAux = (SELECT STATUS from TMP_REPSUP002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
							--IF (@cAux = '8') 
							IF EXISTS (SELECT 1 from TMP_REPSUP002 where IFUNC = @c_ifunc and END_IP = @xc_endip AND STATUS = '8')
								DELETE FROM TMP_REPSUP002 where IFUNC = @c_ifunc and END_IP = @xc_endip;
						end

						-- VIRDI / OUTROS
						ELSE 
							IF (@xc_biotipo != 'A') begin	-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
								--SET @cAux = null
								--SET @cAux = (SELECT STATUS from TMP_REPVRD002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								--IF (@cAux = '8') 
								IF EXISTS (SELECT 1 from TMP_REPVRD002 where IFUNC = @c_ifunc and END_IP = @xc_endip AND BIO_TIPO = @xc_biotipo  AND STATUS = '8')
									DELETE FROM TMP_REPVRD002 where IFUNC = @c_ifunc and END_IP = @xc_endip  AND BIO_TIPO = @xc_biotipo
							end
						
						
						-- **********************************************************************
						-- NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  						
						-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE EXCLUSAO E ESTA PENDENTE

						-- SAGEM
						IF (@xc_biotipo = '6' or @xc_biotipo = '7') BEGIN
							SET @cAux = null
							SET @cAux = (SELECT STATUS FROM RDIG101
								WHERE IFUNC = @c_ifunc and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))

							IF (@cAux = '3') 		-- SITUAÇÃO PENDENTE 
								UPDATE RDIG101 SET STATUS = '4' 							-- A EXCLUSAO QUE ESTÁ PENDENTE FICARA COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
									WHERE IFUNC = @c_ifunc  and END_IP = @xc_endip;

							ELSE BEGIN
								IF (@cAux = '2') BEGIN	 	-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
									-- PROCURA EM RDIG102 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
									SET @cAux1 = null
									SET @cAux1 = (SELECT STATUS from RDIG102 
										where END_IP = @xc_endip and 
											  STATUS = '2' and 
											  (DATEADD (SECOND, 30, DATA_LOAD) < getdate()) AND	
											  ((BIO_TIPO = '6') OR (BIO_TIPO = '7')))		-- O COMANDO FOI FEITO HA MAIS DE 30 SEGUNDOS
												  
									IF (@cAux1 != null)
										UPDATE RDIG101 SET STATUS = '4' 						-- sinaliza que REP NAO RESPONDEU AO COMANDO DE EXCLUSAO E FICARÁ COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
											WHERE IFUNC = @c_ifunc and END_IP = @xc_endip;

								END
							END
						END			

						-- SUPREMA
						ELSE IF (@xc_biotipo = '8') 
						BEGIN
							SET @cAux = null
							SET @cAux = (SELECT STATUS FROM RDIG103
								WHERE IFUNC = @c_ifunc and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))

							IF (@cAux = '3') 		-- SITUAÇÃO PENDENTE 
								UPDATE RDIG103 SET STATUS = '4' 							-- A EXCLUSAO QUE ESTÁ PENDENTE FICARA COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
									WHERE IFUNC = @c_ifunc  and END_IP = @xc_endip;

							ELSE BEGIN
								IF (@cAux = '2') BEGIN   			-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
									-- PROCURA EM RDIG102 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
									SET @cAux1 = null
									SET @cAux1 = (SELECT STATUS from RDIG102 
										where END_IP = @xc_endip and 
											  STATUS = '2' and 
											  (DATEADD (SECOND, 30, DATA_LOAD) < getdate()) AND	
											  (BIO_TIPO = '8'))		-- O COMANDO FOI FEITO HA MAIS DE 30 SEGUNDOS
									IF (@cAux1 != null)
										UPDATE RDIG103 SET STATUS = '4' 						-- sinaliza que REP NAO RESPONDEU AO COMANDO DE EXCLUSAO E FICARÁ COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
											WHERE IFUNC = @c_ifunc and END_IP = @xc_endip;

								END
							END			
						END							
								

						-- OUTRAS BIOMETRIAS
						ELSE IF (@xc_biotipo != 'A') 
						BEGIN
							SET @cAux = null
							SET @cAux = (SELECT STATUS FROM RDIG104
								WHERE IFUNC = @c_ifunc AND BIO_TIPO = @xc_biotipo and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))

							IF (@cAux = '3') 		-- SITUAÇÃO PENDENTE 
								UPDATE RDIG104 SET STATUS = '4' 							-- A EXCLUSAO QUE ESTÁ PENDENTE FICARA COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
									WHERE IFUNC = @c_ifunc  AND BIO_TIPO = @xc_biotipo and END_IP = @xc_endip;

							ELSE BEGIN
								IF (@cAux = '2') BEGIN				-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
									-- PROCURA EM RDIG102 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
									SET @cAux1 = null
									SET @cAux1 = (SELECT STATUS from RDIG102 
										where END_IP = @xc_endip and 
											  STATUS = '2' and 
											  (DATEADD (SECOND, 30, DATA_LOAD) < getdate()) AND	
											  ((BIO_TIPO != '6') and (BIO_TIPO != '7') and (BIO_TIPO != '8') and (BIO_TIPO != 'A'))) 		-- O COMANDO FOI FEITO HA MAIS DE 30 SEGUNDOS
									IF (@cAux1 != null)
										UPDATE RDIG104 SET STATUS = '4' 						-- sinaliza que REP NAO RESPONDEU AO COMANDO DE EXCLUSAO E FICARÁ COM ESTADO DE IGNORADA E NAO SERÁ MAIS EXECUTADA
											WHERE IFUNC = @c_ifunc AND BIO_TIPO = @xc_biotipo and END_IP = @xc_endip;

								END			
							END
						END
						
						-- FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    
						-- **********************************************************************
								
						FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					END 
					
					CLOSE Rtmp_digeqptos
					DEALLOCATE Rtmp_digeqptos
				END
							
			
				ELSE IF (@c_status = '8') BEGIN		-- EXCLUINDO
					set @cTipo = '8'

					DELETE FROM TMP_NREPDIGOUTROS;
					IF (@c_biotipo = '0') BEGIN
						-- inclui em TMP_NREPDIGOUTROS TODOS OS REPS Q FAZEM PARTE De outros GRUPOs DO FUNCIONARIO
						INSERT into TMP_NREPDIGOUTROS (IFUNC, GRUPO,  END_IP, BIO_TIPO, STATUS)		
							select @c_ifunc, VIEWGRPREP.Grupo, VIEWGRPREP.end_ip, VIEWGRPREP.bio_tipo, @c_status
								from VIEWGRPREP, REPGRPF
								where
									(REPGRPF.ifunc = @c_ifunc) and
									(CAST(VIEWGRPREP.grupo AS INT) = CAST(REPGRPF.grupo AS INT)) and
									(CAST(VIEWGRPREP.grupo AS INT) != CAST(@c_grupo AS INT)) and
									(CAST(VIEWGRPREP.grupo AS INT) not in (SELECT CAST(Grupo AS INT) FROM TMP_NREPDIGATV where IFUNC = @c_ifunc) ) and 
									((VIEWGRPREP.bio_tipo != '0') AND (VIEWGRPREP.bio_tipo != 'A'));
					END
					ELSE BEGIN
						INSERT into TMP_NREPDIGOUTROS (IFUNC, GRUPO,  END_IP, BIO_TIPO, STATUS)		
							select distinct @c_ifunc, VIEWGRPREP.Grupo, VIEWGRPREP.end_ip, @c_biotipo, @c_status
								from VIEWGRPREP, REPGRPF
								where
									(REPGRPF.ifunc = @c_ifunc) and
									(CAST(VIEWGRPREP.grupo AS INT) = CAST(REPGRPF.grupo AS INT)) and
									(CAST(VIEWGRPREP.grupo AS INT) != CAST(@c_grupo AS INT)) and
									(CAST(VIEWGRPREP.grupo AS INT) not in (SELECT CAST(Grupo AS INT) FROM TMP_NREPDIGATV where IFUNC = @c_ifunc) ) and 
									(VIEWGRPREP.bio_tipo = @c_biotipo);
					END			

					set @nCont = @@ROWCOUNT
			
					DECLARE Rtmp_digeqptos cursor for 
						(SELECT END_IP, BIO_TIPO from TMP_NREPDIGGRP  
							WHERE IFUNC = @c_ifunc and 
								  STATUS = @cTipo and  
							      CAST(Grupo AS INT) = CAST(@c_grupo AS INT) )
					OPEN Rtmp_digeqptos
					FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					WHILE @@fetch_status != -1
					BEGIN

						--SET @nCont = 0;
						--SET @nCont = (SELECT count(*) FROM TMP_NREPDIGOUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
						--IF (@nCont = 0)	BEGIN			
						
						IF NOT EXISTS (SELECT 1 FROM TMP_NREPDIGOUTROS WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip ) BEGIN
							-- trata equipamento SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') begin
								SET @cAux = null  
								SET @cAux = (SELECT STATUS from TMP_REPSAG002 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux is null)  
									INSERT into TMP_REPSAG002 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo );

								ELSE
									IF (@cAux = '0') 
										UPDATE TMP_REPSAG002 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip
							END
							ELSE begin
								-- trata equipamento SUPREMA
								IF (@xc_biotipo = '8') begin
									SET @cAux = null
									SET @cAux = (SELECT STATUS FROM TMP_REPSUP002 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip )
									IF (@cAux  is null) 
										INSERT into TMP_REPSUP002 (IFUNC, END_IP, STATUS)	VALUES  (@c_ifunc, @xc_endip, @cTipo);
									ELSE
										IF (@cAux = '0') 
											UPDATE TMP_REPSUP002 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip;
								end											
								ELSE begin 
									-- trata equipamento VIRDI / OUTROS
									IF (@xc_biotipo != 'A') 		-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
									begin
										SET @cAux = null
										SET @cAux = (SELECT STATUS FROM TMP_REPVRD002 WHERE IFUNC = @c_ifunc and END_IP  = @xc_endip AND BIO_TIPO = @xc_biotipo)
										IF (@cAux  is null) 
											INSERT into TMP_REPVRD002 (IFUNC, END_IP, BIO_TIPO, STATUS)	VALUES  (@c_ifunc, @xc_endip, @xc_biotipo, @cTipo);
										ELSE
											IF (@cAux = '0') 
												UPDATE TMP_REPVRD002 set STATUS = @cTipo where IFUNC = @c_ifunc and END_IP = @xc_endip and BIO_TIPO = @xc_biotipo;
									end											
								end
							end
						END

						
						-- **********************************************************************
						-- verifica se funcionario x ip ja está em tabela de inclusao, para incluir
						BEGIN
							-- SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') BEGIN
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPSAG001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '3') 
									DELETE FROM TMP_REPSAG001 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							END
							-- SUPREMA
							ELSE IF (@xc_biotipo = '8') BEGIN
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPSUP001 where IFUNC = @c_ifunc and END_IP = @xc_endip)
								IF (@cAux = '3') 
									DELETE FROM TMP_REPSUP001 where IFUNC = @c_ifunc and END_IP = @xc_endip;
							END
							-- VIRDI / OUTROS
							ELSE  IF (@xc_biotipo != 'A') BEGIN					-- NAO PRECISA TRATAR PALMVEIN, POIS JA TEM PROCESSO ESPECIFICO
								SET @cAux = null
								SET @cAux = (SELECT STATUS from TMP_REPVRD001 where IFUNC = @c_ifunc and END_IP = @xc_endip AND BIO_TIPO = @xc_biotipo)
								IF (@cAux = '3') 
									DELETE FROM TMP_REPVRD001 where IFUNC = @c_ifunc and END_IP = @xc_endip AND BIO_TIPO = @xc_biotipo;
							END
						END
							
						-- **********************************************************************
						-- NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  NOVO  						
						-- VERIFICA SE FUNCIONARIO X IP JA ESTÁ EM TABELA DE INCLUSAO E ESTA PENDENTE
						BEGIN
							-- SAGEM
							IF (@xc_biotipo = '6' or @xc_biotipo = '7') BEGIN
								SET @cAux = null
								SET @cAux = (SELECT STATUS FROM RDIG001
										WHERE IFUNC = @c_ifunc and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))

								IF (@cAux = '3') 		-- SITUAÇÃO PENDENTE 
									UPDATE RDIG001 SET STATUS = '4' 
										WHERE IFUNC = @c_ifunc and END_IP = @xc_endip

								ELSE IF (@cAux = '2') BEGIN	 		-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
									-- PROCURA EM RDIG002 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
									SET @cAux1 = null
									SET @cAux1 = (SELECT STATUS from RDIG002 
											where END_IP = @xc_endip and 
												  STATUS = '2' and 
												  (DATEADD (SECOND, 30, DATA_LOAD) < getdate()) AND	
												  ((BIO_TIPO = '6') OR (BIO_TIPO = '7'))) 		-- O COMANDO FOI FEITO HA MAIS DE 30 SEGUNDOS
									IF (@cAux != null)		
										UPDATE RDIG001 SET STATUS = '4' 
											WHERE IFUNC = @c_ifunc and END_IP = @xc_endip

								END
							END

							-- SUPREMA
							ELSE IF (@xc_biotipo = '8') BEGIN
								SET @cAux = null
								SET @cAux = (SELECT STATUS FROM RDIG003
										WHERE IFUNC = @c_ifunc and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))

								IF (@cAux = '3') 		-- SITUAÇÃO PENDENTE 
									UPDATE RDIG003 SET STATUS = '4' 
										WHERE IFUNC = @c_ifunc and END_IP = @xc_endip

								ELSE IF (@cAux = '2') BEGIN	 		-- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
									-- PROCURA EM RDIG002 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
									SET @cAux1 = null
									SET @cAux1 = (SELECT STATUS from RDIG002 
											where END_IP = @xc_endip and 
												  STATUS = '2' and 
												  (DATEADD (SECOND, 30, DATA_LOAD) < getdate()) AND	
												  (BIO_TIPO = '8'))		-- O COMANDO FOI FEITO HA MAIS DE 30 SEGUNDOS

									IF (@cAux != null)	
										UPDATE RDIG003 SET STATUS = '4' 
											WHERE IFUNC = @c_ifunc and END_IP = @xc_endip
								END			
							END

							-- OUTRAS BIOMETRIAS
							ELSE IF (@xc_biotipo != 'A') BEGIN
								SET @cAux = null
								SET @cAux = (SELECT STATUS FROM RDIG004
										WHERE IFUNC = @c_ifunc AND BIO_TIPO = @xc_biotipo and END_IP = @xc_endip AND (STATUS = '3' OR STATUS = '2'))

								IF (@cAux = '3') 		-- SITUAÇÃO PENDENTE 
									UPDATE RDIG004 SET STATUS = '4' 
										WHERE IFUNC = @c_ifunc AND BIO_TIPO = @xc_biotipo and END_IP = @xc_endip

								ELSE IF (@cAux = '2') BEGIN				 -- STATUS = '2' : PODE ESTAR NA SITUAÇÃO DEXECUTANDO E NAO OBTEVE RESPOSTA
									-- PROCURA EM RDIG002 SE O EQUIPAMENTO ESTÁ MAIS DE 30 SEGUNDOS ESPERANDO RESPOSTA, ENTAO PODE TIRAR.
									SET @cAux1 = null
									SET @cAux1 = (SELECT STATUS from RDIG002 
											where END_IP = @xc_endip and 
												  STATUS = '2' and 
												  (DATEADD (SECOND, 30, DATA_LOAD) < getdate()) AND	
												  ((BIO_TIPO != '6') and (BIO_TIPO != '7') and (BIO_TIPO != '8') and (BIO_TIPO != 'A'))) 		-- O COMANDO FOI FEITO HA MAIS DE 30 SEGUNDOS
									IF (@cAux != null)	
										UPDATE RDIG004 SET STATUS = '4' 
											WHERE IFUNC = @c_ifunc AND BIO_TIPO = @xc_biotipo and END_IP = @xc_endip
								END
							END
						END
						-- FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    FIM NOVO    
						-- **********************************************************************
							
						FETCH next from Rtmp_digeqptos into @xc_endip, @xc_biotipo 
					END 			
					
					CLOSE Rtmp_digeqptos
					DEALLOCATE Rtmp_digeqptos
			
					INSERT INTO TMP_NREPDIGATV (IFUNC, GRUPO, BIO_TIPO) VALUES (@c_ifunc, @c_grupo, @c_biotipo)
				END
			END
			
			-- atualiza estado para tratado em REPNDIGAUTO000, SE NÃO encontrou equipamento pertencente ao grupo e cai fora para tratar proximo funcionario
			UPDATE REPNDIGAUTO000 SET STATUS = '0' 			
				WHERE IFUNC = @c_ifunc and 
					BIO_TIPO = @c_biotipo and 
					CAST(Grupo AS INT) = CAST(@c_grupo AS INT)
			
			
			FETCH NEXT FROM cur_autod000 INTO @c_ifunc, @c_status, @c_grupo, @c_biotipo
		END
					
		CLOSE cur_autod000
		DEALLOCATE cur_autod000
	END


	-- trata SAGEM
	-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSAG001 - INCLUSAO)
	--SET @nCont = (SELECT COUNT(*) FROM TMP_REPSAG001 WHERE STATUS = '3')
	--IF (@nCont != 0) BEGIN
	
	IF EXISTS (SELECT 1 FROM TMP_REPSAG001 WHERE STATUS = '3') 
	BEGIN
		-- coloca o codin na tab. RDIG002 (CARGA LISTA) se eqpto  não existir
		insert into RDIG002 (END_IP, STATUS, BIO_TIPO)
			select distinct end_ip, '0', '6' 
			from TMP_REPSAG001
			where TMP_REPSAG001.end_ip not in ( select end_ip from RDIG002 ) and 
					TMP_REPSAG001.STATUS = '3'	
		
		-- insere ifunc-rep em tab. RDIG001, se não existir em tab.
		DECLARE cur_tmpautoSAG001 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSAG001 where STATUS = '3' or STATUS = '1')
		OPEN cur_tmpautoSAG001
		FETCH NEXT FROM cur_tmpautoSAG001 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG001 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG001 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '6');
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			DELETE FROM RDIG101 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	-- DELETA DA TABELA DE EXCLUSAO

			FETCH NEXT FROM cur_tmpautoSAG001 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSAG001
		DEALLOCATE cur_tmpautoSAG001
	END

	
		-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSAG002 - EXCLUSAO)
	--SET @nCont = (SELECT COUNT(*) FROM TMP_REPSAG002 WHERE STATUS = '8')
	--if (@nCont != 0) BEGIN
	
	IF EXISTS (SELECT 1 FROM TMP_REPSAG002 WHERE STATUS = '8') 
	BEGIN
		-- coloca o codin na tab. RDIG102 (EXCLUSAO) o codin não existir
		INSERT INTO RDIG102 (END_IP, STATUS, BIO_TIPO) 
			select distinct end_ip, '0', '6'
			from TMP_REPSAG002
			where TMP_REPSAG002.end_ip not in ( select end_ip from RDIG102 ) and 
					TMP_REPSAG002.STATUS = '8'	
	
		-- insere ifunc-rep em tab. RDIG101, se não existir em tab.
		DECLARE cur_tmpautoSAG002 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSAG002 where STATUS = '8')
		OPEN cur_tmpautoSAG002
		FETCH NEXT FROM cur_tmpautoSAG002 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG101 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG101 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '6');
			end

			-- deleta o ifunc da tabela de INclusao para o rep especifico do grupo
			DELETE FROM RDIG001 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoSAG002 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSAG002
		DEALLOCATE cur_tmpautoSAG002
	end



	-- trata SUPREMA
	-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSUP001 - INCLUSAO)
	--SET @nCont = (SELECT COUNT(*) FROM TMP_REPSUP001 WHERE STATUS = '3')
	--IF (@nCont != 0) BEGIN

	IF EXISTS (SELECT 1 FROM TMP_REPSUP001 WHERE STATUS = '3')
	BEGIN
		-- coloca o codin na tab. RDIG002 (CARGA LISTA) se eqpto  não existir
		insert into RDIG002 (END_IP, STATUS, BIO_TIPO)
			select distinct end_ip, '0', '8' 
			from TMP_REPSUP001
			where TMP_REPSUP001.end_ip not in ( select end_ip from RDIG002 ) and 
					TMP_REPSUP001.STATUS = '3'	
		
		-- insere ifunc-rep em tab. RDIG003, se não existir em tab.
		DECLARE cur_tmpautoSUP001 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSUP001 where STATUS = '3' or STATUS = '1')
		OPEN cur_tmpautoSUP001
		FETCH NEXT FROM cur_tmpautoSUP001 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG003 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG003 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '8');
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			DELETE FROM RDIG103 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoSUP001 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSUP001
		DEALLOCATE cur_tmpautoSUP001
	END

	
		-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPSUP002 - EXCLUSAO)
	--SET @nCont = (SELECT COUNT(*) FROM TMP_REPSUP002 WHERE STATUS = '8')
	--if (@nCont != 0) BEGIN

	IF EXISTS (SELECT 1 FROM TMP_REPSUP002 WHERE STATUS = '8')
	BEGIN
		-- coloca o codin na tab. RDIG102 (EXCLUSAO) o codin não existir
		INSERT INTO RDIG102 (END_IP, STATUS, BIO_TIPO) 
			select distinct end_ip, '0', '8'
			from TMP_REPSUP002
			where TMP_REPSUP002.end_ip not in ( select end_ip from RDIG102 ) and 
					TMP_REPSUP002.STATUS = '8'	
	
		-- insere ifunc-rep em tab. RDIG103, se não existir em tab.
		DECLARE cur_tmpautoSUP002 CURSOR FOR (SELECT IFUNC, END_IP, STATUS from TMP_REPSUP002 where STATUS = '8')
		OPEN cur_tmpautoSUP002
		FETCH NEXT FROM cur_tmpautoSUP002 into @xc_ifunc, @xc_endip, @xc_status
		while @@fetch_status != -1
		begin
			UPDATE RDIG103 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG103 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', '8');
			end

			-- deleta o ifunc da tabela de INclusao para o rep especifico do grupo
			DELETE FROM RDIG003 WHERE IFUNC = @xc_ifunc AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoSUP002 into @xc_ifunc, @xc_endip, @xc_status
		end
		CLOSE cur_tmpautoSUP002
		DEALLOCATE cur_tmpautoSUP002
	END
	
	
	-- trata VIRDI / OUTRAS LEITORAS
	-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPVRD001 - INCLUSAO)
	--SET @nCont = (SELECT COUNT(*) FROM TMP_REPVRD001 WHERE STATUS = '3')
	--IF (@nCont != 0) BEGIN
	
	IF EXISTS (SELECT 1 FROM TMP_REPVRD001 WHERE STATUS = '3')
	BEGIN
		-- coloca o codin na tab. RDIG002 (CARGA LISTA) se eqpto  não existir
		insert into RDIG002 (END_IP, STATUS, BIO_TIPO)
			--select distinct end_ip, '0', '9' 
			select distinct end_ip, '0', bio_tipo  
			from TMP_REPVRD001
			where TMP_REPVRD001.end_ip not in ( select end_ip from RDIG002 ) and 
					TMP_REPVRD001.STATUS = '3'	
		
		-- insere ifunc-rep em tab. RDIG004, se não existir em tab.
		DECLARE cur_tmpautoVRD001 CURSOR FOR (SELECT IFUNC, END_IP, STATUS, BIO_TIPO from TMP_REPVRD001 where STATUS = '3' or STATUS = '1')
		OPEN cur_tmpautoVRD001
		FETCH NEXT FROM cur_tmpautoVRD001 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		while @@fetch_status != -1
		begin
			UPDATE RDIG004 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND 
					   BIO_TIPO = @xc_biotipo AND
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG004 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								values (@xc_ifunc, @xc_endip, '1', @xc_biotipo );
			end
			
			-- deleta o ifunc da tabela de exclusao para o rep especifico do grupo
			DELETE FROM RDIG104 WHERE IFUNC = @xc_ifunc AND BIO_TIPO = @xc_biotipo AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoVRD001 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		end
		CLOSE cur_tmpautoVRD001
		DEALLOCATE cur_tmpautoVRD001
	END

	
		-- **************** trata os novos ifuncs X Eqptos  (resultantes da tabela TMP_REPVRD002 - EXCLUSAO)
	--SET @nCont = (SELECT COUNT(*) FROM TMP_REPVRD002 WHERE STATUS = '8')
	--if (@nCont != 0) BEGIN
	
	IF EXISTS (SELECT 1 FROM TMP_REPVRD002 WHERE STATUS = '8')
	BEGIN
		-- coloca o codin na tab. RDIG102 (EXCLUSAO) o codin não existir
		INSERT INTO RDIG102 (END_IP, STATUS, BIO_TIPO) 
			--select distinct end_ip, '0', '9'
			select distinct end_ip, '0', bio_tipo 
			from TMP_REPVRD002
			where TMP_REPVRD002.end_ip not in ( select end_ip from RDIG102 ) and 
					TMP_REPVRD002.STATUS = '8'	
	
		-- insere ifunc-rep em tab. RDIG104, se não existir em tab.
		DECLARE cur_tmpautoVRD002 CURSOR FOR (SELECT IFUNC, END_IP, STATUS, BIO_TIPO from TMP_REPVRD002 where STATUS = '8')
		OPEN cur_tmpautoVRD002
		FETCH NEXT FROM cur_tmpautoVRD002 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		while @@fetch_status != -1
		begin
			UPDATE RDIG104 SET STATUS = '1' 
				WHERE  IFUNC = @xc_ifunc AND
					   BIO_TIPO = @xc_biotipo AND 
					   END_IP = @xc_endip;

			if (@@rowcount = 0) begin
				INSERT INTO RDIG104 (IFUNC, END_IP, STATUS, BIO_TIPO) 
								--values (@xc_ifunc, @xc_endip, '1', '9');
								values (@xc_ifunc, @xc_endip, '1', @xc_biotipo );
			end

			-- deleta o ifunc da tabela de INclusao para o rep especifico do grupo
			DELETE FROM RDIG004 WHERE IFUNC = @xc_ifunc AND BIO_TIPO = @xc_biotipo AND END_IP = @xc_endip AND (STATUS = '0' OR STATUS = '1')	

			FETCH NEXT FROM cur_tmpautoVRD002 into @xc_ifunc, @xc_endip, @xc_status, @xc_biotipo 
		end
		CLOSE cur_tmpautoVRD002
		DEALLOCATE cur_tmpautoVRD002
	end	

	--SET LOCK_TIMEOUT -1

GO



if object_id('TELESSVR.P_RepGerDigital5', 'p') is null
    exec ('create procedure TELESSVR.P_RepGerDigital5 as select 1')
go

ALTER PROCEDURE TELESSVR.P_RepGerDigital5  @nQtd INT
AS

DECLARE @ret CHAR(1)
DECLARE @nQtdPend INT


	SET DATEFORMAT YMD


	set @ret = 0
	SET @nQtdPend = 0
	
	-- prepara automatico digitais sagem RDIG001 / RDIG101
	exec TELESSVR.AntePrep3_RSagem	@nQtd
	
	-- prepara automatico digitais tsi1 RDIG003 / RDIG103
	exec TELESSVR.AntePrep3_RTsi1 @nQtd	

	-- prepara automatico digitais virdi E OUTROS RDIG004 / RDIG104
	exec TELESSVR.AntePrep2_ROutrosBios @nQtd


	--exec TELESSVR.Prep_RepDigit4 @nQtd
	exec TELESSVR.Prep_RepDigit5 @nQtd
	
	--SELECT TOP(1) @nQtdPend = 1 FROM  REPNDIGAUTO000 WHERE STATUS <> '0'
	--IF (@nQtdPend = 0) 
	
	IF NOT EXISTS (SELECT 1 FROM  REPNDIGAUTO000 WHERE STATUS <> '0')
	begin
		-- trata biometria sagem
		--exec TELESSVR.trata3_RepSagem	
		exec TELESSVR.trata4_RepSagem	

		-- trata biometria tsi1
		--exec TELESSVR.trata3_RepTsi1		
		exec TELESSVR.trata4_RepTsi1		

		-- trata biometria virdi/outros
		--exec TELESSVR.trata2_RepOutrosBios		
		exec TELESSVR.trata3_RepOutrosBios		
	END
	
	select @ret
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


if object_id('TELESSVR.sqlfinal_histRStF2', 'p') is null
    exec ('create procedure TELESSVR.sqlfinal_histRStF2 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlfinal_histRStF2 @LMat VARCHAR(MAX), @cEndIp CHAR(15), @cModo CHAR(1)
AS

DECLARE @Ret smallint , @Tam INT, @Pos INT, @cIFUNC CHAR(12), @cPIS CHAR(12)

	SET @Ret = 0
	
	SET @Tam = len(@LMat) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) 
		begin

			SET @cPIS = SUBSTRING (@LMat, @Pos, 12);
			
			DECLARE lhistf_cur CURSOR FOR
			SELECT IFUNC FROM REPAUXEMPR 
				WHERE END_IP = @cEndIp AND 
				   TIPO = @cModo AND 
					  PIS = @cPIS AND 
					  ST = '1'
				ORDER by IFUNC;
			
			OPEN lhistf_cur
			FETCH next from lhistf_cur into @cIFUNC
			WHILE (@@fetch_status != -1) 
			BEGIN
				UPDATE REPAUXEMPR SET ST = '2' where current of lhistf_cur
					--WHERE END_IP = @cEndIp AND 
					--		TIPO = @cModo AND 
					--		PIS = @cPIS AND
					--		IFUNC = @cIFUNC AND
					--		ST = '1'
				
				FETCH next from lhistf_cur into @cIFUNC
			END
				
			CLOSE lhistf_cur
			DEALLOCATE lhistf_cur

			SET @Pos = @Pos + 12;
		end
	END;


	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


if object_id('TELESSVR.sqlhist_Rfunc3', 'p') is null
    exec ('create procedure TELESSVR.sqlhist_Rfunc3 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlhist_Rfunc3 @LMat VARCHAR(MAX), @cEndIp CHAR(15), @cInsDel CHAR(1), @cModo CHAR(1)
AS

DECLARE @Ret smallint , @Tam INT, @Pos INT, @cAcao CHAR(1)

	SET @Ret = 0
	
	IF (@cInsDel = '3')
		SET @cAcao = 'I'
	ELSE
		SET @cAcao = 'E'


	-- analise de LMat
	SET @Tam = len(@LMat) ;
	if (@Tam > 0) begin
		SET @Pos = 1;
		WHILE (@Pos < @Tam) begin
			INSERT INTO HISTREPFUN (IFUNC, END_IP, INSEXC, MODO) 
							VALUES (SUBSTRING (@LMat, @Pos, 12) , @cEndIp, @cAcao, @cModo);
			SET @Pos = @Pos + 12;
		end
	END;

		
	IF EXISTS (select END_IP FROM REPLASTCOM WHERE END_IP = @cEndIp) 
		UPDATE REPLASTCOM SET DATA_INS = GETDATE() WHERE END_IP = @cEndIp;
	ELSE
		INSERT INTO REPLASTCOM (END_IP, DATA_INS) VALUES (@cEndIp, GETDATE());


	SELECT @Ret
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO



-- ESTA TRIGGER é executada quando (UPDATE) DA TAB. REPEMPR002
-- INSERIRÁ NA TAB.REPNAUTO000, A MATRICULA COM OS GRUPOS AOS QUAIS PERTENCEM, COM STATUS DE INCLUSÃO('3') 
-- MAS COMO ESTÁ ALTERAANDO DADOS DO FUNCIONARIO (NÃO É DIGITAL) NÃO HAVERÁ CARGA AUTOMÁTICA DE DIGITAIS, PORQUE ESTAS NAO FORAM ALTERADAS

IF EXISTS (SELECT name FROM sysobjects WHERE name = 'TRGREPFUN_U' AND type = 'TR')
    DROP TRIGGER TELESSVR.TRGREPFUN_U
GO

CREATE TRIGGER TELESSVR.TRGREPFUN_U ON TELESSVR.REPEMPR002 FOR UPDATE
AS
DECLARE @NovoFunc CHAR(12)

          
	DECLARE cur_updfunc CURSOR FOR (select A.IFUNC from  INSERTED A)

	OPEN cur_updfunc
	FETCH NEXT FROM cur_updfunc INTO @NovoFunc
          
	WHILE @@fetch_status != -1
	BEGIN          
              

		-- ESTA TRIGGER INSERIRA´EM TAB.REPNAUTO000, OS GRUPOS QUE A MATRICULA FAZ PARTE, PARA QUE NOS EQUIPTOS DESTE GRUPO SEJA INCLUIDA A MATRICULA
		exec TELESSVR.Auxtrg_repFunc @NovoFunc, '3';

		FETCH NEXT FROM cur_updfunc INTO @NovoFunc
	END
	CLOSE cur_updfunc
	DEALLOCATE cur_updfunc

GO


-- ESTA TRIGGER é executada antes de DELETE DA TAB. REPEMPR002
-- INSERIRÁ NA TAB.REPNAUTO000, A MATRICULA COM OS GRUPOS AOS QUAIS PERTENCEM, COM STATUS DE EXCLUSÃO('8')
-- INSERIRÁ NA TAB.REPNDIGAUTO000, A MATRICULA COM OS GRUPOS AOS QUAIS PERTENCEM, COM STATUS DE EXCLUSÃO('8')
IF EXISTS (SELECT name FROM sysobjects WHERE name = 'TRGREPFUN_D' AND type = 'TR')
    DROP TRIGGER TELESSVR.TRGREPFUN_D
GO

CREATE TRIGGER TELESSVR.TRGREPFUN_D ON TELESSVR.REPEMPR002 FOR DELETE
AS
DECLARE @VelhoFunc CHAR(12)


	DECLARE cur_delfunc CURSOR FOR (select A.IFUNC from  DELETED A)

	OPEN cur_delfunc
	FETCH NEXT FROM cur_delfunc INTO @VelhoFunc
          
	WHILE @@fetch_status != -1
	BEGIN          
	
		-- ESTA TRIGGER INSERIRA´EM TAB.REPNAUTO000, OS GRUPOS QUE A MATRICULA FAZ PARTE, PARA QUE DOS EQUIPTOS DESTE GRUPO SEJA RETIRADA A MATRICULA
		exec TELESSVR.Auxtrg_repFunc @VelhoFunc, '8';


		-- ESTA TRIGGER INSERIRA´EM TAB.REPNDIGAUTO000, OS GRUPOS QUE A MATRICULA FAZ PARTE, PARA QUE DOS EQUIPTOS DESTE GRUPO SEJA RETIRADA A MATRICULA
		exec TELESSVR.Auxtrg_repDig2 @VelhoFunc, '8', '0';

		FETCH NEXT FROM cur_delfunc INTO @VelhoFunc
	END
	CLOSE cur_delfunc
	DEALLOCATE cur_delfunc

GO


-- ESTA TRIGGER SERÁ EXECUTADO QUANDO UPDATE NA TABELA REPGRPF 
-- (EX: ALTERAÇÃO DO VALOR DO GRUPO PARA O FUNCIONARIO)

IF EXISTS (SELECT name FROM sysobjects WHERE name = 'TRGREPGRP_U' AND type = 'TR')
    DROP TRIGGER TELESSVR.TRGREPGRP_U
GO

CREATE TRIGGER TELESSVR.TRGREPGRP_U ON TELESSVR.REPGRPF FOR UPDATE 
AS
DECLARE @Func CHAR(12)
DECLARE @VelhoGrupo CHAR(5)
DECLARE @NovoGrupo CHAR(5)
DECLARE @cAux VARCHAR(1)
DECLARE @cDataAux datetime
DECLARE @nCont int;
          
    --SET nCont = 0;
	IF UPDATE (GRUPO) BEGIN          
    
		DECLARE cur_auto004 CURSOR FOR (select A.IFUNC, A.GRUPO, B.GRUPO from DELETED A, INSERTED B)
		OPEN cur_auto004
		FETCH NEXT FROM cur_auto004 INTO @Func, @VelhoGrupo, @NovoGrupo

		WHILE @@fetch_status != -1
		BEGIN          
         

			-- ***************************************************************************************************************************************
			-- PARA CARGA DE FUNCIONARIOS
			
			-- *********************** analise grupo 'velho'  ***********************
			-- procura em REPNAUTO000 se o Funcionario x GrupoVelho que foi modificado já está em tabela para ser Excluido (status '8').
			-- Se estiver presente , nada faz
			
			SET @cAux = null
			SET @cAux = 
				(SELECT STATUS FROM REPNAUTO000 
					WHERE REPNAUTO000.IFUNC = @Func and 
					  CAST(REPNAUTO000.GRUPO AS INT) = CAST(@VelhoGrupo AS INT) 
				)
			
			IF (@cAux is null) BEGIN
				-- esta matricula nao sofreu nenhuma inclusao ou exclusao, então insere na tabela REPNAUTO000 como Exclusao. 
				-- A data/hora (DATA_INS) ´será atualizada com a dta corrente
				INSERT INTO REPNAUTO000 (IFUNC, STATUS, GRUPO) VALUES 
										(@Func, '8', @VelhoGrupo)
			END
			ELSE BEGIN
				-- verifica se está na tabela para ainda ser processado para inclusao ou já incluido
				IF (@cAux = '3' OR @cAux = '0') BEGIN
			
					-- como está para ser incluido, altera para status de exclusao, atualizando a data
					UPDATE REPNAUTO000 SET STATUS = '8' , DATA_INS = getdate() 
						WHERE REPNAUTO000.IFUNC = @Func and 
							CAST(REPNAUTO000.GRUPO AS INT) = CAST(@VelhoGrupo AS INT)
				END
			END

			-- ***********************  analisa grupo 'novo'  ***********************
			-- procura em REPNAUTO000 se o Funcionario x GrupoNovo  já está em tabela para ser Incluido (status '3').
			-- Se estiver presente , nada faz

			SET @cAux = null
			SET @cAux = 
				(SELECT STATUS FROM REPNAUTO000 
					WHERE REPNAUTO000.IFUNC = @Func and 
						  CAST(REPNAUTO000.GRUPO AS INT) = CAST(@NovoGrupo AS INT) 
			    )

			IF (@cAux is null) BEGIN
				-- este (funcionario x grupo) nao sofreu nenhuma inclusao ou exclusao, então insere na tabela REPNAUTO000 como Inclusao. 
				-- A data/hora (DATA_INS) ´será atualizada com a dta corrente
				INSERT INTO REPNAUTO000 (IFUNC, STATUS, GRUPO, DATA_INS) VALUES 
										(@Func, '3', @NovoGrupo, DATEADD(ss,1,getdate()) )
			END			
			ELSE BEGIN
				-- verifica se está na tabela para ainda ser processado para exclusao ou já excluido
				IF (@cAux = '8' OR @cAux = '0') BEGIN
					
					-- como está para ser excluido, altera para status de inclusao, atualizando a data com 1 segundo a mais, pois primeiro exclui e depois insere no grpo novo
					UPDATE REPNAUTO000 SET STATUS = '3' , DATA_INS = DATEADD(ss,1,getdate() )
						WHERE REPNAUTO000.IFUNC = @Func and 
							CAST(REPNAUTO000.GRUPO AS INT) = CAST(@NovoGrupo AS INT)
				END
			END
			
			
			-- ***************************************************************************************************************************************
			-- PARA CARGA DE DIGITAIS AUTOMATICO

			-- *********************** analise grupo 'velho'  ***********************
			-- procura em REPNDIGAUTO000 se o Funcionario x GrupoVelho que foi modificado já está em tabela para ser Excluido (status '8').
			-- Se estiver presente , nada faz

			SET @cAux = null
			SET @cAux = 
				(SELECT STATUS FROM REPNDIGAUTO000 
					WHERE REPNDIGAUTO000.IFUNC = @Func and 
						REPNDIGAUTO000.BIO_TIPO = '0' and 
						CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@VelhoGrupo AS INT) 
			    )

			IF (@cAux is null) BEGIN
				-- esta matricula nao sofreu nenhuma inclusao ou exclusao, então insere na tabela REPNDIGAUTO000 como Exclusao. 
				-- A data/hora (DATA_INS) ´será atualizada com a dta corrente
				INSERT INTO REPNDIGAUTO000 (IFUNC, STATUS, GRUPO, BIO_TIPO) VALUES 
											(@Func, '8', @VelhoGrupo, '0')
			END
	
			ELSE BEGIN
				-- verifica se está na tabela para ainda ser processado para inclusao ou já incluido
				IF (@cAux = '3' OR @cAux = '0') BEGIN
					-- como está para ser incluido, altera para status de exclusao, atualizando a data
					UPDATE REPNDIGAUTO000 SET STATUS = '8' , DATA_INS = getdate() 
						WHERE REPNDIGAUTO000.IFUNC = @Func and 
							REPNDIGAUTO000.BIO_TIPO = '0' and 
							CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@VelhoGrupo AS INT)
				END
			END				
				
			-- ***********************  analisa grupo 'novo'  ***********************
			-- procura em REPNAUTO000 se o Funcionario x GrupoNovo  já está em tabela para ser Incluido (status '3').
			-- Se estiver presente , nada faz

			SET @cAux = null
			SET @cAux = 
				(SELECT STATUS FROM REPNDIGAUTO000 
					WHERE REPNDIGAUTO000.IFUNC = @Func and 
						REPNDIGAUTO000.BIO_TIPO = '0' and 
						CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@NovoGrupo AS INT) 
				)

			IF (@cAux is null) BEGIN
				-- este (funcionario x grupo) nao sofreu nenhuma inclusao ou exclusao, então insere na tabela REPNDIGAUTO000 como Inclusao. 
				-- A data/hora (DATA_INS) ´será atualizada com a dta corrente
				INSERT INTO REPNDIGAUTO000 (IFUNC, STATUS, GRUPO, BIO_TIPO, DATA_INS) VALUES 
											(@Func, '3', @NovoGrupo, '0', DATEADD(ss,1,getdate()) )
			END
			ELSE BEGIN
				-- verifica se está na tabela para ainda ser processado para exclusao ou já excluido
				IF (@cAux = '8' OR @cAux = '0') BEGIN
					-- como está para ser excluido, altera para status de inclusao, atualizando a data com 1 segundo a mais, pois primeiro exclui e depois insere no grpo novo
					UPDATE REPNDIGAUTO000 SET STATUS = '3' , DATA_INS = DATEADD(ss,1,getdate() )
						WHERE REPNDIGAUTO000.IFUNC = @Func and 
							REPNDIGAUTO000.BIO_TIPO = '0' and 
							CAST(REPNDIGAUTO000.GRUPO AS INT) = CAST(@NovoGrupo AS INT)
				END
			END
			
			FETCH NEXT FROM cur_auto004 INTO @Func, @VelhoGrupo, @NovoGrupo	
			
		END
		

	CLOSE cur_auto004
	DEALLOCATE cur_auto004
		
	END

GO


-----------------------------------------------------------------------------------
-- 2.10.11.3 || 2.10.11.3 || 2.10.11.3 || 2.10.11.3 || 2.10.11.3 || 2.10.11.3 || --
-----------------------------------------------------------------------------------

-- SEM ALTERAÇÃO DE SCRIPT NESTA RELEASE


-----------------------------------------------------------------------------------
-- 2.10.11.4 || 2.10.11.4 || 2.10.11.4 || 2.10.11.4 || 2.10.11.4 || 2.10.11.4 || --
-----------------------------------------------------------------------------------

-- SEM ALTERAÇÃO DE SCRIPT NESTA RELEASE


-----------------------------------------------------------------------------------
-- 2.10.11.5 || 2.10.11.5 || 2.10.11.5 || 2.10.11.5 || 2.10.11.5 || 2.10.11.5 || --
-----------------------------------------------------------------------------------

-- SEM ALTERAÇÃO DE SCRIPT NESTA RELEASE


-----------------------------------------------------------------------------------
-- 2.10.11.6 || 2.10.11.6 || 2.10.11.6 || 2.10.11.6 || 2.10.11.6 || 2.10.11.6 || --
-----------------------------------------------------------------------------------

-- SEM ALTERAÇÃO DE SCRIPT NESTA RELEASE


-----------------------------------------------------------------------------------
-- 2.10.11.7 || 2.10.11.7 || 2.10.11.7 || 2.10.11.7 || 2.10.11.7 || 2.10.11.7 || --
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- Inclusion date:  12/05/2021 - 15:13
-- Change date:     12/05/2021 - 15:13
-- Sequence:        0446
-- Redmine:         @11548, @12048
-----------------------------------------------------------------------------

/*
{ 
  "database"    : "MSSSQL",
  "owner"       : "TELESSVR",
  "type"        : "TRIGGER",
  "name"        : "DAM00_EI",
  "description" : "DAM00_EI",
  "version"     : "1.0.4.0",
  "log"         : {
                   "1.0.4.0" : { "author" : "Nathan Gabriel", "created" : "12/05/2021", "issue" : "@11548", "description" : "Correção na valiável ICARDREAL não estar zerada antes de realizar as consultas"}
                  }
}
*/
IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('DAM00_EI'))
	DROP TRIGGER TELESSVR.DAM00_EI;
GO

CREATE TRIGGER TELESSVR.DAM00_EI on TELESSVR.DAM00 for update, insert as
declare
  @icard    char(12),
  @diam     char(2),
  @mesm     char(2),
  @anom     char(2),
  @horam    char(4),
  @segundo  char(2),
  @codac    char(2),
  @posic    char(1),
  @blueb    char(2),
  @codtt    char(2),
  @end_ip   char(15),
  @CodiFunc char(2),
  @onoff    char(1),
  @veiculo  varchar(15),
  @erro     int,
  @CodiPlan numeric(3),
  @CodiCole numeric(3),
  @CodiBene numeric(2),
  @UsoMarc  numeric(2),
  @deslog   varchar(254),
  @DataAces datetime,
  @HoraAces int,
  @SequColeAlar int,
  @idVeic int,
  @CodiEsta smallint,
  @IdEsVisit int,
  @TipoVisi int,
  @BloqAcesSaid varchar(1),
  @BaixAutoCrac varchar(1),
  @ICardReal    char(12),
  @AchouIcard   smallint,
  @ICardVeiculo numeric(12),
	
  @vIdColab numeric(9),
  @vIdVisi numeric(9),
  @vDataCP Date,
	@vHoraEntrCP DateTime,
  @vHoraSaidCP DateTime,
  @vHoraCP DateTime

	  select @SequColeAlar = 0 ;

	  declare cur_dam00_ins_new cursor for
		select icard, diam, mesm, anom, horam, segundo, codac, posic, blueb, codtt, end_ip, codfnc, onoff, veiculo
		  from
			inserted for read only

	  open cur_dam00_ins_new 
  
	  fetch next from cur_dam00_ins_new into @icard, @diam, @mesm, @anom, @horam, @segundo, @codac, @posic, @blueb, @codtt, @end_ip, @CodiFunc, @onoff, @veiculo
  
	  while ( @@fetch_status = 0 )
	  begin
   
		select @erro = 0
		select @deslog = ''
		select @SequColeAlar = @SequColeAlar + 1 ;

		if (  @segundo = '99' )
			select @segundo = '00'
            

		if not ( @diam like '[0-9][0-9]' and @diam between '01' and '31' )
		begin
     
		  select @erro = 1

		  select @deslog = 'DAM00: Formato de Data Inválido: [telessvr][DAM00][DIAM] = ' + @diam
   
		end
		else
		  if not ( @mesm like '[0-9][0-9]' and @mesm  between '01' and '12' )
		  begin

			select @erro = 1

			select @deslog = 'DAM00: Formato de Data Inválido: [telessvr][DAM00][MESM] = ' + @mesm
          
		  end
		  else
			if not ( @anom  like '[0-9][0-9]'  and @anom  between '00' and '99'   )
			begin
             
			  select @erro = 1
             
			  select @deslog = 'DAM00: Formato de Data Inválido: [telessvr][DAM00][ANOM] = ' + @anom
             
			end
			else
			  if not (  @horam like '[0-9][0-9][0-9][0-9]'  and @horam between '0000' and '2400'  )
			  begin
           
				select @erro = 1
           
				select @deslog = 'DAM00: Formato de Data Inválido: [telessvr][DAM00]HORAM] = ' + @horam
         
			  end
			  else
				if not (  @segundo like '[0-9][0-9]' and @segundo between '00' and '60' )
				begin
             
				  select @erro = 1
              
				  select @deslog = 'DAM00: Formato de Data Inválido: [telessvr][DAM00]SEGUNDO] = ' + @segundo
           
				end
								else
					if ( suricato.isReallyNumeric( @icard ) = 0 )
					begin
                 
					  select @erro = 1		  
                 
					  select @deslog = 'DAM00: Formato de Icard inválido. ICARD = ' + @icard
                   
					  Set @icard = 0
               
					end
  
		if @erro = 0
		begin

		  select @CodiPlan = CodiPlan, @CodiCole = CodiCole from suricato.TbCodin where NumeEndeCole = @end_ip 

		  if ( @CodiPlan IS NULL OR @CodiCole IS NULL )
		  begin
			select @erro = 1
				  select @deslog = 'DAM00: Codin não encontrado'
					GOTO FIM
		  end
 
		  select @CodiBene = CodiBene from suricato.TbCodinBenef where CodiPlan = @CodiPlan and CodiCole = @CodiCole

		  select @UsoMarc = UsoMarc from suricato.TbMarcaReali where CodiPlan = @CodiPlan and CodiCole = @CodiCole and CodiFunc = convert( numeric(2) , CodiFunc )

		  select @DataAces = convert( datetime,  @anom + @mesm + @diam, 112 )

		  select @HoraAces = convert( int, substring( @horam, 1, 2 ) ) * 60 + convert( int, substring( @horam, 3, 2 ) )
  
		  set @ICardReal = null

		  select @ICardReal = ICard from suricato.TbCrachFisic where NumeFisiCrac = convert( decimal, @icard )	  

		  if @ICardReal is null
			select @ICardReal = @icard			
      
		  if exists( select 1 from suricato.TbMarcaAcess where ICard = @ICardReal and DataAces = @DataAces and HoraAces = @HoraAces and SequRegi = @segundo and CodiPlan = @CodiPlan and CodiCole = @CodiCole )
		  begin
               
			select @erro = 1
               
			select @deslog = 'DAM00: Marcações Duplicadas para Crachá: ' + @ICardReal +
							 ', Data: ' + cast( @DataAces as varchar ) + 
							 ', Hora: ' + cast( @HoraAces as varchar ) + ':' + cast( @segundo as varchar ) +
							 ', Planta: ' + cast( @CodiPlan as varchar ) +
							 ', Codin ' + cast( @CodiCole as varchar )
             
		  end
                    
		  if @erro = 0
		  begin

			select @ICardVeiculo = COALESCE( case when rtrim(ltrim(@veiculo)) = '' then 0 else convert( numeric, rtrim(ltrim(@veiculo ))) end, 0 )

			if ( @ICardVeiculo = 0 and exists ( select 1 from suricato.TbCadasCrach where ICard = @ICardReal and UsoFaixCrac = 8 ) )
			begin
			  select @ICardVeiculo = @ICardReal
			end




			-- POC SENADO
			begin
						select 
								@vIdColab = isnull(IdColab,0) 
							from 
								suricato.TbHistoCrach 
							where 
								ICard = @ICardReal 
								and ( DataFina < @DataAces or ( DataFina = @DataAces and HoraFina < ( @HoraAces * 60 ) ) ) 
							order by 
								DataFina DESC, 
								HoraFina DESC			  

				select top 1 @ICardVeiculo = isnull(hv.IcardV,0) from suricato.TBHISTORESPVEICU hrv
				join suricato.TBHISTOVEICU hv
				on hrv.idveic = hv.idveic
				where 
				hrv.IDCOLAB = @vIdColab
				order by hv.datainic desc, hv.horainic desc
			end

			insert into suricato.TbMarcaAcess ( ICard, DataAces, HoraAces, SequRegi, TipoAces, CodiPlan, CodiCole, CodiFunc, DireAces, QuanAces, OrigMarc, UsoMarc, CodiBene, FlagAces, StatAtuaCole, NumeFisiCrac, ICardV )
			  values ( @ICardReal, @DataAces, @HoraAces, @segundo, @codac, @CodiPlan, @CodiCole, convert( numeric(2), @CodiFunc ), case when @posic = '0' then 'E' when @posic = '1' then 'S' end, 0, 'E', isnull( @UsoMarc, 1 ), @CodiBene, 0, convert( smallint, @onoff  ), @icard, @ICardVeiculo )


					
			-- >>> Alarme
					if ( @codac = '15')
					begin
				
						select 
								@vIdColab = IdColab 
							from 
								suricato.TbHistoCrach 
							where 
								ICard = @ICardReal 
								and ( DataFina < @DataAces or ( DataFina = @DataAces and HoraFina < ( @HoraAces * 60 ) ) ) 
							order by 
								DataFina DESC, 
								HoraFina DESC			  
				
						insert into suricato.TbAlarSTrata ( DataColeAlar, HoraColeAlar, SequColeAlar, DataAlar, HoraAlar, CodiPlan, CodiCole, CodiSind, TipoAlar, StatAlar, DataRecoAlar, HoraRecoAlar, UsuaReceChav, DescRecoUsua, TipoRecoReal, EndeEntrCole, ICard, TipoAces, IdColab )
							select 
									convert( char(8), getdate(), 112 ),
									( datepart( hour, getdate() ) * 60 ) + ( datepart( minute, getdate() ) ),
									datepart( second, getdate() ) * 1000 + datepart( millisecond, getdate() ) + @SequColeAlar,
									@DataAces, @HoraAces * 60 + @segundo, @CodiPlan, @CodiCole, 2015, 1, 0 , '19001231', 0, null, '', null, null, @ICardReal, @codac, @vIdColab
								from
									suricato.TbTipoAcess
								where 
									TipoAces = @codac and  TipoAcesMoni = 'S'
							
					end
					else
					begin
				
						insert into suricato.TbAlarSTrata ( DataColeAlar, HoraColeAlar, SequColeAlar, DataAlar, HoraAlar, CodiPlan, CodiCole, CodiSind, TipoAlar, StatAlar, DataRecoAlar, HoraRecoAlar, UsuaReceChav, DescRecoUsua, TipoRecoReal, EndeEntrCole, ICard, TipoAces )
							select 
									convert( char(8), getdate(), 112 ),
									( datepart( hour, getdate() ) * 60 ) + ( datepart( minute, getdate() ) ),
									datepart( second, getdate() ) * 1000 + datepart( millisecond, getdate() ) + @SequColeAlar,
									@DataAces, @HoraAces * 60 + @segundo, @CodiPlan, @CodiCole, 9999, 0, 0 , '19001231', 0, null, '', null, null, @ICardReal, @codac
								from
									suricato.TbTipoAcess
								where 
									TipoAces = @codac and  TipoAcesMoni = 'S'				
				
					end
			-- <<< Alarme

				


			-- >>> Baixa de Provisório
			if @posic = '1' and @codac = '01'
			begin

				if exists ( select 1 from suricato.TbCadasCrach where icard = cast( replicate( 0, 12 - len( cast( @ICardReal as varchar ) ) ) + cast( @ICardReal as varchar ) as numeric) and UsoFaixCrac = 6 )
				begin

					if exists ( select 1 from suricato.TbCodin where NumeEndeCole = @end_ip and BaixaAutoProv  = 'S' )
					begin

					  update suricato.TbHistoCrach
						set 
						  DataFina = @DataAces, 
						  HoraFina = @HoraAces - 1,
						  StatHist = 2,
						  StatAtuaCont = 2
						where 
						  ICard = @ICardReal
										and ( DataInic < @DataAces or ( DataInic = @DataAces and HoraInic <= @HoraAces ) ) 
										and ( DataFina > @DataAces or ( DataFina = @DataAces and HoraFina >= @HoraAces ) or ( DataFina = '1900-12-31' ) ) 
						  and convert( datetime, convert( varchar(10), DataFina, 120 ) ) = convert( datetime, convert( varchar(10), getdate(), 120 ) ) 

					end

				end

			end
			-- <<< Baixa de Provisório


			-- >>> Baixa de Visitante
			
			if @posic = '1' and @codac = '01'
			begin
				  if exists ( select 1 from telessvr.controle where icard = replicate( 0, 12 - len( cast( @ICardReal as varchar ) ) ) + cast( @ICardReal as varchar ) and tpfis = 4 )
				  begin

					if exists ( select 1 from suricato.TbCodin where NumeEndeCole = @end_ip and BaixAutoCrac = 'S' )
					begin

					  select 
						  @IdEsVisit = IdEsVisit, 
						  @TipoVisi = suricato.TbTipoVisit.TipoVisi, 
						  @BloqAcesSaid = BloqAcesSaid, 
						  @BaixAutoCrac = BaixAutoCrac 
						from 
						  suricato.TbTipoVisit
						inner join suricato.TbESVisit
						  on suricato.TbTipoVisit.TipoVisi = suricato.TbESVisit.TipoVisi
						where 
						  ICard = @ICardReal and
						  DataSaid = convert(datetime, '19001231', 112)

					  if upper( @BaixAutoCrac ) = 'S'
					  begin

						update suricato.TbESVisit 
						  set 
							DataSaid = @DataAces, 
							HoraSaid = @HoraAces,
							DataSaidLoca = @DataAces, 
							HoraSaidLoca = @HoraAces
						  where 
							IdEsVisit = @IdEsVisit

						update suricato.TbHistoVisit
						  set 
							DataFina = @DataAces, 
							HoraFina = @HoraAces
						  where 
							ICard = @ICardReal and 
							DataFina = convert(datetime, '19001231', 112)

						end

						if upper( @BloqAcesSaid ) = 'S'
						  update telessvr.controle set situa = '1' where icard = replicate( 0, 12 - len( cast( @ICardReal as varchar ) ) ) + cast( @ICardReal as varchar ) and tpfis = 4

					  end
				  end
			end 
			-- <<< Baixa de Visitante



			-- >>> Suricato Risk Area Controller
			if ( @codac = '01' ) and
			   exists ( select 1 from suricato.TbParamServi where Nome = 'USE_RISK_AREA_CONTROLLER' and Valo = 'S' ) and
			   exists ( select 1 from suricato.TbCodinLocalAcess where CodiPlan = @CodiPlan and CodiCole = @CodiCole )
			begin

			  declare @DataHora varchar(19)

			  select @DataHora = '20' + @anom + '-' + @mesm + '-' + @diam + ' ' + substring( @horam, 1, 2 ) + ':' + substring( @horam, 3, 2 )  + ':' + @segundo

			  if (@posic = '0')
			  begin
				update suricato.TbContrLocalAcess set Entrada = CONVERT(Datetime, @DataHora, 120) where Icard = cast(@ICardReal as numeric) and NumeEndeCole = @end_ip
			  end
			  else
			  begin
				update suricato.TbContrLocalAcess set Status = 0, Saida = CONVERT(Datetime, @DataHora, 120) where Icard = cast(@ICardReal as numeric) and NumeEndeCole = @end_ip
				delete TELESSVR.MATCODIN where ICard = @ICardReal and END_IP = @end_ip
			  end

			end
			-- <<< Suricato Risk Area Controller


			-- >>> Suricato Message Controller
			if exists ( select 1 from suricato.TbParamServi where Nome = 'USE_MESSAGE_CONTROLLER' and Valo = 'S' )
			begin

			  declare @vDataInic datetime;
			  declare @vHoraInic integer;

			  declare cur_MessageController cursor for select icard from inserted for read only

			  open cur_MessageController fetch next from cur_MessageController into @icard

			  while ( @@fetch_status = 0 )
			  begin


				update
					suricato.TbMensaColab
				  set
					StatAtuaCont = 2
				  where
					IdColab = ( select IdColab from suricato.TbColab where IdPessoa = suricato.getIdPessoa( @icard ) ) and
					( DataInic < convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataInic = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraInic <= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) ) and
					( DataFina > convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataFina = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraFina >= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) or ( DataFina = '1900-12-31' ) ) and
					StatAtuaCont = 1;


				select 
					TOP 1 @vIdColab = IdColab, @vDataInic = DataInic, @vHoraInic = HoraInic 
				  from 
					  suricato.TbMensaColab
				  where
					IdColab = ( select IdColab from suricato.TbColab where IdPessoa = suricato.getIdPessoa( @icard ) ) and
					( DataInic < convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataInic = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraInic <= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) ) and
					( DataFina > convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataFina = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraFina >= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) or ( DataFina = '1900-12-31' ) ) and
					StatAtuaCont = 0
				  order by
					DataInic, HoraInic

				if @vIdColab <> 0
				  begin

					update suricato.TbMensaColab set StatAtuaCont = 1 where IdColab = @vIdColab and DataInic = @vDataInic and HoraInic = @vHoraInic;   

				  end
				  else
				  begin

					update
						suricato.TbMensaColab
					  set
						StatAtuaCont = 0
					  where
						IdColab = ( select IdColab from suricato.TbColab where IdPessoa = suricato.getIdPessoa( @icard ) ) and
						( DataInic < convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataInic = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraInic <= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) ) and
						( DataFina > convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataFina = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraFina >= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) or ( DataFina = '1900-12-31' ) ) and
						StatAtuaCont = 2;

					select 
						TOP 1 @vIdColab = IdColab, @vDataInic = DataInic, @vHoraInic = HoraInic 
						  from 
							suricato.TbMensaColab
					  where
						IdColab = ( select IdColab from suricato.TbColab where IdPessoa = suricato.getIdPessoa( @icard ) ) and
						( DataInic < convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataInic = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraInic <= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) ) and
						( DataFina > convert( datetime, convert( varchar(10), getdate(), 120 ) ) or ( DataFina = convert( datetime, convert( varchar(10), getdate(), 120 ) ) and HoraFina >= ( datepart( hour, getdate() ) * 60 + datepart( minute, getdate() ) ) ) or ( DataFina = '1900-12-31' ) ) and
						StatAtuaCont = 0
					  order by
						DataInic, HoraInic
            
					update suricato.TbMensaColab set StatAtuaCont = 1 where IdColab = @vIdColab and DataInic = @vDataInic and HoraInic = @vHoraInic; 

				  end

				fetch next from cur_MessageController into @icard

			  end

			  close cur_MessageController
 
			  deallocate cur_MessageController

			end
			-- <<< Suricato Message Controller


			-- >>> Baixa de Crédito de Refeitório de Colaborador
				  if  @codac = '01' 
				  begin

					  -- 

					  insert into suricato.TbCredCColab (IdColab, DataCons, HoraCons, SeguCons, ContCred, StatHist)
						  select HC.IdColab, @DataAces, @HoraAces, @segundo, AC.ContCredRefe, 1
							  from 
								  suricato.TbHistoCrach HC
							  inner join suricato.TbAcessColab AC
								  on HC.IdColab = AC.IdColab
							  where
								  HC.ICard = @ICardReal 
								  and ( HC.DataInic < @DataAces or ( HC.DataInic = @DataAces and HC.HoraInic <= ( @HoraAces * 60 ) ) ) 
								  and ( HC.DataFina > @DataAces or ( HC.DataFina = @DataAces and HC.HoraFina >= ( @HoraAces * 60 ) ) or ( HC.DataFina = '1900-12-31' ) ) 
								  and exists (select 1 from suricato.TbCodin where CodiPlan = @CodiPlan and CodiCole = @CodiCole and LocaCole = 2 )

				  end
			-- <<< Baixa de Crédito de Refeitório de Colaborador



			-- >>> Identificação de Pessoa Por Ambiente
			if exists ( select 1 from suricato.TbParamServi where Nome = 'PESSOA_AMBIENTE' and Valo = 'S' ) and @codac = '01' 
			begin

			  declare @vIdPessoa numeric(9)

			  declare @vCodiAmbi numeric(8) 

			  select @vIdPessoa = suricato.getIdPessoa( @icard )

			  select @vCodiAmbi = CodiAmbi from suricato.TbAmbieColet where CodiPlan = @CodiPlan and CodiCole = @CodiCole

			  if (@vIdPessoa is not null) and (@vCodiAmbi is not null)
			  begin

				delete from suricato.TbPessoaAmbie where IdPessoa = @vIdPessoa

				if (@posic = '0')
				begin
				  insert into suricato.TbPessoaAmbie ( IdPessoa, CodiAmbi ) values ( @vIdPessoa, @vCodiAmbi )
				end
				else
				begin
				  select @vCodiAmbi = CodiAmbiPai from suricato.TbAmbie where CodiAmbi = @vCodiAmbi
				  if (@vCodiAmbi is not null)
				  begin
					insert into suricato.TbPessoaAmbie ( IdPessoa, CodiAmbi ) values ( @vIdPessoa, @vCodiAmbi )
				  end
				end

			  end

			end
			-- <<< Identificação de Pessoa Por Ambiente



			-- >>> Contador de Presenca por Ambiente
			if @codac = '01' 
			   and exists ( select 1 from suricato.TbParamServi 
							  where 
								Nome = 'CONTADOR_PRESENCA_AMBIENTE' 
								and Valo = 'S' )
			begin
			  SELECT @vCodiAmbi = CODIAMBI FROM SURICATO.TBAMBIECOLET WHERE CODIPLAN = @CodiPlan AND CODICOLE = @CodiCole
			  IF (@vCodiAmbi IS NOT NULL)
			  BEGIN
				EXECUTE SURICATO.SP_CONTADOR_PRESENCA_AMBIENTE @ICardReal, @DataAces, @HoraAces, @segundo, vCodiAmbi, @posic
			  END
			end
			-- <<< Contador de Presenca por Ambiente



			-- >>> Contador de Presenca
			if @codac = '01' 
			   and exists ( select 1 from suricato.TbParamServi 
							  where 
								Nome = 'CONTADOR_PRESENCA' 
								and Valo = 'S' 
								and exists (select 1 from suricato.TbCodin where CodiPlan = @CodiPlan and CodiCole = @CodiCole and LocaCole = 1 ) ) 
			begin
			  EXECUTE SURICATO.SP_CONTADOR_PRESENCA @ICardReal, @DataAces, @HoraAces, @segundo, @CodiPlan, @posic
			end
			-- <<< Contador de Presenca
        
				
				
			-- >>> Controlar 1 Entrada de Veículo por Pessoa
			if @codac = '01' 
			   and exists ( select 1 from suricato.TbParamServi 
							  where 
								Nome = 'CONTROLADUPLAENTRADAVEICULO' 
								and Valo = 'S' 
								and exists (select 1 from suricato.TbCodin where CodiPlan = @CodiPlan and CodiCole = @CodiCole and DuplEntrVeic = 'S' ) ) 
			begin

			  if (@posic = '0')
			  begin

							insert into suricato.TbBloquCrach ( ICard, DataBloq, HoraBloq, CodiMoti, DataLibe, HoraLibe, StatAtuaCont, NumeFisiCrac )
								select 
										HV.ICardV, @DataAces, @HoraAces, 1004, '1900-12-31', 0, 1, 0
									from 
										suricato.TbHistoRespVeicu HRV 
					inner join suricato.TbHistoVeicu HV
					  on HRV.IdVeic = HV.IdVeic
									where
										HRV.IdColab in (
									
											select 
													HRV.IdColab
												from 
													suricato.TbHistoRespVeicu HRV
												inner join suricato.TbHistoVeicu HV
													on HRV.IdVeic = HV.IdVeic
												where
													HV.ICardV = @ICardReal 
													and ( HRV.DataInic < @DataAces or ( HRV.DataInic = @DataAces and HRV.HoraInic <= @HoraAces ) ) 
													and ( HRV.DataFim > @DataAces or ( HRV.DataFim = @DataAces and HRV.HoraFina >= @HoraAces ) or ( HRV.DataFim = '1900-12-31' ) ) 
							
										)
										and HV.ICardV <> @ICardReal  
										and ( HRV.DataInic < @DataAces or ( HRV.DataInic = @DataAces and HRV.HoraInic <= @HoraAces ) ) 
										and ( HRV.DataFim > @DataAces or ( HRV.DataFim = @DataAces and HRV.HoraFina >= @HoraAces ) or ( HRV.DataFim = '1900-12-31' ) )
										and not exists (
										  select 1 from suricato.TbBloquCrach
											  where 
													ICard = HV.ICardV
													and ( DataBloq < @DataAces or ( DataBloq = @DataAces and HoraBloq <= @HoraAces ) ) 
													and ( DataLibe > @DataAces or ( DataLibe = @DataAces and HoraLibe >= @HoraAces ) or ( DataLibe = '1900-12-31' ) )												
							and CodiMoti = 1004
										)

			  end
			  else
			  begin

							update suricato.TbBloquCrach
								set DataLibe = @DataAces, HoraLibe = @HoraAces - 1, StatAtuaCont = 2
								where 
									exists
									(
											select 
														1
													from 
														suricato.TbHistoRespVeicu HRV
							inner join suricato.TbHistoVeicu HV
							  on HRV.IdVeic = HV.IdVeic
													where
														HRV.IdColab in (
													
															select 
																	HRV.IdColab
																from 
																	suricato.TbHistoRespVeicu HRV
																inner join suricato.TbHistoVeicu HV
																	on HRV.IdVeic = HV.IdVeic
																where
																	HV.ICardV = @ICardReal 
																	and ( HRV.DataInic < @DataAces or ( HRV.DataInic = @DataAces and HRV.HoraInic <= @HoraAces ) ) 
																	and ( HRV.DataFim > @DataAces or ( HRV.DataFim = @DataAces and HRV.HoraFina >= @HoraAces ) or ( HRV.DataFim = '1900-12-31' ) )
																
														)
														and HV.ICardV <> @ICardReal  
														and HV.ICardV = ICard
														and ( HRV.DataInic < @DataAces or ( HRV.DataInic = @DataAces and HRV.HoraInic <= @HoraAces ) ) 
														and ( HRV.DataFim > @DataAces or ( HRV.DataFim = @DataAces and HRV.HoraFina >= @HoraAces ) or ( HRV.DataFim = '1900-12-31' ) )
									)
									and ( DataBloq < @DataAces or ( DataBloq = @DataAces and HoraBloq <= @HoraAces ) ) 
									and ( DataLibe > @DataAces or ( DataLibe = @DataAces and HoraLibe >= @HoraAces ) or ( DataLibe = '1900-12-31' ) )														
					and CodiMoti = 1004

			  end

			end
			-- <<< Controlar 1 Entrada de Veículo por Pessoa	


			-- >>> Controlar Baixa de Saída de Veículo de Visitante
			if @codac = '01' 
			   and @posic = '1'
			   and @ICardVeiculo > 0
			   and exists ( select 1 from suricato.TbParamServi 
							  where 
								Nome = 'BAIXAR_VEICULO_VISITANTE' 
								and Valo = 'S' 
								and exists (select 1 from suricato.TbCodin where CodiPlan = @CodiPlan and CodiCole = @CodiCole and LocaCole = 1 and BaixAutoCrac = 'S') ) 
			begin

			  update suricato.TbHistoVeicu set DataFim = @DataAces, HoraFina = @HoraAces - 1 
				where 
				  ICardV = @ICardVeiculo
				  and ( DataInic < @DataAces or ( DataInic = @DataAces and HoraInic <= @HoraAces ) ) 
								and ( DataFim > @DataAces or ( DataFim = @DataAces and HoraFina >= @HoraAces ) or ( DataFim = '1900-12-31' ) )
								and TipoPess = 'V'

			end
			-- <<< Controlar Baixa de Saída de Veículo de Visitante

		  end

		end
   
   
		FIM:	 
		if @erro = 1
		begin
		  insert into suricato.TbMarcaRejei ( DataLogProc, ICard, DiaMarc, MesMarc, AnoMarc, HoraMarc, TipoAces, DireAces, BLUEB, CodiColeAlfa, NumeEndeIP, CodiFunc, DescLog, NomeTabeTele, DataAlar, EntrAlar, OcorAlar, NomeListBene, StatDeveBene, SeguMarc, Veic, PesoRefe, ValoKiloRefe, ValoRefe, QuanSobr, NiveAces, FaixHoraRefe, QuanCred, SituCrac, QuanMens )
			values ( convert( numeric( 14, 6 ) , getdate() ), @icard, @diam, @mesm, @anom, @horam, @codac, @posic, @blueb, @codtt, @end_ip, @CodiFunc, @deslog, 'dam00', null, null, null, null, null, @segundo, @veiculo, null, null, null, null, null, null, null, null, null )
		end


		fetch next from cur_dam00_ins_new into @icard, @diam, @mesm, @anom, @horam, @segundo, @codac, @posic, @blueb, @codtt, @end_ip, @CodiFunc, @onoff, @veiculo


	  end

	  close cur_dam00_ins_new
 
	  deallocate cur_dam00_ins_new

GO


-----------------------------------------------------------------------------------
-- 2.10.11.8 || 2.10.11.8 || 2.10.11.8 || 2.10.11.8 || 2.10.11.8 || 2.10.11.8 || --
-----------------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Inclusion date:  27/05/2021 - 09:36
-- Change date:     27/05/2021 - 09:36
-- Sequence:        0472
-- Redmine:         @11665
-----------------------------------------------------------------------------

/*
{ 
  "database"    : "MSSQL",
  "owner"       : "TELESSVR",
  "type"        : "TRIGGER",
  "name"        : "CONTDIG_SAGEM_TBTEMPL",
  "description" : "CONTDIG_SAGEM_TBTEMPL",
  "version"     : "1.0.5.0",
  "log"         : {
                   "1.0.5.0" : { "author" : "Nathan Gabriel", "created" : "27/05/2021", "issue" : "@11665", "description" : "Solucionar o problema no nome do cursor"}
                  }
}
*/
IF EXISTS (SELECT * FROM SYS.OBJECTS WHERE UPPER(OBJECT_ID) = OBJECT_ID('TELESSVR.CONTDIG_SAGEM_TBTEMPL'))
	DROP TRIGGER TELESSVR.CONTDIG_SAGEM_TBTEMPL
GO
 
CREATE TRIGGER TELESSVR.CONTDIG_SAGEM_TBTEMPL ON TELESSVR.CONTDIG_SAGEM FOR INSERT, UPDATE
AS

BEGIN
--VERSION_CONTROL 1.0.5.0 VERSION_CONTROL

	DECLARE @L_ICARD CHAR(12)
	DECLARE @L_TITULAR VARCHAR(MAX)
	DECLARE @L_ALTERNATIVO VARCHAR(MAX)
	DECLARE @L_STATUS CHAR(1)
	DECLARE @L_IDPESSOA NUMERIC(9,0)  
  
	IF UPPER( CURRENT_USER ) = 'SURICATO'
	RETURN;
  
	DECLARE CCONTDIG_SAGEM_TBTEMPL CURSOR
	FOR SELECT 
		ICARD, 
		TEMPL_TIT1 + TEMPL_TIT2 + TEMPL_TIT3 + TEMPL_TIT4,
		TEMPL_ALT1 + TEMPL_ALT2 + TEMPL_ALT3 + TEMPL_ALT4,
		STATUS
		FROM INSERTED

	OPEN CCONTDIG_SAGEM_TBTEMPL

		FETCH NEXT FROM CCONTDIG_SAGEM_TBTEMPL INTO @L_ICARD, @L_TITULAR, @L_ALTERNATIVO, @L_STATUS

		WHILE @@FETCH_STATUS = 0
		BEGIN
			SELECT @L_IDPESSOA = SURICATO.GETIDPESSOA( @L_ICARD )
			IF @L_IDPESSOA > 0
			BEGIN
				IF EXISTS ( SELECT 1 FROM SURICATO.TBTEMPL WHERE IDPESSOA = @L_IDPESSOA AND TIPOBIOM = '6')
				BEGIN
					UPDATE SURICATO.TBTEMPL SET TEMPTITU = @L_TITULAR, TEMPALTE = @L_ALTERNATIVO WHERE IDPESSOA = @L_IDPESSOA AND TIPOBIOM = '6'
				END
				ELSE
				BEGIN
					INSERT INTO SURICATO.TBTEMPL( IDPESSOA, TEMPTITU, QUALTEMPTITU, TEMPALTE, QUALTEMPALTE, TIPOBIOM, STATUS ) SELECT @L_IDPESSOA, @L_TITULAR, 0, @L_ALTERNATIVO, 0, '6', 1
				END
			END 
			FETCH NEXT FROM CCONTDIG_SAGEM_TBTEMPL INTO @L_ICARD, @L_TITULAR, @L_ALTERNATIVO, @L_STATUS
		END
  
	CLOSE CCONTDIG_SAGEM_TBTEMPL
 
	DEALLOCATE CCONTDIG_SAGEM_TBTEMPL
END
GO

-----------------------------------------------------------------------------------
-- 2.10.11.9 || 2.10.11.9 || 2.10.11.9 || 2.10.11.9 || 2.10.11.9 || 2.10.11.9 || --
-----------------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- CONEX REP V.08.03.01 || CONEX REP V.08.03.01 || CONEX REP V.08.03.01 || --
-----------------------------------------------------------------------------

if object_id('TELESSVR.sqlrolha_alarme2_tcp', 'p') is null
    exec ('create procedure TELESSVR.sqlrolha_alarme2_tcp as select 1')
go

ALTER PROCEDURE TELESSVR.sqlrolha_alarme2_tcp @EndIp CHAR(15), @cReg VARCHAR(35) OUTPUT, @cInfo VARCHAR(15) OUTPUT
AS

DECLARE @xret int

BEGIN
	
	SET @xret = 0
	SET @cInfo = NULL
	
	IF EXISTS (select * from CP_NB where END_IP = @EndIp AND ST = '1' AND TIPO_CC = '0')
	begin
		--SELECT @cReg = END_IP + ST + CC + TIPO_CC + ACAO + 'X'   	
		SELECT @cReg = END_IP + ST + CC + TIPO_CC + ACAO + space(1)   	
			FROM CP_NB 
			WHERE END_IP = @EndIp AND ST = '1' AND TIPO_CC = '0'
		-- e'incrementado 'X' em cReg pois há truncamento de valor se este terminar com espacos 
		UPDATE CP_NB SET ST = '2'
			WHERE END_IP = @EndIp AND ST = '1' AND TIPO_CC = '0'
		--select @mens = 'END_IP '+ @EndIp + ' foi encontrado' 
		
		
		-- COLETA INFORMACOES ADICIONAIS
		IF EXISTS (select * from CP_NBAUX where END_IP = @EndIp)
		begin
			SELECT @cInfo = INFORM from CP_NBAUX where END_IP = @EndIp
		end
	end

	ELSE    -- nao achou registro
	begin
		IF EXISTS (select * from CP_NB where END_IP = @EndIp AND ST = '1' AND TIPO_CC = '1')
		begin
			--SELECT @cReg = END_IP + ST + CC + TIPO_CC + ACAO + 'X'   	
			SELECT @cReg = END_IP + ST + CC + TIPO_CC + ACAO + space(1)   	
				FROM CP_NB 
				WHERE END_IP = @EndIp AND ST = '1' AND TIPO_CC = '1'
			
			-- e'incrementado 'X' em cReg pois há truncamento de valor se este terminar com espacos 
			UPDATE CP_NB SET ST = '2' WHERE END_IP = @EndIp AND ST = '1' AND TIPO_CC = '1'
			--select @mens = 'END_IP '+ @EndIp + ' foi encontrado' 	
			
			-- COLETA INFORMACOES ADICIONAIS
			IF EXISTS (select * from CP_NBAUX where END_IP = @EndIp)
			begin
				SELECT @cInfo = INFORM from CP_NBAUX where END_IP = @EndIp
			end
			
		end
		
		ELSE	
		begin
			select @xret = 1
			--select @mens = 'END_IP '+ @EndIp + ' nao encontrado'
			select @cReg = NULL
		end
	end
	
	return (@xret)
END
GO


-----------------------------------------------------------------------------------
-- CONEX ACESSO V.40.02.01 || CONEX ACESSO V.40.02.01 || CONEX ACESSO V.40.02.01 ||
-----------------------------------------------------------------------------------


-- *****************   TABELA  ESTAC003 
IF EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'ESTAC003_IND1')
    DROP INDEX TELESSVR.ESTAC003.ESTAC003_IND1;
GO

IF EXISTS (SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'ESTAC003' AND UPPER(COLUMN_NAME) = 'GREST')
    ALTER TABLE TELESSVR.ESTAC003 ALTER COLUMN GREST CHAR(6)
GO

IF NOT EXISTS (SELECT 1 FROM SYS.INDEXES WHERE UPPER(NAME) = 'ESTAC003_IND1')
    CREATE UNIQUE INDEX ESTAC003_IND1 ON TELESSVR.ESTAC003 (ICARD, GREST)
GO


-- *****************   TABELA  DAT07 
ALTER TABLE TELESSVR.DAT07 DROP constraint bio_tipo1;
GO
ALTER TABLE TELESSVR.DAT07 with nocheck add constraint bio_tipo1 CHECK (BIO_TIPO IN ('0','1','2','3','4','5','6','7','8','9','A','C','D'))
GO


-- *****************   TABELA  CONTDIG_OUTROS 

IF NOT EXISTS (select column_name from INFORMATION_SCHEMA.columns where UPPER(table_name) = 'CONTDIG_OUTROS'  and UPPER(column_name) = 'DIGITALBIN_PAD')
	ALTER TABLE TELESSVR.CONTDIG_OUTROS ADD DIGITALBIN_PAD VARBINARY(MAX);
GO

IF NOT EXISTS (select column_name from INFORMATION_SCHEMA.columns where UPPER(table_name) = 'CONTDIG_OUTROS'  and UPPER(column_name) = 'DIGITALBIN_ALT')
	ALTER TABLE TELESSVR.CONTDIG_OUTROS ADD DIGITALBIN_ALT VARBINARY(MAX);
GO	


ALTER TABLE TELESSVR.CONTDIG_OUTROS DROP constraint digoutros_TPDIG;
GO
ALTER TABLE TELESSVR.CONTDIG_OUTROS with nocheck add constraint digoutros_TPDIG CHECK (BIO_TIPO IN ('9','C','D'))
GO



IF EXISTS (SELECT name FROM sysobjects WHERE name = 'TRGMATGRP_I' AND type = 'TR')
    DROP TRIGGER TELESSVR.TRGMATGRP_I
GO

CREATE TRIGGER TELESSVR.TRGMATGRP_I ON TELESSVR.MATGRUPO AFTER INSERT
AS
DECLARE @ICARD CHAR(12)

DECLARE CURSOR_INSMATG CURSOR FOR SELECT ICARD FROM INSERTED  ORDER BY ICARD
				
	OPEN CURSOR_INSMATG
	FETCH NEXT FROM CURSOR_INSMATG into @ICARD

	WHILE @@FETCH_STATUS = 0	
	BEGIN

		-- OBS: O STATUS SERÁ 3 (ALTERADO GRUPO) E NAO 1 (INCLUSAO DE DIGITAL EM TABELA DIGITAL)
		UPDATE CONTDIG_SAGEM 	SET STATUS = '3' WHERE ICARD = @ICARD;
		UPDATE CONTDIG_TSI1  	SET STATUS = '3' WHERE ICARD = @ICARD;
		UPDATE PALMV001      	SET ST = '3'     WHERE ICARD = @ICARD;
		UPDATE CONTDIG_OUTROS  	SET STATUS = '3' WHERE ICARD = @ICARD;

		FETCH NEXT FROM CURSOR_INSMATG into @ICARD
	END
	CLOSE CURSOR_INSMATG
	DEALLOCATE CURSOR_INSMATG
	
GO

IF EXISTS (SELECT name FROM sysobjects WHERE name = 'TRGMATGRP_U' AND type = 'TR')
    DROP TRIGGER TELESSVR.TRGMATGRP_U
GO

CREATE TRIGGER TELESSVR.TRGMATGRP_U ON TELESSVR.MATGRUPO AFTER UPDATE
AS
DECLARE @ICARD CHAR(12)


	IF UPDATE (GRUPO) OR UPDATE (ICARD)
	BEGIN
		DECLARE CURSOR_UPMATG CURSOR FOR SELECT ICARD FROM INSERTED  ORDER BY ICARD
				
		OPEN CURSOR_UPMATG
		FETCH NEXT FROM CURSOR_UPMATG into @ICARD

		WHILE @@FETCH_STATUS = 0	
		BEGIN

			-- OBS: O STATUS SERÁ 3 (ALTERADO GRUPO) E NAO 8 (EXCLUSAO DE DIGITAL EM TABELA DIGITAL)
			UPDATE CONTDIG_SAGEM 	SET STATUS = '3' WHERE ICARD = @ICARD;
			UPDATE CONTDIG_TSI1  	SET STATUS = '3' WHERE ICARD = @ICARD;
			UPDATE PALMV001      	SET ST = '3'     WHERE ICARD = @ICARD;
			UPDATE CONTDIG_OUTROS  	SET STATUS = '3' WHERE ICARD = @ICARD;

			FETCH NEXT FROM CURSOR_UPMATG into @ICARD
		END
		CLOSE CURSOR_UPMATG
		DEALLOCATE CURSOR_UPMATG
	END
GO

IF EXISTS (SELECT name FROM sysobjects WHERE name = 'TRGMATGRP_D' AND type = 'TR')
    DROP TRIGGER TELESSVR.TRGMATGRP_D
GO

CREATE TRIGGER TELESSVR.TRGMATGRP_D ON TELESSVR.MATGRUPO AFTER DELETE
AS
DECLARE @ICARD CHAR(12)

DECLARE CURSOR_DELMATG CURSOR FOR SELECT ICARD FROM DELETED  ORDER BY ICARD
				
	OPEN CURSOR_DELMATG
	FETCH NEXT FROM CURSOR_DELMATG into @ICARD

	WHILE @@FETCH_STATUS = 0	
	BEGIN

		-- OBS: O STATUS SERÁ 3 (ALTERADO GRUPO) E NAO 8 (EXCLUSAO DE DIGITAL EM TABELA DIGITAL)
		UPDATE CONTDIG_SAGEM 	SET STATUS = '3' WHERE ICARD = @ICARD;
		UPDATE CONTDIG_TSI1  	SET STATUS = '3' WHERE ICARD = @ICARD;
		UPDATE PALMV001      	SET ST = '3'     WHERE ICARD = @ICARD;
		UPDATE CONTDIG_OUTROS  	SET STATUS = '3' WHERE ICARD = @ICARD;

		FETCH NEXT FROM CURSOR_DELMATG into @ICARD
	END
	
	CLOSE CURSOR_DELMATG
	DEALLOCATE CURSOR_DELMATG
GO

if object_id('TELESSVR.sqlolha_alarme_tcp2', 'p') is null
    exec ('create procedure TELESSVR.sqlolha_alarme_tcp2 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlolha_alarme_tcp2 @EndIp CHAR(15), @cReg CHAR(35) OUTPUT
AS
DECLARE @xEndIp CHAR(15), @xret int

BEGIN
	SET @xret = 0
	IF EXISTS (select * from CP_NB  
		where END_IP = @EndIp AND ST = '1' AND TIPO_CC = '0')
	begin
		--SELECT @cReg = END_IP + ST + CC + TIPO_CC + ACAO + 'X'   	
		SELECT @cReg = END_IP + ST + CC + TIPO_CC + ACAO + space(1)
			FROM CP_NB 
			WHERE END_IP = @EndIp AND ST = '1' AND TIPO_CC = '0'
			-- e'incrementado space(1) em cReg pois há truncamento de valor se este terminar com espacos 
		
		UPDATE CP_NB SET ST = '2'
			WHERE END_IP = @EndIp AND ST = '1' AND TIPO_CC = '0'
	end
	ELSE 	-- nao achou registro
	begin
		IF EXISTS (select * from CP_NB 
		    where END_IP = @EndIp AND ST = '1' AND TIPO_CC = '1')
		begin
			--SELECT @cReg = END_IP + ST + CC + TIPO_CC + ACAO + 'X'   	
			SELECT @cReg = END_IP + ST + CC + TIPO_CC + ACAO + space(1)
				FROM CP_NB 
				WHERE END_IP = @EndIp AND ST = '1' AND TIPO_CC = '1'
				-- e'incrementado space(1) em cReg pois há truncamento de valor se este terminar com espacos 
		
			UPDATE CP_NB SET ST = '2'
				WHERE END_IP = @EndIp AND ST = '1' AND TIPO_CC = '1'
		end
		ELSE	
		begin
			SET @xret = 1
			SET @cReg = NULL
		end
	end
	return (@xret)

END
GO

if object_id('TELESSVR.SQLMAT_GRUPO_tcp', 'p') is null
    exec ('create procedure TELESSVR.SQLMAT_GRUPO_tcp as select 1')
go

ALTER PROCEDURE TELESSVR.SQLMAT_GRUPO_tcp @cMatric char(12), @cData char(12), @cEndIp char(15)
AS

DECLARE @i int, @achou int, @k int, @ini int, @fim int
DECLARE @hora_ini varchar(4), @hora_fim varchar(4), @cGrupo char(3), @cFaixa char(56)
DECLARE @dDataOcor DATETIME

	
	SET DATEFORMAT DMY
	SET @achou = 0
	SET @dDataOcor = CAST((substring(@cData,1,2)+'-'+
							 substring(@cData,3,2)+'-'+
							 substring(@cData,5,2)+' '+
							 substring(@cData,7,2)+':'+
							 substring(@cData,9,2)+':'+
							 '00') AS datetime);

	-- cursor para matgrupo 
	DECLARE cur_MATGRUPO cursor FOR 
		SELECT a.GRUPO, a.FXPERM 
		FROM  TABGRPSETFX a, MATGRUPO b 
		WHERE a.END_IP = @cEndIp  AND 
			  b.ICARD = @cMatric AND 
			  convert(int, b.GRUPO) = convert(int, a.GRUPO) AND
			  @dDataOcor >= b.DATINI AND
			  @dDataOcor <= b.DATFIM 
			  
	OPEN cur_MATGRUPO
	FETCH NEXT FROM cur_MATGRUPO INTO @cGrupo, @cFaixa
	WHILE (@@fetch_status != -1) and (@achou != 1) 
	begin
		SET @achou = 2
		SET @i = 0
		WHILE (@i < 7)				-- verifica enquanto nao esgotar as 7 faixas horarias ou até encontrar a faixa
		begin
			SET @k = (8 * @i)		-- vai 'andar' de 8 em 8 porque a faixa é hhmmhhmm
			SET @ini = @k + 1;		-- posicao de inicio de faixa
			SET @fim = @k + 5;		-- posicao de fim  de faixa

			SET @hora_ini = substring(@cFaixa, @ini, 4);	-- string de hhmi inicial
			SET @hora_fim = substring(@cFaixa, @fim, 4);	-- string de hhmi final
			
			if @hora_ini = '2400' 
				SET @hora_ini = '2359'
			if @hora_fim = '2400' 
				SET @hora_fim = '2359'
			
			-- verifica se hora/minuto da ocorrencia está dentro da faixa de pesquisa
			IF ((substring(@cData,7,4) >= @hora_ini) and	
				(substring(@cData,7,4) <= @hora_fim) )
			begin				
				SET @i = 7			-- indica parada de busca
				SET @achou = 1		-- indica parada de busca do cursor
			end
			else
				SET @i = @i + 1;	-- vai para proxima faixa horaria
		end
		FETCH NEXT FROM cur_MATGRUPO INTO @cGrupo, @cFaixa
	end
	
	CLOSE cur_MATGRUPO
	DEALLOCATE cur_MATGRUPO


	SELECT @achou
	GO
			

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqlproc_digitPALMV', 'p') is null
    exec ('create procedure TELESSVR.sqlproc_digitPALMV as select 1')
go

ALTER PROCEDURE TELESSVR.sqlproc_digitPALMV @cMat VARCHAR(12), @cEndIp VARCHAR(15)  AS
DECLARE @Ret INT, @nTotalPad INT , @nTotalAlt INT 
DECLARE @nAuxTotalPad INT , @nAuxTotalAlt INT 
DECLARE @cPad VARBINARY(MAX), @cAlt VARBINARY(MAX)

	set @nTotalPad = 0
	set @nTotalAlt = 0
	set @cPad = 0
	set @cAlt = 0
	set @Ret = 0
	

	SELECT @cPad = TEMPL_PAD, @cAlt = TEMPL_ALT 
		FROM PALMV001 --nolock
		WHERE ICARD = @cMat
	
	IF (@@ROWCOUNT = 1) begin	
		if (@cPad != 0) 
			--set @nTotalPad = datalength (@cPad)
			set @nTotalPad = len (@cPad)
		
		if (@cAlt != 0) 
			--set @nTotalAlt = datalength (@cAlt)
			set @nTotalAlt = len (@cAlt)
		

		set @Ret = 1;
	end
	
	
	IF (@Ret = 0) BEGIN
		-- insere em tabela DIGLOAD001
		INSERT INTO DIGLOAD001 (END_IP, ICARD, BIO_TIPO) 
			VALUES (@cEndIp, @cMat, 'A');
	END

	SELECT @Ret, @cPad, @cAlt, @nTotalPad, @nTotalAlt

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


if object_id('TELESSVR.trata_OutrosBios', 'p') is null
    exec ('create procedure TELESSVR.trata_OutrosBios as select 1')
go

ALTER PROCEDURE TELESSVR.trata_OutrosBios AS

DECLARE @ret CHAR(1)
DECLARE @z_endip CHAR(15)
DECLARE @z_biotipo CHAR(1)
DECLARE @z_status CHAR(1)

DECLARE @z_mat CHAR(12)
DECLARE @aux_icard CHAR(12)
DECLARE @aux_endip CHAR(15)

SET DATEFORMAT YMD

	SET LOCK_TIMEOUT 3000


	-- ********************   ARRUMAR SITUAÇÕES PARA outras bios    -  INCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS  QUE FICARAM PENDENTES NA CARGA E QUE NAO SERAO REENVIADAS AUTOMATICAMENTE
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE EQUIPAMENTO REJEITOU A CARGA  (status '4')
	DECLARE cur_troubleIns1 CURSOR FOR 
		(SELECT distinct ICARD from DIG004 
			WHERE STATUS = '4'
		)
	OPEN cur_troubleIns1
	FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	WHILE (@@fetch_status != -1) BEGIN
		DECLARE cur_troubleIns2 CURSOR FOR 
			(SELECT END_IP from DIG004 
				WHERE (ICARD = @z_mat and STATUS = '4')
			)
		OPEN cur_troubleIns2
		FETCH NEXT FROM cur_troubleIns2 INTO @z_endip

		WHILE (@@fetch_status != -1) BEGIN
			DELETE DIG004 WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '4')

			UPDATE DIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

			FETCH NEXT FROM cur_troubleIns2 INTO @z_endip
		END


		CLOSE cur_troubleIns2
		deallocate cur_troubleIns2

		FETCH NEXT FROM cur_troubleIns1 INTO @z_mat
	END
	
	CLOSE cur_troubleIns1
	deallocate cur_troubleIns1

	

	-- ***********************  TRATA AS BIOMETRIAS  QUE FICARAM PENDENTES NA CARGA
	-- SITUACAO EM QUE CARGA FICOU PENDENTE PORQUE HOUVE DELETE DE REGISTROS DOS bios (DA TAB.CONTDIG_OUTROS CADASTRO)
	-- delete registro de DIG004 se nao houver cadastro de BIO  desta matricula
	DECLARE cur_autoIns1 CURSOR FOR 
		(SELECT distinct ICARD, BIO_TIPO from DIG004 
			WHERE STATUS = '3'
		)
	OPEN cur_autoIns1
	FETCH NEXT FROM cur_autoIns1 INTO @z_mat, @z_biotipo
	WHILE (@@fetch_status != -1) BEGIN
		
		-- VERIFICA SE HÁ CADASTRO DO BIO  DA MATRICULA
		SELECT @aux_icard = ICARD FROM CONTDIG_OUTROS 
			WHERE ICARD = @z_mat AND BIO_TIPO = @z_biotipo
			
		IF (@@ROWCOUNT = 0)	BEGIN
			-- nao ha cadastro de BIO  desta matricula
			DECLARE cur_autoIns2 CURSOR FOR 
				(SELECT END_IP from DIG004 
					WHERE (ICARD = @z_mat 	and 
						   STATUS = '3' 	and 
						   BIO_TIPO = @z_biotipo)
				)
			OPEN cur_autoIns2
			FETCH NEXT FROM cur_autoIns2 INTO @z_endip

			WHILE (@@fetch_status != -1) BEGIN
				DELETE DIG004 WHERE (END_IP = @z_endip and ICARD = @z_mat and STATUS = '3')

				UPDATE DIG002 set status = '1'WHERE (END_IP =  @z_endip AND STATUS = '3') ;

				FETCH NEXT FROM cur_autoIns2 INTO @z_endip
			END


			CLOSE cur_autoIns2
			deallocate cur_autoIns2
		END

		FETCH NEXT FROM cur_autoIns1 INTO @z_mat, @z_biotipo
	END
	
	CLOSE cur_autoIns1
	deallocate cur_autoIns1

	-- ***********************  TRATA AS BIOMETRIAS  QUE FICARAM PENDENTES NA INCLUSAO
	-- altera status de todos os codins para carga de digitais, se esses não estiverem com carga de digitais ou estiverem pendentes

	DECLARE cur_endip CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from DIG004 
			WHERE (STATUS != '0' and STATUS != '2') 
		)
	OPEN cur_endip
	FETCH NEXT FROM cur_endip INTO @z_endip, @z_biotipo, @z_status
	
	while @@fetch_status != -1
	begin
		UPDATE DIG002 set status = '1'
			WHERE (END_IP = @z_endip and 
					(STATUS = '0' or STATUS= '3') and 
					BIO_TIPO = @z_biotipo)
		FETCH NEXT FROM cur_endip INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE cur_endip
	deallocate cur_endip



	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO CARREGANDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de carregando '2' por mais de 2 minutos OU
	-- equipamentos  q tiveram carga de aplicativo 
	DECLARE cur_dig02 CURSOR FOR 
		(SELECT END_IP, BIO_TIPO, STATUS from DIG002 
			WHERE ((status = '5' or status = '6' or 		-- CARGA DE APLICATIVO
				   (status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate())) 
				   and 
				   ((BIO_TIPO != '8') and (BIO_TIPO != '6') and (BIO_TIPO != '7')) 
				  )
		)
	OPEN cur_dig02
	FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_biotipo, @z_status

	WHILE @@fetch_status != -1
	begin
		-- OBSERVACAO: PARA BIOMETRIA , A CARGA DE APLICATIVO NO EQUIPAMENTO NAO APAGA AS BIOMETRIAS, POIS BIOMETRIA  FICA NO LEITOR E NAO NO EQUIPAMENTO,
		-- LOGO NAO É NECESSARIO FAZER A RECARGA DE BIOMETRIA
		IF (@z_status = '2') begin		-- situação q estava fazendo a carga e deu problema

			UPDATE DIG004 set STATUS = '1'			-- status = 1 : a carregar
				WHERE (END_IP = @z_endip and STATUS = '2'  and BIO_TIPO = @z_biotipo) 

			UPDATE DIG002 set status = '1' 
				where (END_IP = @z_endip and BIO_TIPO = @z_biotipo)
		end

		ELSE begin
			IF (@z_status = '5' or @z_status = '6') begin		-- HOUVE CARGA DE APLICATIVO, MAS NAO VAI RECARREGAR AS BIOMETRIAS
				UPDATE DIG002 set status = '0' 
					WHERE (end_ip = @z_endip  and BIO_TIPO = @z_biotipo)
			end
		end
		
		FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_biotipo, @z_status
	end

	CLOSE cur_dig02
	DEALLOCATE cur_dig02
	


	-- ***********************  TRATA AS BIOMETRIAS QUE FICARAM EM ESTADO DE CARREGANDO E NAO SAI DESTA SITUAÇÃO
	-- para BIOMETRIAS   DE DIG004 que ficaram em estado carregando '2', e o equipamento está em estado de repouso	, forca o equipamento a carrega-lo novamente

	DECLARE cur_dig02 CURSOR FOR 
		(SELECT A.END_IP, A.STATUS, A.BIO_TIPO from DIG002 A 
			INNER JOIN DIG004 B ON
				A.END_IP = B.END_IP and 
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = B.BIO_TIPO)
	OPEN cur_dig02
	FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_status, @z_biotipo 

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG004 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' AND BIO_TIPO = @z_biotipo;
		UPDATE DIG002 set STATUS = '1' 
			WHERE END_IP = @z_endip  and BIO_TIPO = @z_biotipo;
			
		FETCH NEXT FROM cur_dig02 INTO @z_endip, @z_status, @z_biotipo;
	END
	CLOSE cur_dig02
	deallocate cur_dig02
	


	-- ********************   ARRUMAR SITUAÇÕES PARA   outras bios   -  EXCLUSAO
	-- ***********************  TRATA AS BIOMETRIAS  QUE FICARAM PENDENTES NA EXCLUSAO
	-- altera status dos codins Sagem para exclusao de biometria, se esses não estiverem com exclusao de biometria ou estiverem pendentes

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO from DIG104 
			--WHERE (STATUS != '0' and STATUS != '2' and BIO_TIPO = '8')
			WHERE (STATUS != '0' and STATUS != '2' and STATUS != '4')		-- statys 4 indica resposta do rep de nao implementado
		)
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG102 set STATUS = '1'
			WHERE (END_IP = @z_endip) and 
			  	  --(STATUS = '0' or STATUS = '3') and 
			  	  (STATUS = '0' or STATUS = '3' or STATUS = '4') and 		-- statys 4 indica resposta do rep de nao implementado
				  (BIO_TIPO = @z_biotipo)

		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo
	END
	CLOSE cur_autoExc1
	deallocate cur_autoExc1
	


	-- ********************   TRATA EQUIPAMENTOS TSI1 QUE FICARAM EM ESTADO EXCLUINDO OU SOFRERAM CARGA DE APLICATIVO
	-- equipamentos  q ficaram em estado de excluindo '2' por mais de 2 minutos ou
	-- equipamentos que sofreram exclusao/recarga de aplicativo 

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT distinct END_IP, BIO_TIPO, STATUS from DIG102 
			WHERE (((BIO_TIPO != '6') and (BIO_TIPO != '7') and (BIO_TIPO != '8')) 
					and
					(status = '5' or status = '6' or 													-- CARGA DE APLICATIVO
					(status = '2' and DATEADD (MINUTE, 2, data_load)  < getdate()))   
				  )			
		)			
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip,  @z_biotipo, @z_status

	while @@fetch_status != -1
	begin
		if (@z_status = '2') begin
			UPDATE DIG104 set status = '1'
				WHERE (END_IP = @z_endip) and (status = '2') and (BIO_TIPO = @z_biotipo)	-- deixa como status a carregar somente na situacao de problemas (status = '2')

			UPDATE DIG102 set status = '1' 
				WHERE (END_IP = @z_endip  and BIO_TIPO = @z_biotipo)
		end
				
		else if (@z_status = '5'  or @z_status = '6') begin
			UPDATE DIG102 set status = '0' where (end_ip = @z_endip and BIO_TIPO = @z_biotipo)	
		end;
				
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_biotipo, @z_status
	end
	CLOSE cur_autoExc1
	deallocate cur_autoExc1



	-- ***********************  TRATA AS BIOMETRIAS TSI1 QUE FICARAM EM ESTADO DE EXCLUINDO E NAO SAI DESTA SITUAÇÃO
	-- para digitais de DIG104 que ficaram em estado excluindo '2'	, forca o equipamento a exclui-lo novamente

	DECLARE cur_autoExc1 CURSOR FOR 
		(SELECT  A.END_IP, A.STATUS, A.BIO_TIPO from DIG102 A 
			INNER JOIN DIG104 B ON
				A.END_IP = B.END_IP and
				A.STATUS = '0' and 
				B.STATUS = '2' and
				A.BIO_TIPO = B.BIO_TIPO)
	OPEN cur_autoExc1
	FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status, @z_biotipo

	WHILE (@@fetch_status != -1) BEGIN
		UPDATE DIG104 SET STATUS = '1' 
			WHERE END_IP = @z_endip AND STATUS = '2' and BIO_TIPO = @z_biotipo;
		UPDATE DIG102 set STATUS = '1' 
			WHERE END_IP = @z_endip and BIO_TIPO = @z_biotipo;
	
		FETCH NEXT FROM cur_autoExc1 INTO @z_endip, @z_status, @z_biotipo;
	END
	CLOSE cur_autoExc1
	deallocate cur_autoExc1

	SET LOCK_TIMEOUT -1
	
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqlconG3G5_ace_usuario3', 'p') is null
    exec ('create procedure TELESSVR.sqlconG3G5_ace_usuario3 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlconG3G5_ace_usuario3 @cMatricNS char(22), @cInform char(20), @cTipTerm char(1), @cEndIp char(15), @cOwner char(30), @cDataOcorr char(10), @cVisita char(12) AS
DECLARE	@cReg1 as varchar(250), @cReg2 as varchar(250), @cReg3 as varchar(250), 
		@cReg4 as varchar(250), @RetFun SMALLINT,
		@cReg5 as varchar(250), @cReg6 as varchar(250), @cReg7 as varchar(250), @cReg8 as varchar(250),
		@cReg9 as varchar(250), @cReg10 as varchar(250), @cReg11 as varchar(250)
DECLARE @ret int, @cUsuLock char(15), @cFxDiaEsp char(28), @cFxCred char(4), @Result int, @cMatBusca char(12)
DECLARE	@cIniHalm char(12), @cFimHalm char(12), @cIniIntj char(12), @cFimIntj char(12), @cFimAntD char(12)
DECLARE	@cIniHalmAux char(16), @cFimHalmAux char(16), @cIniIntjAux char(16), @cFimIntjAux char(16), @cFimAntDAux char(16)
DECLARE @dDataBD DATETIME, @dDataOcor DATETIME;
DECLARE @pos int
DECLARE @cModo char(1), @cFazLock char(1), @cDesbloqRev char(1),@cVerNumS char(1)
DECLARE @cVarAux char(12)
--DECLARE @nGrest int, @nGrestEquip int, @nCont int
DECLARE @nGrEstFixa int, @nGrestEquip int, @nCont int
DECLARE @nArea int, @nAreaEquip int
--DECLARE	@cEmFixa char(1), @AuxGr char(3), @AuxGr2 varchar(3);
DECLARE	@cEmFixa char(1), @AuxGr char(6), @AuxGr2 varchar(6);
DECLARE @cEscoltado char(12), @cEscolta char(12), @cTemEsc char(1), @cEhEscolta char(1), @cProcurado char(12), @cSentido CHAR(1)
DECLARE @nContArea int, @cFinalSentido CHAR(1), @AuxSentido CHAR(1), @nAuxArea int
DECLARE @cSituaAux char(1)
DECLARE @cRegra char(1)

DECLARE
        @cMatric   char(12),
        @cIcard    char(12),
        @cCPF	   char(11),
        @cNumSerial	   char(10),
		@cBloqBDCC char(1),
        --@cGrupo    char(3),
        @cCodig    char(6),
        @cTpFis    char(1),
        @cSitua    char(1),
        --@cSubNv    char(5),
        --@cPlanta   char(3),
        @cDataHora char(10),
        @cUltrs    char(25),
        @cDatIni   char(6),
        @cDatFim   char(6),
        @cTitular  char(12),
        @cFx_Flg   char(1), 
        @cFx_Dta   char(11), 
        @cFx_Alm   char(3),
        @cMensagem char(32), 
        @cDta_mens char(6),
        @cQtd_mens char(2),
        @cCred_Fx1 char(2), 
        @cCred_Fx2 char(2),
        @cCred_Fx3 char(2),
        @cCred_Fx4 char(2),
        @cCred_Fx5 char(2),
        @cCred_Fx6 char(2),
        @cFx1 char(8), 
        @cFx2 char(8), 
        @cFx3 char(8), 
        @cFx4 char(8), 
        @cFx5 char(8), 
        @cFx6 char(8), 
        @cUltPasR  char(10),
        --@cGrupo1   char(3),
        @cDatIniG1 char(10),
        @cDatFimG1 char(10),
        --@cGrupo2   char(3),
        @cDatIniG2 char(10),
        @cDatFimG2 char(10),
        --@cGrupo3   char(3),
        @cDatIniG3 char(10),
        @cDatFimG3 char(10),
        --@cGpoSab   char(3),
        --@cGpoDom   char(3),
        --@cGpoFer   char(3),
        @cAnti_D   char(1),
        @cBloq     char(1),
        @cVHora    char(1),
        @cVLocal   char(1),
        @cVValid   char(1),
        @cVAfast   char(1),
        @cVCred    char(1),
        @cVisEsp   char(1),
        @cVPonto   char(1),
        @cPonto    char(1),	
        @cVDigit   char(1),
      	@cTpoIntj  char(3), 
      	@cTolIntj  char(3), 
      	@cInterj   char(1),
      	@cTpoJorn  char(3), 
      	@cSaidaMax   char(1),
      	@cTipoDoc	char(1),
		@cVnDias   char(2),
		@cDiasSuc  char(2),
		@cPne    char(1),
		@cBloqRev    char(1),
		@cvViaRep char(1)

DECLARE
@cGrupo    char(5),	-- novo
@cSubNv    char(7),	-- novo
@cGrupo1   char(5),	-- novo
@cGrupo2   char(5),	-- novo
@cGrupo3   char(5),	-- novo
@cGpoSab   char(5),	-- novo
@cGpoDom   char(5),	-- novo
@cGpoFer   char(5),	-- novo
@cAdBuf VARCHAR(2),			-- novo
@nTamG int,
@cPlanta   char(5)

/*
DECLARE
@cGrupo    varchar(5),	-- novo
@cSubNv    varchar(7),	-- novo
@cGrupo1   varchar(5),	-- novo
@cGrupo2   varchar(5),	-- novo
@cGrupo3   varchar(5),	-- novo
@cGpoSab   varchar(5),	-- novo
@cGpoDom   varchar(5),	-- novo
@cGpoFer   varchar(5),	-- novo
@cAdBuf CHAR(2),			-- novo
@nTamG int,
@cPlanta   varchar(5)
*/


DECLARE @stmt1 nvarchar(4000)
DECLARE @ParmDefinition nvarchar(500);



	SET LOCK_TIMEOUT 1000	
	SET @RetFun = 0
	SET @cReg1  = ''
	SET @cReg2  = ''
	SET @cReg3  = ''
	SET @cReg4  = ''

	SET @cReg5  = ''
	SET @cReg6  = ''
	SET @cReg7  = ''
	SET @cReg8  = ''
	SET @cUsuLock = @cEndIp

	SELECT @cAdBuf = null
	SELECT @nTamG = 3 
	SELECT	@nTamG  = COLUNAS.LENGTH
	FROM 
		SYSOBJECTS AS TABELAS,
		SYSCOLUMNS AS COLUNAS
	WHERE 
		-- JOINS 
		TABELAS.ID = COLUNAS.ID
		AND TABELAS.NAME = 'DAT07'
		AND COLUNAS.NAME = 'LACES'


	SET @Result = 1	
	SET @cMatric = substring(@cMatricNS, 1, 12);
	SET @cMatBusca = '000000000000'
	SET @cTipoDoc = '0'
	SET @cBloqBDCC = '0'
	SET @cFx1 = '24002400'
	SET @cFx2 = '24002400'
	SET @cFx3 = '24002400'
	SET @cFx4 = '24002400'
	SET @cFx5 = '24002400'
	SET @cFx6 = '24002400'

	set DATEFORMAT dmy
	SET @dDataOcor = CAST((substring(@cDataOcorr,5,2)+'-'+
							 substring(@cDataOcorr,7,2)+'-'+
							 substring(@cDataOcorr,9,2)+' '+
							 substring(@cDataOcorr,1,2)+':'+
							 substring(@cDataOcorr,3,2)+':'+
							 '00') AS datetime);

	SET @cModo = substring(@cInform, 1, 1);  -- TIPO DE PESQUISA
	-- cModo = 0 :icard; 
	-- cModo = 1 :numero serial
	-- cModo = 2 :cpf
	-- cModo = 3 :bdcc


	SET @cFazLock = 	substring(@cInform, 3, 1);  -- SE CONSULTA ONLINE
	SET @cDesbloqRev = 	substring(@cInform, 4, 1);  -- SE DESBLOQUEIO REVISTA
	SET @cVerNumS = 	substring(@cInform, 5, 1);  -- SE verifica NUMSERIAL
	SET @cEhEscolta =  	substring(@cInform, 6, 1);	-- SE É INDICADOR DE ESCOLTA

	-- *******************************************************
	-- verifica se modo de busca é por CPF
	IF (@cModo ='2') begin					-- CPF
		SELECT	@cIcard   = a.ICARD,
				@cCPF	  = c.CPF,
				@cTipoDoc = c.TIPODOC
				
			FROM ContCPF c 
				INNER JOIN Controle a
					ON c.CPF = substring(@cMatric, 2, 11) and c.icard = a.icard 

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end
	
	-- *******************************************************
	-- verifica se modo de busca é por ICARD
	ELSE IF (@cModo = '0') begin  			-- ICARD
		IF (@cVerNumS = '1') BEGIN
			SELECT	@cIcard   = a.ICARD,
					@cNumSerial  = a.NUMSERIAL
				FROM Controle a 
			WHERE a.ICARD = @cMatric and
   				  a.NumSerial = substring(@cMatricNS, 13, 10) 
				
			IF (@@ROWCOUNT = 0) begin
				-- SITUACAO SURICATO: VARIOS CARTOES SM COM MESMO ICARD, E NA CONTROLE ESTAO OS VALORES DE NUM.SERIAL NA COLUNA ICARD, TODOS COM O MESMO VALOR DO TITULAR
				-- A BUSCA PRIMEIRO SERA FEITA ICARD+NUMSERIAL. SE NÃO ACHOU, QUE É ONDE SE ENCONTRA AGORA, A BUSCA SERÁ SOBRE TITULAR+ICARD. QDO ENCONTRAR, O VALOR DE
				-- CMATBUSCA SERÁ O VALOR DO CAMPO ICARD

				SELECT	@cIcard   = a.TITULAR,
						@cVarAux  = a.ICARD,
						@cSituaAux  = a.SITUA
					FROM Controle a 
				WHERE a.TITULAR = @cMatric and
					  a.ICARD = '00'+substring(@cMatricNS, 13, 10) 

				IF (@@ROWCOUNT = 0) begin
					set @cIcard = '000000000000'	-- 12 zeros
					SET @RetFun = -2
					SET @Result = 0	
				end
				ELSE begin
					-- antes de atribuir @cMatBusca = @cIcard, deve-se verificar se a situação é invalida. 
					-- Se invalida, 	cMatBusca := VarAux, para que retorne situação invalida ao Conex										
					--	SET	@cMatBusca = @cIcard;
					IF (@cSituaAux = '1') 
						SET	@cMatBusca = @cVarAux;	
					ELSE
						SET	@cMatBusca = @cIcard;
				end
			end
			ELSE begin
				SET	@cMatBusca = @cIcard;
			end
		end	

		ELSE begin
			SET @cMatBusca = @cMatric;
		end
	end
				
	-- *******************************************************
	-- verifica se modo de busca é por NUMERO SERIAL
	ELSE IF (@cModo = '1') begin  			-- NUMERO SERIAL
		SELECT	@cIcard   = a.ICARD,
				@cNumSerial  = a.NUMSERIAL
				
			FROM Controle a 
				WHERE a.NumSerial = substring(@cMatric, 3, 10) 
	
		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end


	-- *******************************************************
	-- verifica se modo de busca é por BDCC
	ELSE IF (@cModo = '3') begin  		
		SELECT	@cIcard   = a.ICARD,
				@cBloqBDCC  = c.Bloqueado
				
			FROM bdcc_cracha c 
			INNER JOIN Controle a
				ON c.Cracha = @cMatric and 
				   c.Cracha = a.ICARD  

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
			SET @Result = 0	
		end
		ELSE begin
			SET	@cMatBusca = @cIcard;
		end
	end


	-- *******************************************************
	-- verifica se encontrou o usuario, entao coleta informacoes do usuario
	IF (@Result = 1) begin			
		
		-- COLETA faixa horaria do usuario de acordo com o tipo de terminal 
				
		IF (@cTipTerm = '3') begin		  -- TERMINAL TIPO PONTO
			-- colocar 'X' no final de cReg1,cReg2,cReg3 e cReg4 pois o SQL trunca   valores
			-- com campos que contem branco (se o campo for o ultimo a ser concatenado)
			SELECT @cIcard    = a.ICARD,
					   @cReg1 = b.FX_DOM_P + b.FX_SEG_P + b.FX_TER_P + 'X', 
					   @cReg2 = b.FX_QUA_P + b.FX_QUI_P + b.FX_SEX_P + 'X', 
					   @cReg3 = b.FX_SAB_P + b.FX_REF + 'X',
					   --@cReg4 = a.FX_1 + a.FX_2 + a.FX_3 + a.FX_4 + a.FX_5 + a.FX_6 + 'X'
					   @cFx1 = a.FX_1, @cFx2 = a.FX_2, @cFx3 = a.FX_3, @cFx4 = a.FX_4, @cFx5 = a.FX_5, @cFx6 = a.FX_6
					   
			FROM  Controle a
				INNER JOIN  FxHoraria b  
					ON a.ICard = @cMatBusca and b.ICard = a.ICard
		end  			
		
		ELSE begin						-- TERMINAL QUE NAO É PONTO (ACESSO)
			SELECT @cIcard    = a.ICARD,
				   @cReg1 = b.FX_DOM_A + b.FX_SEG_A + b.FX_TER_A + 'X', 
				   @cReg2 = b.FX_QUA_A + b.FX_QUI_A + b.FX_SEX_A + 'X', 
				   @cReg3 = b.FX_SAB_A + b.FX_REF + 'X',
				   --@cReg4 = a.FX_1 + a.FX_2 + a.FX_3 + a.FX_4 + a.FX_5 + a.FX_6 + 'X' 
				   @cFx1 = a.FX_1, @cFx2 = a.FX_2, @cFx3 = a.FX_3, @cFx4 = a.FX_4, @cFx5 = a.FX_5, @cFx6 = a.FX_6
			FROM  Controle a
				INNER JOIN  FxHoraria b  
					ON a.ICard = @cMatBusca and b.ICard = a.ICard
		end

		IF (@@ROWCOUNT = 0) begin
			set @cIcard = '000000000000'	-- 12 zeros
			SET @RetFun = -2
		end

		-- *******************************************************
		-- COLETA outros dados do usuario
		ELSE begin
			SELECT	@cIcard   = a.ICARD,
					@cGrupo   = a.GRUPO,
					@cCodig   = a.CODIG,
					@cTpFis   = a.TPFIS, 
					@cSitua   = a.SITUA,
					@cSubNv   = a.SUBNV,
					@cPlanta  = a.PLANTA,
					@cDataHora = a.DATAHORA,
					@cUltrs    = a.ULTRS,
					@cDatIni   = a.DATINI,
					@cDatFim   = a.DATFIM,
					@cTitular  = a.TITULAR,
					@cFx_Flg   = a.FX_FLG,
					@cFx_Dta   = a.FX_DTA,
					@cFx_Alm   = a.TEMPO_ALM,
					@cMensagem = a.MENSAGEM,
					@cDta_mens = a.DTA_MENS, 
					@cQtd_mens = a.QTD_MENS,
					@cCred_Fx1 = a.CRED_FX1,
					@cCred_Fx2 = a.CRED_FX2,
					@cCred_Fx3 = a.CRED_FX3,
					@cCred_Fx4 = a.CRED_FX4,
					@cCred_Fx5 = a.CRED_FX5,
					@cCred_Fx6 = a.CRED_FX6,
					@cUltPasR  = a.ULTPAS_REF,
					@cGrupo1   = a.GRUPO1,
					@cDatIniG1 = a.DATINIG1,
					@cDatFimG1 = a.DATFIMG1,
					@cGrupo2   = a.GRUPO2,
					@cDatIniG2 = a.DATINIG2,
					@cDatFimG2 = a.DATFIMG2,
					@cGrupo3   = a.GRUPO3,
					@cDatIniG3 = a.DATINIG3,
					@cDatFimG3 = a.DATFIMG3,
					@cGpoSab   = a.GRUPO_SAB,
					@cGpoDom   = a.GRUPO_DOM,
					@cGpoFer   = a.GRUPO_FER,
					@cAnti_D   = a.ANTI_DUPLA,
					@cBloq     = a.BLOQ_FALTA,
					@cVHora    = a.VER_HORA,
					@cVLocal   = a.VER_LOCAL,
					@cVValid   = a.VER_VALID,
					@cVAfast   = a.VER_AFAST,
					@cVCred    = a.VER_CRED,
					@cVisEsp   = a.VIS_ESP,
					@cVDigit   = a.VER_DIGIT,

					@cTpoIntj = a.TEMPO_RET,				
					@cTolIntj = a.TOLER_RET,
					@cInterj  = a.VER_RET,

					@cTpoJorn  = a.TEMPO_JORNADA, 
					@cSaidaMax = a.VER_SAIDAMAX,
					@cVnDias   = a.VER_NDIAS,
					@cPne      = a.PNE,
					@cBloqRev  = a.BLOQREV,
					@cvViaRep  = a.VER_VIAREP

				FROM Controle a
					WHERE  a.icard = @cMatBusca

			IF (@@ROWCOUNT = 0) begin
				set @cIcard = '000000000000'	-- 12 zeros
				SET @RetFun = -2
			end

			-- *******************************************************
			-- locka usuario se necessario
			ELSE begin
				IF (@cSitua = '4') or (@cFazLock = '0') begin 	-- se Provisorio, não 'bloqueia'. Sera 'bloqueado' o Titular
					set @ret = 0
				end
				ELSE begin
					SET @stmt1 = 'execute @p1 = ' + @cOwner + '.request_lock @cMat, @cUsu'
					SET @ParmDefinition = N'@cMat nvarchar(30), @cUsu CHAR(15), @p1 int OUTPUT ';		
					EXEC sp_executesql @stmt1, 
									@ParmDefinition, 
									@cMat = @cMatric, 
									@cUsu = @cEndIp,
									@p1 = @ret OUTPUT		
				end		
	
				-- *******************************************************
				-- verifica se dados são nulos para preencher com valores default
				IF (@ret = 0) begin
					SET @cFxDiaEsp = SPACE(28);
					SET @cFxCred   = SPACE(4);
					-- Armazena dados da matricula em Registro
					-- colocar 'X' no final de cReg1, cReg2 e cReg3 pois o SQL trunca            -- valores com campos que contem branco (se o campo for o ultimo a ser       -- concatenado)
					if (@cCodig is Null) 
						SET @cCodig = SPACE(6);
					if (@cTpFis is Null) 
						SET @cTpFis = SPACE(1);
					if (@cSubNv is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cSubNv = '00'+SPACE(3);	-- 3 espacos
						ELSE
							SET @cSubNv = '00'+SPACE(5);	-- 5 espacos
					END
						
					if (@cPlanta is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cPlanta = '000';		--3
						ELSE
							SET @cPlanta = '00000';		-- 5 
					END

					if (@cDataHora is Null) 
						SET @cDataHora = '3112202359';
					if (@cUltrs is Null) 
						SET @cUltrs = '0101902359'+SPACE(10);
					if (@cFx_Flg is Null)  
						SET @cFx_Flg = '0';		-- 1 
					if (@cFx_Dta is Null)  
						SET @cFx_Dta = SPACE(11);
					if (@cFx_Alm is Null)  
						SET @cFx_Alm = SPACE(3);
					if (@cDatIni is Null) 
						SET @cDatIni = SPACE(6);
					if (@cDatFim is Null) 
						SET @cDatFim = SPACE(6);
					if (@cTitular is Null) 
						SET @cTitular = SPACE(12);
					if (@cMensagem is Null)  
						SET @cMensagem = SPACE(32);
					if (@cDta_mens is Null)  
						SET @cDta_mens = SPACE(6);
					if (@cQtd_mens is Null)  
						SET @cQtd_mens = SPACE(2);
					if (@cCred_Fx1 is Null)  
						SET @cCred_Fx1 = '00';		-- 2
					if (@cCred_Fx2 is Null)  
						SET @cCred_Fx2 = '00';		-- 2
					if (@cCred_Fx3 is Null)  
						SET @cCred_Fx3 = '00';		-- 2
					if (@cCred_Fx4 is Null)  
						SET @cCred_Fx4 = '00';		-- 2
					if (@cCred_Fx5 is Null)  
						SET @cCred_Fx5 = '00';		-- 2
					if (@cCred_Fx6 is Null)  
						SET @cCred_Fx6 = '00';		-- 2
					if (@cUltPasR is Null)  
						SET @cUltPasR = SPACE(10);

					if (@cGrupo1 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo1 = '000';	-- 3 
						ELSE
							SET @cGrupo1 = '00000'	-- 5 
					END
					if (@cDatIniG1 is Null) 
						SET @cDatIniG1 = SPACE(10);
					if (@cDatFimG1 is Null) 
						SET @cDatFimG1 = SPACE(10);

					if (@cGrupo2 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo2 = '000';	-- 3 
						ELSE
							SET @cGrupo2 = '00000'	-- 5 
					END
					if (@cDatIniG2 is Null) 
						SET @cDatIniG2 = SPACE(10);
					if (@cDatFimG2 is Null) 
						SET @cDatFimG2 = SPACE(10);
					
					if (@cGrupo3 is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGrupo3 = '000';	-- 3 
						ELSE
							SET @cGrupo3 = '00000'	-- 5 
					END
					if (@cDatIniG3 is Null) 
						SET @cDatIniG3 = SPACE(10);
					if (@cDatFimG3 is Null) 
						SET @cDatFimG3 = SPACE(10);

					if (@cGpoSab is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoSab = '000';	-- 3 
						ELSE
							SET @cGpoSab = '00000'	-- 5 
					END

					if (@cGpoDom is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoDom = '000';	-- 3 
						ELSE
							SET @cGpoDom = '00000'	-- 5 
					END

					if (@cGpoFer is Null) 
					BEGIN
						IF (@nTamG = 3)  
							SET @cGpoFer = '000';	-- 3 
						ELSE
							SET @cGpoFer = '00000'	-- 5 
					END

					if (@cVisEsp is Null) 
						SET @cVisEsp = '0';		-- 1
					if (@cVDigit is Null) 
						SET @cVDigit = '2';		-- 1
					if (@cTpoIntj is Null) 
						SET @cTpoIntj = '000';		-- 3
					if (@cTolIntj is Null)
						SET @cTolIntj = '000';		-- 3
					if (@cInterj is Null)
						SET @cInterj = '0';		-- 1 
					if (@cTpoJorn is Null)
						SET @cTpoJorn = '000';		-- 3
					if (@cSaidaMax is Null)
						SET @cSaidaMax = '0';		-- 1 
					if (@cTipoDoc is Null)
						SET @cTipoDoc = '2';		-- 1 

					if (@cVnDias is Null) 
						SET @cVnDias = '00';		-- 2

					if (@cPne is Null)
						SET @cPne = '0';		-- 1 
					if (@cBloqRev is Null)
						SET @cBloqRev = '0';		-- 1 
					if (@cvViaRep is Null)
						SET @cvViaRep = '0';		-- 1 

					if (@cFx1 is Null)
						SET @cFx1 = '24002400';		-- 8 
					if (@cFx2 is Null)
						SET @cFx2 = '24002400';		-- 8 
					if (@cFx3 is Null)
						SET @cFx3 = '24002400';		-- 8 
					if (@cFx4 is Null)
						SET @cFx4 = '24002400';		-- 8 
					if (@cFx5 is Null)
						SET @cFx5 = '24002400';		-- 8 
					if (@cFx6 is Null)
						SET @cFx6 = '24002400';		-- 8 


					IF (@nTamG = 3) 
						SELECT @cAdBuf = SPACE(2);		-- 2 espços
					ELSE
						SELECT @cAdBuf = null


					SET @cReg4 = @cFx1 + @cFx2 + @cFx3 + @cFx4 + @cFx5 + @cFx6 + 'X'
					
					SET @cReg5 = @cIcard + @cGrupo + 
								 @cCodig + @cTpFis + @cSitua + @cSubNv + 
								 @cPlanta + 
								 'X'
					
					/*
					SET @cReg5 = @cIcard + @cGrupo + COALESCE(@cAdBuf, '') + 
								 @cCodig + @cTpFis + @cSitua + @cSubNv + COALESCE(@cAdBuf, '') + 
								 @cPlanta + COALESCE(@cAdBuf, '') + 'X'
					*/
					

					SET @cReg6 = substring(@cDataHora,1,10) + @cUltrs + @cFx_Flg + @cFx_Dta + @cFx_Alm + 
								 @cFxDiaEsp + @cDatIni + @cDatFim + @cMensagem + @cDta_mens + @cQtd_mens  + 
								 @cCred_Fx1 + @cFxCred +
								 @cCred_Fx2 + @cFxCred +
								 @cCred_Fx3 + @cFxCred +
								 @cCred_Fx4 + @cFxCred +
								 @cCred_Fx5 + @cFxCred +
								 @cCred_Fx6 + @cFxCred +
								 @cUltPasR + @cTitular  + 'X'
								 
					SET @cReg7 = @cGrupo1 + @cDatIniG1 + @cDatFimG1 +
								 @cGrupo2 + @cDatIniG2 + @cDatFimG2 +
								 @cGrupo3 + @cDatIniG3 + @cDatFimG3 +
								 @cGpoSab + 
								 @cGpoDom + 
								 @cGpoFer + 
								 @cAnti_D + @cBloq + @cVHora + @cVLocal +
								 @cVValid + @cVAfast + @cVCred + @cVisEsp + 'X'


					/*
					SET @cReg7 = @cGrupo1 + COALESCE(@cAdBuf, '') + @cDatIniG1 + @cDatFimG1 +
								 @cGrupo2 + COALESCE(@cAdBuf, '') + @cDatIniG2 + @cDatFimG2 +
								 @cGrupo3 + COALESCE(@cAdBuf, '') + @cDatIniG3 + @cDatFimG3 +
								 @cGpoSab + COALESCE(@cAdBuf, '') + 
								 @cGpoDom + COALESCE(@cAdBuf, '') + 
								 @cGpoFer + COALESCE(@cAdBuf, '') + 
								 @cAnti_D + @cBloq + @cVHora + @cVLocal +
								 @cVValid + @cVAfast + @cVCred + @cVisEsp + 'X'
					*/					


					IF (@cDesbloqRev = '1')  
						SET @cBloqRev = '0'
					

					--SET @cReg8 = @cIcard + '0' + '0' + @cVDigit + 
					SET @cReg8 = @cIcard + @cvViaRep + '0' + @cVDigit + 
								 @cTpoIntj + @cTolIntj + @cInterj + 
								 @cTpoJorn + @cSaidaMax + 
								 @cTipoDoc + '00' + @cVnDias + 
								 --@cPne + @cBloqRev + 'X'
								 @cPne + @cBloqRev
				end
				-- matricula ja lockada
				ELSE
					SET @RetFun = -3
			end
		end
	END

	SET DATEFORMAT dmy
	SELECT @cIniHalmAux = CONVERT(char(8), a.Ini_Halm, 3)+ CONVERT(char(8), a.Ini_Halm, 8),
		   @cFimHalmAux = CONVERT(char(8), a.Fim_Halm, 3)+ CONVERT(char(8), a.Fim_Halm, 8),
		   @cIniIntjAux = CONVERT(char(8), a.Ini_Intj, 3)+ CONVERT(char(8), a.Ini_Intj, 8),
		   @cFimIntjAux = CONVERT(char(8), a.Fim_Intj, 3)+ CONVERT(char(8), a.Fim_Intj, 8),
		   @cFimAntDAux = CONVERT(char(8), a.Fim_AntiD, 3)+ CONVERT(char(8), a.Fim_AntiD, 8) ,
		   @cDiasSuc = a.Dias_Suc   
		   
	FROM DATAHORA a 
	WHERE a.ICARD = @cMatBusca
	
	IF (@@ROWCOUNT = 0) begin
  		SET @cIniHalm = '010106000000'	-- 01/01/06
		SET @cFimHalm = '010106000000'	-- 01/01/06
		SET @cIniIntj = '010106000000'	-- 01/01/06
		SET @cFimIntj = '010106000000'	-- 01/01/06
		SET @cFimAntD = '010106000000'	-- 01/01/06
		SET @cDiasSuc = '00';
	end
	ELSE begin
		SET @cIniHalm = substring (@cIniHalmAux,1,2)+substring (@cIniHalmAux, 4,2)+substring (@cIniHalmAux, 7,2)+
						substring (@cIniHalmAux,9,2)+substring (@cIniHalmAux,12,2)+substring (@cIniHalmAux,15,2)
		SET @cFimHalm = substring (@cFimHalmAux,1,2)+substring (@cFimHalmAux, 4,2)+substring (@cFimHalmAux, 7,2)+
						substring (@cFimHalmAux,9,2)+substring (@cFimHalmAux,12,2)+substring (@cFimHalmAux,15,2)
		SET @cIniIntj = substring (@cIniIntjAux,1,2)+substring (@cIniIntjAux, 4,2)+substring (@cIniIntjAux, 7,2)+
						substring (@cIniIntjAux,9,2)+substring (@cIniIntjAux,12,2)+substring (@cIniIntjAux,15,2)
		SET @cFimIntj = substring (@cFimIntjAux,1,2)+substring (@cFimIntjAux, 4,2)+substring (@cFimIntjAux, 7,2)+
						substring (@cFimIntjAux,9,2)+substring (@cFimIntjAux,12,2)+substring (@cFimIntjAux,15,2)
		SET @cFimAntD = substring (@cFimAntDAux,1,2)+substring (@cFimAntDAux, 4,2)+substring (@cFimAntDAux, 7,2)+
						substring (@cFimAntDAux,9,2)+substring (@cFimAntDAux,12,2)+substring (@cFimAntDAux,15,2)
	END
	
	SET @cReg9 = @cIcard + @cIniHalm + @cFimHalm + @cIniIntj + @cFimIntj + @cFimAntD + @cDiasSuc + 'X';

	--SET @cReg10 = @cBloqBDCC + 'X';
	SET @cReg10 = @cBloqBDCC;

	-- *******************************************************
	-- atualiza tab.CONTROLE se o usuario foi liberado pelo equipamento para revista
	IF (@RetFun = 0 AND 
		@Result = 1 AND 
		@cDesbloqRev = '1') begin
			IF (@cFazLock = '0') begin				-- marcacao offline
				SET @pos = CHARINDEX(' ', @cUltrs);  	-- VERIFICA SE data armazenada em BD tem valor em branco

				IF (@pos <= 10) and (@pos > 0) 
					SET @dDataBD = @dDataOcor;		-- assume temporariamente a mesma data de ocorrencia para que haja tualização
				ELSE begin
					set DATEFORMAT dmy
					SET @dDataBD = CAST((substring(@cUltrs,1,2)+'-'+substring(@cUltrs,3,2)+'-'+substring(@cUltrs,5,2)+' '+
							 			 substring(@cUltrs,7,2)+':'+substring(@cUltrs,9,2)+':'+'00') AS datetime);					
				end
				
				IF (@dDataOcor >= @dDataBD) 			-- atualiza BD porque a marcacao offline é mais recente que está em BD
					UPDATE CONTROLE SET BLOQREV = '0' WHERE ICARD = @cMatBusca;
			end
			ELSE
				UPDATE CONTROLE SET BLOQREV = '0' 
					WHERE ICARD = @cMatBusca
	end		
				
	
	-- *******************************************************
	-- verifica grupo do Estacionamento / AREA controlada por vaga
	SET @nGrEstFixa = 0;
	SET @nGrestEquip = 0;
	SET @cEmFixa = '0';
	SET @cRegra = '0';
	
	SELECT @nGrestEquip = convert(int, GREST)  			-- VERIFICA SE O EQUIPAMENTO PERTENCE A ALGUM ESTACIONAMENTO / AREA CONTROLADA
		FROM ESTAC001 
		WHERE END_IP = @cEndIp;
	
	IF (@@ROWCOUNT = 0) begin
		SET @nGrEstFixa = 0;
		SET @nGrestEquip = 0;
	end			
	ELSE begin
		SELECT @nGrEstFixa = convert(int, GREST),
			   @cEmFixa = EMFIXA   					-- VERIFICA SE A MATRICULA POSSUI VAGA FIXA NESTE ESTACIONAMENTO
			FROM ESTAC003 
			WHERE ICARD = @cMatBusca AND convert(int, GREST) = convert(int, @nGrestEquip);
			
		IF (@@ROWCOUNT = 0)	begin 		
			SET @nGrEstFixa = 0;
			SET @cEmFixa = '0';
		END
	END;

	-- verifica numero da regra, se equipamento pertencer a área de vagas
	IF (@nGrestEquip != 0) begin
		SELECT @cRegra = REGRA 
			FROM ESTAC002 
			WHERE convert(int, GREST) = convert(int, @nGrestEquip);
	
		IF (@@ROWCOUNT = 0) begin
			SET @cRegra = '0';
		end
	END 

	SET @AuxGr2 = convert(char, @nGrEstFixa);
	SET @AuxGr = REPLICATE('0',6-LEN(@AuxGr2) ) + @AuxGr2;
	SET @cReg8 = @cReg8 + @AuxGr;								-- grupo de estacionamento do qual o usuario tem vaga fixa
	SET @cReg8 = @cReg8 + @cEmFixa + 'X';						-- indicador se estacionou em vaga fixa

	SET @AuxGr2 = convert(char, @nGrestEquip);
	SET @AuxGr = REPLICATE('0',6-LEN(@AuxGr2) ) + @AuxGr2;			-- grupo de estacionamento ao qual o equipamento faz parte
	SET @cReg10 = @cReg10 + @AuxGr 				-- posic 1 a 6(numero da area de controle)
	SET @cReg10 = @cReg10 + @cRegra + 'X'		-- posic 7 (numero da regra)		


	-- *******************************************************
	-- verifica Area de ESCOLTA
	SET @cTemEsc = '0'

	IF (@cEhEscolta = '0')		-- não é a escolta
	BEGIN
		SET @cProcurado = @cMatBusca
		SET @nContArea = 0
		SET @cFinalSentido = '0'
		
		SET @cEscoltado = @cMatBusca
		SET @cEscolta = '000000000000'
		SET @cTemEsc = '0'
		SET @cSentido = '0'
	
		
		DECLARE escolt_cur CURSOR FOR
			SELECT AREA, SENTIDO FROM ESCOLT002 
				WHERE END_IP = @cEndIp
				ORDER by AREA;

		OPEN escolt_cur
		FETCH next from escolt_cur into @nAuxArea, @AuxSentido
		WHILE (@@fetch_status != -1)
		BEGIN
			SET @nContArea = @nContArea + 1
		
			-- localiza a AREA e MATRICULA NA TABELA DE PESSOAS A SEREM ESCOLTADAS
			IF EXISTS (
				SELECT ICARD_ESCOLTADO, AREA 
					FROM ESCOLT001 
					WHERE ICARD_ESCOLTADO = @cProcurado AND
						  AREA = @nAuxArea)

			BEGIN
				SET @cFinalSentido = 
				CASE 
					WHEN @cFinalSentido = '0' 
						THEN ( @AuxSentido)
					WHEN @cFinalSentido = '1' AND (@AuxSentido = '2' OR  @AuxSentido = '3') 
						THEN '3'
					WHEN @cFinalSentido = '2' AND (@AuxSentido = '1' OR  @AuxSentido = '3')
						THEN '3'
						ELSE @cFinalSentido
				END
					
				SET @cTemEsc = '1'
				SET @cSentido = @cFinalSentido
			END
			
			FETCH next from escolt_cur into @nAuxArea, @AuxSentido
		END
		
		CLOSE escolt_cur
		DEAllocate escolt_cur
	END


	-- É A ESCOLTA
	ELSE BEGIN
	
		SET @nContArea = 0
		SET @cEscoltado = @cVisita
		SET @cEscolta = '000000000000'
		SET @cTemEsc = '0'
		SET @cSentido = '0'
	
		DECLARE escolt_cur CURSOR FOR
			SELECT AREA FROM ESCOLT002 
				WHERE END_IP = @cEndIp
				ORDER by AREA;

	
		OPEN escolt_cur
		FETCH next from escolt_cur into @nAuxArea
		WHILE (@@fetch_status != -1)
		BEGIN
			SET @nContArea = @nContArea + 1
		
			-- VERIFICA SE A MATRICULA É AUTORIZADA A SER  ESCOLTA 

			IF EXISTS (
				SELECT ICARD_ESCOLTADO, AREA 
					FROM ESCOLT001 
					WHERE ICARD_ESCOLTADO = @cVisita AND
					   	  ICARD_GUARDA = @cMatBusca AND 
					      AREA = @nAuxArea)
			BEGIN
				SET @cEscoltado = @cVisita;
				SET @cEscolta = @cMatBusca;
				SET @cTemEsc = '0'	
				--SET @@fetch_status  = -1
				BREAK
			END
			ELSE
				FETCH next from escolt_cur into @nAuxArea
		END
		CLOSE escolt_cur
		DEAllocate escolt_cur
	END

	
	SET @cReg11 = @cEscoltado + @cEscolta + @cTemEsc + @cSentido + 'X';

	


	SET LOCK_TIMEOUT -1		
	
	SELECT @RetFun, 
		@cReg1, 
		@cReg2, 
		@cReg3, 
		@cReg4, 
		@cReg5, 
		@cReg6, 
		@cReg7, 
		@cReg8, 
		@cReg9,
		@cReg10,
		@cReg11,
		@nTamG		
	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqlfim_ExcAutoDigit3', 'p') is null
    exec ('create procedure TELESSVR.sqlfim_ExcAutoDigit3 as select 1')
go

ALTER PROCEDURE TELESSVR.sqlfim_ExcAutoDigit3 @cEndIp CHAR(15), @cStat CHAR(1), @cBioTipo CHAR(1) AS

declare @nCont smallint
declare @nErr smallint
declare @Aux char(12)
declare @cIcard char(12)
declare @STATUS char(1)

	SET LOCK_TIMEOUT 5000
	SET @nCont = 0
	SET @nErr = 0
	
	IF (@cBioTipo =  '6' or @cBioTipo = '7') BEGIN		-- SAGEM
		DECLARE lexcldig_cur CURSOR FOR
			SELECT ICARD, STATUS FROM DIG101 
				WHERE END_IP = @cEndIp AND 
					  STATUS = '2'
				ORDER by ICARD;

		OPEN lexcldig_cur
		FETCH next from lexcldig_cur into @cIcard, @STATUS
		WHILE (@@fetch_status != -1)
		begin
			update DIG101 set STATUS = @cStat where current of lexcldig_cur 
			SET @nCont = @nCont+1

			fetch next from lexcldig_cur into @cIcard, @STATUS
		end
		close lexcldig_cur
		deallocate lexcldig_cur
	END

	ELSE	
	BEGIN
		IF (@cBioTipo = '8') BEGIN		-- TSI1
			DECLARE lexcldig_cur CURSOR FOR
				SELECT ICARD, STATUS FROM DIG103 
					WHERE END_IP = @cEndIp AND 
						  STATUS = '2'
					ORDER by ICARD;

			OPEN lexcldig_cur
			FETCH next from lexcldig_cur into @cIcard, @STATUS
			WHILE (@@fetch_status != -1)
			begin
				update DIG103 set STATUS = @cStat where current of lexcldig_cur 
				SET @nCont = @nCont+1

				fetch next from lexcldig_cur into @cIcard, @STATUS
			end
			close lexcldig_cur
			deallocate lexcldig_cur
		END
		ELSE
			IF (@cBioTipo != '0') BEGIN		-- VIRDI / OUTROS
				DECLARE lexcldig_cur CURSOR FOR
					SELECT ICARD, STATUS FROM DIG104 
						WHERE END_IP = @cEndIp AND 
							  STATUS = '2' AND
							  BIO_TIPO = @cBioTipo 
						ORDER by ICARD;

				OPEN lexcldig_cur
				FETCH next from lexcldig_cur into @cIcard, @STATUS
				WHILE (@@fetch_status != -1)
				begin
					update DIG104 set STATUS = @cStat where current of lexcldig_cur 
					SET @nCont = @nCont+1

					fetch next from lexcldig_cur into @cIcard, @STATUS
				end
				close lexcldig_cur
				deallocate lexcldig_cur
			END
	END
		

	UPDATE DIG102 SET STATUS = @cStat WHERE END_IP = @cEndIp;
	SET LOCK_TIMEOUT -1


	return @nCont	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqlfim_InsAutoBinBios', 'p') is null
    exec ('create procedure TELESSVR.sqlfim_InsAutoBinBios as select 1')
go

ALTER PROCEDURE TELESSVR.sqlfim_InsAutoBinBios @cEndIp CHAR(15), @cStat CHAR(1), @cBioTipo CHAR(1) AS

declare @nCont smallint
declare @nErr smallint
declare @Aux char(12)
declare @cIcard char(12)
declare @STATUS char(1)

	SET @nCont = 0
	SET @nErr = 0
	SET LOCK_TIMEOUT 5000
	DECLARE lfimbiooutros_cur CURSOR FOR
				SELECT ICARD, STATUS FROM DIG004 
					WHERE END_IP = @cEndIp AND 
						  STATUS = '2' AND 
						  BIO_TIPO = @cBioTipo
					order by ICARD;

	open lfimbiooutros_cur
	fetch next from lfimbiooutros_cur into @cIcard, @STATUS
	while (@@fetch_status != -1)
	begin
		update DIG004 set STATUS = @cStat where current of lfimbiooutros_cur 
		SET @nCont = @nCont+1

		fetch next from lfimbiooutros_cur into @cIcard, @STATUS
	end
	close lfimbiooutros_cur
	deallocate lfimbiooutros_cur
	
	UPDATE DIG002 SET STATUS = @cStat WHERE END_IP = @cEndIp;
	SET LOCK_TIMEOUT -1

	return @nCont	
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

if object_id('TELESSVR.sqlGravaBD_BinaryBios', 'p') is null
    exec ('create procedure TELESSVR.sqlGravaBD_BinaryBios as select 1')
go

ALTER PROCEDURE TELESSVR.sqlGravaBD_BinaryBios @cMatric VARCHAR(12), @cDadosChar VARCHAR(MAX), @tam INT,  @nTipoPadAlt INT, @cBioTipo CHAR(1)
AS
DECLARE @cAuxMat VARCHAR(12)
declare @cDadosBin VARBINARY(MAX)
	

	SET @cDadosBin = CONVERT(varbinary(max), @cDadosChar, @tam);

	SELECT @cAuxMat = ICARD  
		FROM CONTDIG_OUTROS 
		WHERE ICARD = @cMatric AND
			  BIO_TIPO = @cBioTipo

	IF @@ROWCOUNT = 0 
	begin
		IF (@nTipoPadAlt = 0)
			INSERT INTO CONTDIG_OUTROS (ICARD, DIGITALBIN_PAD, BIO_TIPO, STATUS, STATUS_REP)  
				VALUES (@cMatric, @cDadosBin, @cBioTipo, '1', '1');
		ELSE
			INSERT INTO CONTDIG_OUTROS (ICARD, DIGITALBIN_ALT, BIO_TIPO, STATUS, STATUS_REP)  
				VALUES (@cMatric, @cDadosBin, @cBioTipo, '1', '1');
	end
	ELSE begin
		IF (@nTipoPadAlt = 0)
			UPDATE CONTDIG_OUTROS set 
				DIGITALBIN_PAD = @cDadosBin,
				STATUS = '1',
				STATUS_REP = '1'
			where icard = @cMatric

		ELSE
			UPDATE CONTDIG_OUTROS set 
				DIGITALBIN_ALT = @cDadosBin,
				STATUS = '1',
				STATUS_REP = '1'
			where icard = @cMatric
	end		
	
	SET LOCK_TIMEOUT -1
	


SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


if object_id('TELESSVR.sqller_autoLoadDigit3', 'p') is null
    exec ('create procedure TELESSVR.sqller_autoLoadDigit3 as select 1')
go

ALTER PROCEDURE TELESSVR.sqller_autoLoadDigit3  @cEndIp VARCHAR(15)AS

declare @nTotal smallint
declare @cStatus char(1)
declare @cBio_Tipo char(1)
declare @ICARD varchar(12)
declare @STATUS char(1)

DECLARE @cListaId VARCHAR(MAX)

	SET @nTotal = 0
	SET @cListaId = ''

	SET LOCK_TIMEOUT 5000

	-- procura pelo equipamento
	IF EXISTS (SELECT * FROM DIG002  WHERE END_IP = @cEndIp and STATUS = '1')
	BEGIN
	    SELECT @cStatus = STATUS, @cBio_Tipo = BIO_TIPO
			FROM DIG002
			WHERE END_IP = @cEndIp

		IF (@cStatus = '1') BEGIN
			IF (@cBio_Tipo = '6' or @cBio_Tipo = '7') BEGIN		-- SAGEM
				DECLARE ldigit_cur CURSOR FOR
					SELECT ICARD, STATUS FROM DIG001 
						WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
							order by ICARD;

				open ldigit_cur
				fetch next from ldigit_cur into @ICARD, @STATUS
				while (@@fetch_status != -1) and (@nTotal < 24) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE DIG001 set STATUS = '2' where current of ldigit_cur
					
					set @nTotal = @nTotal + 1
					
					fetch next from ldigit_cur into @ICARD, @STATUS
				end
				close ldigit_cur
				deallocate ldigit_cur
			END
			
			ELSE 
				IF (@cBio_Tipo = '8') BEGIN		-- TSI1
					DECLARE ldigit_cur CURSOR FOR
						SELECT ICARD, STATUS FROM DIG003 
							WHERE (END_IP = @cEndIp) and (STATUS != '0') and (STATUS != '2')
						ORDER by ICARD;

					open ldigit_cur
					fetch next from ldigit_cur into @ICARD, @STATUS
					while (@@fetch_status != -1) and (@nTotal < 24) 
					begin
						SET @cListaId = @cListaId + @ICARD
						UPDATE DIG003 set STATUS = '2' where current of ldigit_cur

						set @nTotal = @nTotal + 1
						
						fetch next from ldigit_cur into @ICARD, @STATUS
					end
					close ldigit_cur
					deallocate ldigit_cur
				END
						
				-- VIRDI E OUTROS
				ELSE 
					IF (@cBio_Tipo != '0') BEGIN		
						DECLARE ldigit_cur CURSOR FOR
							SELECT ICARD, STATUS FROM DIG004 
								WHERE (END_IP = @cEndIp) and 
									  (STATUS != '0') and (STATUS != '2') AND 
									  (BIO_TIPO = @cBio_Tipo)
							ORDER by ICARD;

						open ldigit_cur
						fetch next from ldigit_cur into @ICARD, @STATUS
						while (@@fetch_status != -1) and (@nTotal < 24) 
						begin
							SET @cListaId = @cListaId + @ICARD
							UPDATE DIG004 set STATUS = '2' where current of ldigit_cur
							set @nTotal = @nTotal + 1

							fetch next from ldigit_cur into @ICARD, @STATUS
						end
						close ldigit_cur
						deallocate ldigit_cur
					END

			IF (@nTotal = 0) 
				UPDATE DIG002 SET STATUS = '0' WHERE END_IP = @cEndIp;
			ELSE 
				UPDATE DIG002 SET 
					STATUS = '2',
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;
		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaId as cListaId
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO
	
if object_id('TELESSVR.sqller_autoExclDigit3', 'p') is null
    exec ('create procedure TELESSVR.sqller_autoExclDigit3 as select 1')
go

ALTER PROCEDURE TELESSVR.sqller_autoExclDigit3 @cEndIp VARCHAR(15) AS

declare @nTotal smallint
declare @cStatus char(1)
declare @cBio_Tipo char(1)
declare @ICARD varchar(12)
declare @STATUS char(1)
DECLARE @cListaId VARCHAR(MAX)

	SET @nTotal = 0
	SET @cListaId = ''

	SET LOCK_TIMEOUT 2000

	-- procura pelo equipamento
	IF EXISTS (SELECT * FROM DIG102  WHERE END_IP = @cEndIp AND STATUS = '1')
	BEGIN
	    SELECT @cStatus = STATUS, @cBio_Tipo = BIO_TIPO
			FROM DIG102 NOLOCK
			WHERE END_IP = @cEndIp

		IF (@cStatus = '1') BEGIN
			-- SAGEM
			IF (@cBio_Tipo = '6' or @cBio_Tipo = '7') BEGIN		
				DECLARE ldigit_cur CURSOR FOR
					SELECT ICARD, STATUS FROM DIG101 
						WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
							order by ICARD;

				open ldigit_cur
				fetch next from ldigit_cur into @ICARD, @STATUS
				while (@@fetch_status != -1) and (@nTotal < 32) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE DIG101 set STATUS = '2' where current of ldigit_cur
					set @nTotal = @nTotal + 1

					fetch next from ldigit_cur into @ICARD, @STATUS
				end
				close ldigit_cur
				deallocate ldigit_cur
			END
			
			-- TSI1	
			ELSE IF (@cBio_Tipo = '8') BEGIN
				DECLARE ldigit_cur CURSOR FOR
					SELECT ICARD, STATUS FROM DIG103 
						WHERE END_IP = @cEndIp AND STATUS != '0' AND STATUS != '2' 
							order by ICARD;

				open ldigit_cur
				fetch next from ldigit_cur into @ICARD, @STATUS
				while (@@fetch_status != -1) and (@nTotal < 32) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE DIG103 set STATUS = '2' where current of ldigit_cur
					set @nTotal = @nTotal + 1

					fetch next from ldigit_cur into @ICARD, @STATUS
				end
				close ldigit_cur
				deallocate ldigit_cur
			END
			
			-- VIRDI / outros
			ELSE 
				IF (@cBio_Tipo != '0') BEGIN		
				DECLARE ldigit_cur CURSOR FOR
					SELECT ICARD, STATUS FROM DIG104 
						WHERE END_IP = @cEndIp AND 
							  STATUS != '0' AND STATUS != '2' AND 
							  BIO_TIPO = @cBio_Tipo 
							order by ICARD;

				open ldigit_cur
				fetch next from ldigit_cur into @ICARD, @STATUS
				while (@@fetch_status != -1) and (@nTotal < 32) 
				begin
					SET @cListaId = @cListaId + @ICARD
					UPDATE DIG104 set STATUS = '2' where current of ldigit_cur
					set @nTotal = @nTotal + 1

					fetch next from ldigit_cur into @ICARD, @STATUS
				end
				close ldigit_cur
				deallocate ldigit_cur
			END
			
			IF (@nTotal = 0) 
				UPDATE DIG102 SET STATUS = '0' WHERE END_IP = @cEndIp;
			ELSE 
				UPDATE DIG102 SET 
					STATUS = '2',
					DATA_LOAD = getdate()
				WHERE END_IP = @cEndIp;

		END
	END
	SET LOCK_TIMEOUT -1
	
	SELECT @nTotal as nTotal,
		   @cListaId as cListaId
	GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO
	
if object_id('TELESSVR.sqlproc_digitBinaryBios', 'p') is null
    exec ('create procedure TELESSVR.sqlproc_digitBinaryBios as select 1')
go

ALTER PROCEDURE TELESSVR.sqlproc_digitBinaryBios @cMat VARCHAR(12), @cEndIp VARCHAR(15), @cBioTipo CHAR(1) AS
DECLARE @Ret INT, @nTotalPad INT , @nTotalAlt INT 
DECLARE @nAuxTotalPad INT , @nAuxTotalAlt INT 
DECLARE @cPad VARBINARY(MAX), @cAlt VARBINARY(MAX)

	set @nTotalPad = 0
	set @nTotalAlt = 0
	set @cPad = 0
	set @cAlt = 0
	set @Ret = 0
	

	SELECT @cPad = DIGITALBIN_PAD, @cAlt = DIGITALBIN_ALT 
		FROM CONTDIG_OUTROS 
		WHERE ICARD = @cMat AND 
			  BIO_TIPO = @cBioTipo;
	
	IF (@@ROWCOUNT = 1) begin	
		if (@cPad != 0) 
			set @nTotalPad = len (@cPad)
		
		if (@cAlt != 0) 
			set @nTotalAlt = len (@cAlt)
		
		if ((@nTotalPad = 0) and (@nTotalAlt= 0))
			set @Ret = 0;
		else
			set @Ret = 1;
	end
	
	
	IF (@Ret = 0) BEGIN
		-- insere em tabela DIGLOAD001
		INSERT INTO DIGLOAD001 (END_IP, ICARD, BIO_TIPO) 
			VALUES (@cEndIp, @cMat, @cBioTipo);
	END

	SELECT @Ret, @cPad, @cAlt, @nTotalPad, @nTotalAlt

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


if object_id('TELESSVR.G3G5_PREP3_SAGEM', 'p') is null
    exec ('create procedure TELESSVR.G3G5_PREP3_SAGEM as select 1')
go

ALTER PROCEDURE TELESSVR.G3G5_PREP3_SAGEM AS

DECLARE @c_status CHAR(1)
DECLARE @c_icard CHAR(12)

DECLARE @xc_status CHAR(1)
DECLARE @xc_icard CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @xc_tipobio CHAR(1)
DECLARE @ret CHAR(1)

DECLARE @z_endip CHAR(15)
DECLARE @nCont SMALLINT
DECLARE @nAchouGrupo SMALLINT

SET DATEFORMAT YMD


	set @ret = 0

	-- cursor para matriculas cujas digitais foram alteradas
	DECLARE cur_stdigital CURSOR FOR (select ICARD, STATUS from CONTDIG_SAGEM WHERE STATUS = '1' or STATUS = '3' or STATUS = '8')

	OPEN cur_stdigital
	FETCH NEXT FROM cur_stdigital INTO @c_icard, @c_status
	while @@fetch_status != -1
	begin
	
		SET @nAchouGrupo = 0		-- presupoe q nao tem icard x grupo correspondente em tab 
	
		-- *************************************************************************
		-- prepara os ids excluidos (controle.situa = invalido) ou grupos da controle alterados, retirando as digitais de todos os equipamentos 
		IF (@c_status = '3') or (@c_status = '8') BEGIN			-- alterados grupos (3) ou (situa invalidos ou  ver_digit nao confere)  (8)

			-- MONTA temporaria matricula x equipamentos cadastrados
			INSERT INTO TMP_DIG101 (ICARD, END_IP, STATUS, BIO_TIPO) 		
				SELECT distinct @c_icard, DAT07.END_IP, '0', DAT07.BIO_TIPO 
				FROM DAT07 
				WHERE BIO_TIPO = '6' or BIO_TIPO = '7';

	
			-- *****************************************************************
			-- COMO ESTA EXCLUINDO O FUNCIONARIO DA EMPRESA (CONTROLE.SITUA = '1' INVALIDO), TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN
			-- COMO ALTEROU O GRUPO, TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN

			--DELETE FROM DIG001 WHERE ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1')

			-- VAI DELETAR A MATRICULA DE QUALQUER STATUS PORQUE PODE CAIR NA SITUACAO EM QUE HA INCLUSAO DA MATRICULA, MAS NAO VAI PORQUE O EQUIPAMENTO 'ESTA OCUPADO' (nova resposta do microdimarms).
			-- SE HOUVER POSTERIORMENTE EXCLUSAO DESSA MESMA MATRICULA, DEVE=-SE EXCLUIR A INCLUSAO DESSA MATRICULA DA TABELA
			DELETE FROM DIG001 WHERE ICARD = @c_icard
			
		
		END	

		IF (@c_status = '1') or (@c_status = '3') BEGIN		-- incluido/alterado BIOMETRIA (1)   ou   alterados grupos (3) 

			-- ******************************************************************
			-- para todos icards q alteraram digital, distribui nos equipamentos de acordo com o grupo cadastrado em 
			-- CONTROLE, DAT07,DAT08 
			-- MONTA temporaria matricula com codins com permissao acesso
			
			insert into TMP_DIG001 (ICARD, END_IP, STATUS, BIO_TIPO)
			SELECT distinct A.icard,  A.end_ip, A.st, A.bio_tipo
				FROM 
					-- seleciona os equipamentos que fazem parte dos grupos do usuário
					(SELECT distinct @c_icard as 'icard',  dat07.end_ip, '0' as 'st', dat07.bio_tipo
						from dat07, dat08 
						where
							dat07.end_ip <> '000.000.000.000' and
							CONVERT(int,dat08.grupo) in (
								select CONVERT(int,grupo) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1') 		-- equipamentos do grupo , situa diferente de invalido, e verifica digital
								  union
								select CONVERT(int,grupo1) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union	
								select CONVERT(int,grupo2) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo3) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_sab) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_dom) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_fer) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,A.grupo) from MATNGRUPOS A, CONTROLE B where A.ICARD = @c_icard  AND B.ICARD = @c_icard AND (B.SITUA <> '1') and (B.VER_DIGIT <> '1')
								  union
								select CONVERT(int,A.grupo) from MATGRUPO A, CONTROLE B where A.ICARD = @c_icard  AND B.ICARD = @c_icard AND (B.SITUA <> '1') and (B.VER_DIGIT <> '1')
								) and
							CONVERT(int,dat07.laces) = CONVERT(int,dat08.laces) and
							CONVERT(int,dat07.planta) = CONVERT(int,dat08.planta) and
							(dat07.bio_tipo = '6' or dat07.bio_tipo = '7')  
				UNION
					SELECT distinct @c_icard as 'icard',  dat07.end_ip, '0' as 'st', dat07.bio_tipo
						from dat07, MATCODIN 
						where
							matcodin.icard = @c_icard and
							matcodin.end_ip <> '000.000.000.000' and 
							matcodin.end_ip = dat07.end_ip and 
							(dat07.bio_tipo = '6' or dat07.bio_tipo = '7') ) as A

			-- para quem incluiu/alterou digital (status 1) ou mudou de grupo (status 3)
			--IF (@c_status = '3') BEGIN
			IF (@c_status = '1') OR (@c_status = '3') BEGIN
			
				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao temporaria os equipamentos que fazem parte do novo grupo

				DELETE FROM TMP_DIG101
					WHERE EXISTS
						(SELECT TMP_DIG001.icard 
							FROM 
								TMP_DIG001
							WHERE 
								TMP_DIG001.icard = TMP_DIG101.icard and
								TMP_DIG001.END_IP = TMP_DIG101.END_IP and
							  	TMP_DIG001.icard = @c_icard
					);

				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao final os equipamentos do ID em questão, para REFAZER a tabela
				--DELETE from DIG101 where ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1')
				
				-- VAI DELETAR A MATRICULA DE QUALQUER STATUS PORQUE PODE CAIR NA SITUACAO EM QUE HA EXCLUSAO DA MATRICULA, MAS NAO VAI PORQUE O EQUIPAMENTO ESTA OCUPADO.
				-- SE HOUVER POSTERIORMENTE INCLUSAO DESSA MESMA MATRICULA, DEVE=-SE EXCLUIR A EXCLUSAO DESSA MATRICULA DA TABELA
				DELETE from DIG101 where ICARD = @c_icard 
			END

		END


		-- ******************************************************************
		-- PREPARA TABELA TEMPORARIA DE INCLUSAO COM OS ENDEREÇOS IP 
		SET @nCont = (SELECT COUNT(*) FROM TMP_DIG001)

		-- verifica se a matricula esta cadastrada em controle e se pertence a alguma codin. 
		-- Caso negativo, seu status ainda continua setado até que seja cadastrada e pertença a algum local de acesso
		if (@nCont != 0) begin

			-- insere icard-codin em tab. DIG001, se não existir em tab.
			DECLARE cur_tmpdigital CURSOR FOR (select ICARD, END_IP, STATUS, BIO_TIPO from TMP_DIG001)
			OPEN cur_tmpdigital
			FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio

			WHILE @@fetch_status != -1 BEGIN
				UPDATE DIG001 SET STATUS = '1' 
					WHERE  ICARD = @xc_icard AND
						   END_IP = @xc_endip
				if @@rowcount = 0
				begin		
					INSERT INTO DIG001 (ICARD, END_IP, STATUS, BIO_TIPO) 
						values (@xc_icard, @xc_endip, '1', @xc_tipobio);
				end

				FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio
			end
			
			
			SET @nAchouGrupo = 1;
			
			-- coloca o codin na tab. DIG002 (CARGA LISTA) o codin não existir
			insert into DIG002 (END_IP, DATA_LOAD, STATUS, BIO_TIPO)
				select distinct end_ip, getdate(), '0', bio_tipo  
				from
					-- tmp_dig001
					DIG001
				where
					end_ip not in ( select end_ip from DIG002 );
			
			
			CLOSE cur_tmpdigital
			DEALLOCATE cur_tmpdigital
		end

		-- ******************************************************************
		-- PREPARA TABELA TEMPORARIA DE EXCLUSAO COM OS ENDEREÇOS IP DOS EQUIPAMENTOS
		SET @nCont = (SELECT COUNT(*) FROM TMP_DIG101)
		IF (@nCont != 0) BEGIN

			-- insere na tabela final DIG101  os ID COM STATUS de carga (0 / 1= a excluir)
			DECLARE cur_tmpdigital CURSOR FOR (select ICARD, END_IP, STATUS, BIO_TIPO from TMP_DIG101)
			OPEN cur_tmpdigital
			FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio

			WHILE @@fetch_status != -1 BEGIN
				UPDATE DIG101 SET STATUS = '1' 
					WHERE  ICARD = @xc_icard AND
						   END_IP = @xc_endip
				if @@rowcount = 0
				begin		
					INSERT INTO DIG101 (ICARD, END_IP, STATUS, BIO_TIPO) 
						values (@xc_icard, @xc_endip, '1', @xc_tipobio);
				end

				FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio
			end
			
			SET @nAchouGrupo = 1;

			-- coloca o equipamento na tab. DIG102 (CARGA LISTA) o equipamento q não existir
			insert into DIG102 (END_IP, DATA_LOAD, STATUS, BIO_TIPO)
				select distinct END_IP, GETDATE(), '0', BIO_TIPO
				from
					DIG101
				where
					END_IP not in ( select END_IP from DIG102 );
							
			CLOSE cur_tmpdigital
			DEALLOCATE cur_tmpdigital
		END	

		-- atualiza status da matricula, como tratado
		IF (@nAchouGrupo = 1) 	
			update CONTDIG_SAGEM SET STATUS = '0' 
				where ICARD = @c_icard;
			
		DELETE TMP_DIG001
		DELETE TMP_DIG101

		
		FETCH NEXT FROM cur_stdigital INTO @c_icard, @c_status
	end
	CLOSE cur_stdigital
	deallocate cur_stdigital

GO

if object_id('TELESSVR.G3G5_PREP3_TSI1', 'p') is null
    exec ('create procedure TELESSVR.G3G5_PREP3_TSI1 as select 1')
go

ALTER PROCEDURE TELESSVR.G3G5_PREP3_TSI1 AS

DECLARE @c_status CHAR(1)
DECLARE @c_icard CHAR(12)

DECLARE @xc_status CHAR(1)
DECLARE @xc_icard CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @xc_tipobio CHAR(1)
DECLARE @ret CHAR(1)

DECLARE @z_endip CHAR(15)
DECLARE @nCont SMALLINT
DECLARE @nAchouGrupo SMALLINT
DECLARE @aux_icard CHAR(12)          


SET DATEFORMAT YMD


	set @ret = 0

	-- cursor para matriculas cujas digitais foram alteradas
	DECLARE cur_stdigital CURSOR FOR (select ICARD, STATUS from CONTDIG_TSI1 WHERE STATUS = '1' or STATUS = '3' or STATUS = '8')

	OPEN cur_stdigital
	FETCH NEXT FROM cur_stdigital INTO @c_icard, @c_status
	while @@fetch_status != -1
	begin
	
		SET @nAchouGrupo = 0		-- presupoe q nao tem icard x grupo correspondente em tab 
	
		-- *************************************************************************
		-- prepara os ids excluidos (controle.situa = invalido) ou grupos da controle alterados, retirando as digitais de todos os equipamentos 
		IF (@c_status = '3') or (@c_status = '8') BEGIN			-- alterados grupos (3) ou situa invalidos  (8)

			-- MONTA temporaria matricula x equipamentos cadastrados
			INSERT INTO TMP_DIG103 (ICARD, END_IP, STATUS, BIO_TIPO) 		
				SELECT distinct @c_icard, DAT07.END_IP, '0', DAT07.BIO_TIPO 
				FROM DAT07 
				WHERE BIO_TIPO = '8';

	
			-- *****************************************************************
			-- COMO ESTA EXCLUINDO O FUNCIONARIO DA EMPRESA (CONTROLE.SITUA = '1' INVALIDO), TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN
			-- COMO ALTEROU O GRUPO, TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN

			--DELETE FROM DIG003 WHERE ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1')
			
			-- VAI DELETAR A MATRICULA DE QUALQUER STATUS PORQUE PODE CAIR NA SITUACAO EM QUE HA INCLUSAO DA MATRICULA, MAS NAO VAI PORQUE O EQUIPAMENTO 'ESTA OCUPADO' (nova resposta do microdimarms).
			-- SE HOUVER POSTERIORMENTE EXCLUSAO DESSA MESMA MATRICULA, DEVE=-SE EXCLUIR A INCLUSAO DESSA MATRICULA DA TABELA
			DELETE FROM DIG003 WHERE ICARD = @c_icard 
		
		END	

		IF (@c_status = '1') or (@c_status = '3')  BEGIN				-- alteracao na digital ou em grupo

			-- ******************************************************************
			-- para todos icards q alteraram digital, distribui nos equipamentos de acordo com o grupo cadastrado em 
			-- CONTROLE, DAT07,DAT08 
			-- MONTA temporaria matricula com codins com permissao acesso
					
			insert into TMP_DIG003 (ICARD, END_IP, STATUS, BIO_TIPO)
			SELECT distinct A.icard,  A.end_ip, A.st, A.bio_tipo
				FROM 
					-- seleciona os equipamentos que fazem parte dos grupos do usuário
					(SELECT distinct @c_icard as 'icard',  dat07.end_ip, '0' as 'st', dat07.bio_tipo
						from dat07, dat08 
						where 
							dat07.end_ip <> '000.000.000.000' and
							CONVERT(int,dat08.grupo) in (
								select CONVERT(int,grupo) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')  		-- antes era ((SITUA = '1') or (SITUA = '7'))
								  union
								select CONVERT(int,grupo1) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union	
								select CONVERT(int,grupo2) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo3) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_sab) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_dom) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_fer) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,A.grupo) from MATNGRUPOS A, CONTROLE B where A.ICARD = @c_icard  AND B.ICARD = @c_icard AND (B.SITUA <> '1') and (B.VER_DIGIT <> '1')
								  union
								select CONVERT(int,A.grupo) from MATGRUPO A, CONTROLE B where A.ICARD = @c_icard  AND B.ICARD = @c_icard AND (B.SITUA <> '1') and (B.VER_DIGIT <> '1')
								) and
						  CONVERT(int,dat07.laces) = CONVERT(int,dat08.laces) and
						  CONVERT(int,dat07.planta) = CONVERT(int,dat08.planta) and
						  dat07.bio_tipo = '8'  
				UNION
					SELECT distinct @c_icard as 'icard',  dat07.end_ip, '0' as 'st', dat07.bio_tipo
						from dat07, MATCODIN 
						where 
							matcodin.icard = @c_icard and
							matcodin.end_ip <> '000.000.000.000' and 
							matcodin.end_ip = dat07.end_ip and 
							dat07.bio_tipo = '8') as A
							
			-- para quem incluiu/alterou digital (status 1) ou mudou de grupo (status 3)				
			-- IF (@c_status = '3') BEGIN
			IF (@c_status = '1') OR (@c_status = '3') BEGIN
				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao temporaria os equipamentos que fazem parte do novo grupo

				DELETE FROM TMP_DIG103
					WHERE EXISTS
						(SELECT TMP_DIG003.icard 
							FROM 
								TMP_DIG003
							WHERE 
								TMP_DIG003.icard = TMP_DIG103.icard and
								TMP_DIG003.END_IP = TMP_DIG103.END_IP and
							  	TMP_DIG003.icard = @c_icard
						);

				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao final os equipamentos do ID em questão, para REFAZER a tabela
				
				--DELETE from DIG103 where ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1')
				-- VAI DELETAR A MATRICULA DE QUALQUER STATUS PORQUE PODE CAIR NA SITUACAO EM QUE HA EXCLUSAO DA MATRICULA, MAS NAO VAI PORQUE O EQUIPAMENTO ESTA OCUPADO.
				-- SE HOUVER POSTERIORMENTE INCLUSAO DESSA MESMA MATRICULA, DEVE=-SE EXCLUIR A EXCLUSAO DESSA MATRICULA DA TABELA
				DELETE from DIG103 where ICARD = @c_icard 
				
			END
							
		END

		-- ******************************************************************
		-- PREPARA TABELA TEMPORARIA DE INCLUSAO COM OS ENDEREÇOS IP 
		SET @nCont = (SELECT COUNT(*) FROM TMP_DIG003)

		-- verifica se a matricula esta cadastrada em controle e se pertence a alguma codin. 
		-- Caso negativo, seu status ainda continua setado até que seja cadastrada e pertença a algum local de acesso
		IF (@nCont != 0) BEGIN

			-- insere icard-codin em tab. DIG003, se não existir em tab.
			DECLARE cur_tmpdigital CURSOR FOR (select ICARD, END_IP, STATUS, BIO_TIPO from TMP_DIG003)
			OPEN cur_tmpdigital
			FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio

			while @@fetch_status != -1
			begin
				UPDATE DIG003 SET STATUS = '1' 
					WHERE  ICARD = @xc_icard AND
						   END_IP = @xc_endip
				if @@rowcount = 0
				begin		
					INSERT INTO DIG003 (ICARD, END_IP, STATUS, BIO_TIPO) 
						values (@xc_icard, @xc_endip, '1', @xc_tipobio);
				end

				FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio
			end
			
			SET @nAchouGrupo = 1;
			
			-- coloca o codin na tab. DIG002 (CARGA LISTA) o codin não existir
			insert into DIG002 (END_IP, DATA_LOAD, STATUS, BIO_TIPO)
				select distinct end_ip, getdate(), '0', bio_tipo  
				from
					DIG003
				where
					end_ip not in ( select end_ip from DIG002 );
			
			CLOSE cur_tmpdigital
			DEALLOCATE cur_tmpdigital
		END

		-- ******************************************************************
		-- PREPARA TABELA TEMPORARIA DE EXCLUSAO COM OS ENDEREÇOS IP DOS EQUIPAMENTOS
		SET @nCont = (SELECT COUNT(*) FROM TMP_DIG103)
		IF (@nCont != 0) BEGIN

			-- insere na tabela final DIG103  os ID COM STATUS de carga (0 / 1= a excluir)
			DECLARE cur_tmpdigital CURSOR FOR (select ICARD, END_IP, STATUS, BIO_TIPO from TMP_DIG103)
			OPEN cur_tmpdigital
			FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio

			WHILE @@fetch_status != -1 BEGIN
				UPDATE DIG103 SET STATUS = '1' 
					WHERE  ICARD = @xc_icard AND
						   END_IP = @xc_endip
				if @@rowcount = 0
				begin		
					INSERT INTO DIG103 (ICARD, END_IP, STATUS, BIO_TIPO) 
						values (@xc_icard, @xc_endip, '1', @xc_tipobio);
				end

				FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio
			end
			
			SET @nAchouGrupo = 1;

			-- coloca o equipamento na tab. DIG102 (CARGA LISTA) o equipamento q não existir
			insert into DIG102 (END_IP, DATA_LOAD, STATUS, BIO_TIPO)
				select distinct END_IP, GETDATE(), '0', BIO_TIPO
				from
					DIG103
				where
					END_IP not in ( select END_IP from DIG102 );
							
			CLOSE cur_tmpdigital
			DEALLOCATE cur_tmpdigital
		END	


		-- atualiza status da matricula, como tratado
		IF (@nAchouGrupo = 1) 	
			update CONTDIG_TSI1 SET STATUS = '0' 
				where ICARD = @c_icard;
			
		DELETE TMP_DIG003
		DELETE TMP_DIG103

		FETCH NEXT FROM cur_stdigital INTO @c_icard, @c_status
	end
	CLOSE cur_stdigital
	deallocate cur_stdigital

GO

if object_id('TELESSVR.G3G5_prep3_Palmv', 'p') is null
    exec ('create procedure TELESSVR.G3G5_prep3_Palmv as select 1')
go

ALTER PROCEDURE TELESSVR.G3G5_prep3_Palmv AS

DECLARE @nCont SMALLINT
DECLARE @nAchouGrupo SMALLINT
DECLARE @aux_icard CHAR(12)          

DECLARE @c_status CHAR(1)
DECLARE @c_icard CHAR(12)

DECLARE @xc_status CHAR(1)
DECLARE @xc_icard CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @ret CHAR(1)


SET DATEFORMAT YMD


	set @ret = 0

	SET LOCK_TIMEOUT 5000
	
	
	--begin TRAN

	-- cursor para matriculas cujas digitais foram alteradas
	DECLARE cur_autopalmv CURSOR FOR (select ICARD, ST from PALMV001 WHERE ST = '1' or ST = '3' or ST = '8')
	OPEN cur_autopalmv
	FETCH NEXT FROM cur_autopalmv INTO @c_icard, @c_status
	WHILE (@@fetch_status != -1)
	BEGIN          
		SET @nAchouGrupo = 0		-- presupoe q nao tem icard x grupo correspondente em tab 
		
		-- *************************************************************************
		-- prepara os ids excluidos (controle.situa = invalido) ou grupos da controle alterados, retirando os faces de todos os equipamentos SENSOBOXs
		IF (@c_status = '3') or (@c_status = '8') BEGIN			-- alterados grupos (3) ou situa invalidos  (8)
		
			-- MONTA temporaria matricula x SENSOBOXs cadastrados
			INSERT INTO TMP2_PALMV015 (ICARD, END_CTRLPALMV) 		
				SELECT distinct @c_icard, DAT07.END_IP
				FROM DAT07 
				WHERE BIO_TIPO = 'A';

			-- ******************************************************************
			-- COMO ESTA EXCLUINDO O FUNCIONARIO DA EMPRESA (CONTROLE.SITUA = '1' INVALIDO), TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN
			-- COMO ALTEROU O GRUPO, TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN

			--DELETE PALMV014 WHERE ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1')
			
			-- VAI DELETAR A MATRICULA DE QUALQUER STATUS PORQUE PODE CAIR NA SITUACAO EM QUE HA INCLUSAO DA MATRICULA, MAS NAO VAI PORQUE O EQUIPAMENTO 'ESTA OCUPADO' (nova resposta do microdimarms).
			-- SE HOUVER POSTERIORMENTE EXCLUSAO DESSA MESMA MATRICULA, DEVE=-SE EXCLUIR A INCLUSAO DESSA MATRICULA DA TABELA
			DELETE PALMV014 WHERE ICARD = @c_icard
				

--			DECLARE cur_tmpauto CURSOR FOR (SELECT ICARD, END_CTRLPALMV, STATUS from PALMV014 --WITH (UPDLOCK, NOWAIT)
--				where ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1'))
--			OPEN cur_tmpauto
--			FETCH NEXT FROM cur_tmpauto into @xc_icard, @xc_endip, @xc_status
			
--			WHILE @@fetch_status != -1
--			begin
--				DELETE PALMV014 WHERE ICARD = @xc_icard and END_CTRLPALMV = @xc_endip
--				FETCH NEXT FROM cur_tmpauto into @xc_icard, @xc_endip, @xc_status
--			end
			
--			CLOSE cur_tmpauto
--			DEALLOCATE cur_tmpauto
			
		END
		
		IF (@c_status = '1') or (@c_status = '3') BEGIN		-- incluido/alterado face (1)   ou   alterados grupos (3) 

			-- ******************************************************************
			-- para todos icards q alteraram face, distribui nos SENSOBOXs de acordo como grupo cadastrado em 
			-- CONTROLE, DAT07,DAT08
			-- MONTA temporaria matricula com codins com permissao acesso
			
			INSERT INTO TMP2_PALMV014 (ICARD, END_CTRLPALMV) 		
				SELECT distinct tA.icard, tA.END_IP
					FROM 
						-- seleciona os equipamentos que fazem parte dos grupos do usuário
						(SELECT distinct @c_icard as 'icard',  dat07.end_ip
							from dat07, dat08
							where
							  dat07.end_ip <> '000.000.000.000' and
							  CONVERT(int,dat08.grupo) in (
								select CONVERT(int,grupo) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1')		-- era (SITUA = '0' OR SITUA = '7')
								  union
								select CONVERT(int,grupo1) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1')
								  union	
								select CONVERT(int,grupo2) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1')
								  union
								select CONVERT(int,grupo3) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1')
								  union
								select CONVERT(int,grupo_sab) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1')
								  union
								select CONVERT(int,grupo_dom) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1')
								  union
								select CONVERT(int,grupo_fer) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1')
								  union
								select CONVERT(int,A.grupo) from MATNGRUPOS A, CONTROLE B where A.ICARD = @c_icard  AND B.ICARD = @c_icard AND (B.SITUA <> '1')
								  union
								select CONVERT(int,A.grupo) from MATGRUPO A, CONTROLE B where A.ICARD = @c_icard  AND B.ICARD = @c_icard AND (B.SITUA <> '1')
								) and
							  CONVERT(int,dat07.laces) = CONVERT(int,dat08.laces) and
							  CONVERT(int,dat07.planta) = CONVERT(int,dat08.planta) and
							  dat07.bio_tipo = 'A'
				UNION
					SELECT distinct @c_icard as 'icard',  dat07.end_ip
						from dat07, MATCODIN 
						where
							matcodin.icard = @c_icard and
							matcodin.end_ip <> '000.000.000.000' and 
							matcodin.end_ip = dat07.end_ip and 
							dat07.bio_tipo = 'A') as tA
			
			
			-- para quem incluiu/alterou digital (status 1) ou mudou de grupo (status 3)
			--IF (@c_status = '3') BEGIN
			IF (@c_status = '1') OR (@c_status = '3') BEGIN
				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao temporaria os SENSOBOX que fazem parte do novo grupo

				DELETE FROM TMP2_PALMV015
				WHERE EXISTS
				  ( SELECT TMP2_PALMV014.icard 
					FROM TMP2_PALMV014
						WHERE TMP2_PALMV014.icard = TMP2_PALMV015.icard AND
							  TMP2_PALMV014.END_CTRLPALMV = TMP2_PALMV015.END_CTRLPALMV AND TMP2_PALMV014.icard = @c_icard
					);

				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao final os SENSOBOX do ID em questão, PARA refazer a tabela
				--DELETE from PALMV015 where ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1')
				
				-- VAI DELETAR A MATRICULA DE QUALQUER STATUS PORQUE PODE CAIR NA SITUACAO EM QUE HA EXCLUSAO DA MATRICULA, MAS NAO VAI PORQUE O EQUIPAMENTO ESTA OCUPADO.
				-- SE HOUVER POSTERIORMENTE INCLUSAO DESSA MESMA MATRICULA, DEVE=-SE EXCLUIR A EXCLUSAO DESSA MATRICULA DA TABELA
				DELETE from PALMV015 where ICARD = @c_icard
				

--				DECLARE cur_tmpauto CURSOR FOR (SELECT ICARD, END_CTRLPALMV, STATUS from PALMV015 --WITH (UPDLOCK, NOWAIT)
--					where ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1'))
--				OPEN cur_tmpauto
--				FETCH NEXT FROM cur_tmpauto into @xc_icard, @xc_endip, @xc_status
--
--				WHILE @@fetch_status != -1
--				begin
--					DELETE PALMV015 WHERE ICARD = @xc_icard and END_CTRLPALMV = @xc_endip
--					FETCH NEXT FROM cur_tmpauto into @xc_icard, @xc_endip, @xc_status
--				end
--
--				CLOSE cur_tmpauto
--				DEALLOCATE cur_tmpauto

			END
			
		END
			
		-- ******************************************************************
		-- PREPARA TABELA TEMPORARIA DE INCLUSAO COM OS ENDEREÇOS IP DOS SENSOBOXS
		SET @nCont = (SELECT COUNT(*) FROM TMP2_PALMV014)
				
		IF (@nCont != 0) BEGIN
			-- insere na tabela final PALMV014  os ID x SENSOBOX e STATUS de carga (0 / 1= a carregar)
			DECLARE cur_autoins CURSOR FOR (SELECT ICARD, END_CTRLPALMV from TMP2_PALMV014)
			OPEN cur_autoins
			FETCH NEXT FROM cur_autoins into @xc_icard, @xc_endip

			WHILE (@@fetch_status != -1)	BEGIN
					
				SELECT @aux_icard  = icard from PALMV014 --WITH (UPDLOCK, NOWAIT) 
					WHERE ICARD = @xc_icard AND
						  END_CTRLPALMV = @xc_endip ;
								  
				IF (@@ROWCOUNT = 0)
					INSERT INTO PALMV014 (ICARD, END_CTRLPALMV, STATUS) 
								values (@xc_icard, @xc_endip, '1')
				ELSE
					UPDATE PALMV014 SET STATUS = '1' 
						WHERE  ICARD = @xc_icard AND
							   END_CTRLPALMV = @xc_endip;
					
				FETCH NEXT FROM cur_autoins into @xc_icard, @xc_endip
			END;					
			
			SET @nAchouGrupo = 1;
			
			-- coloca o SENSOBOX na tab. PALMV004 (CARGA LISTA) o SENSOBOX q não existir
			insert into PALMV004 (END_CTRLPALMV, DATA_LOAD, STATUS)
				select distinct END_CTRLPALMV, GETDATE(), '0'
					from
						PALMV014
					where
						END_CTRLPALMV not in ( select END_CTRLPALMV from PALMV004 );

			CLOSE cur_autoins
			DEALLOCATE cur_autoins
						
		END
			
		-- PREPARA TABELA TEMPORARIA DE EXCLUSAO COM OS ENDEREÇOS IP DOS SENSOBOXS
		
		SET @nCont = (SELECT COUNT(*) FROM TMP2_PALMV015)
		IF (@nCont != 0) BEGIN

			-- insere na tabela final PALMV015  os ID x SENSOBOX e STATUS de carga (0 / 1= a excluir)
			DECLARE cur_autoexc CURSOR FOR (SELECT ICARD, END_CTRLPALMV from TMP2_PALMV015)
			OPEN cur_autoexc
			FETCH NEXT FROM cur_autoexc into @xc_icard, @xc_endip

			WHILE (@@fetch_status != -1)	BEGIN
					
				SELECT @aux_icard  = icard from PALMV015 --WITH(UPDLOCK, NOWAIT)
					WHERE ICARD = @xc_icard AND
						  END_CTRLPALMV = @xc_endip ;
								  
				IF (@@ROWCOUNT = 0)
					INSERT INTO PALMV015 (ICARD, END_CTRLPALMV, STATUS) 
								values (@xc_icard, @xc_endip, '1')
				ELSE
					UPDATE PALMV015 SET STATUS = '1' 
						WHERE  ICARD = @xc_icard AND
							   END_CTRLPALMV = @xc_endip;
					
				FETCH NEXT FROM cur_autoexc into @xc_icard, @xc_endip
			END;					
			
			SET @nAchouGrupo = 1

			-- coloca o SENSOBOX na tab. PALMV005 (CARGA LISTA) o SENSOBOX q não existir
			insert into PALMV005 (END_CTRLPALMV, DATA_LOAD, STATUS)
				select distinct END_CTRLPALMV, GETDATE(), '0'
				from
					PALMV015
				where
					END_CTRLPALMV not in ( select END_CTRLPALMV from PALMV005 );
							
			CLOSE cur_autoexc
			DEALLOCATE cur_autoexc
		END	
			
		-- atualiza status da matricula, como tratado
		IF (@nAchouGrupo = 1) 	
			update PALMV001 SET ST = '0' 
				where ICARD = @c_icard;
			
		DELETE TMP2_PALMV014
		DELETE TMP2_PALMV015

		FETCH NEXT FROM cur_autopalmv INTO @c_icard, @c_status
	END

	CLOSE cur_autopalmv
	DEALLOCATE cur_autopalmv

	--COMMIT TRAN
	SET LOCK_TIMEOUT -1
GO

if object_id('TELESSVR.PREP2_OUTROSBIOS', 'p') is null
    exec ('create procedure TELESSVR.PREP2_OUTROSBIOS as select 1')
go

ALTER PROCEDURE TELESSVR.PREP2_OUTROSBIOS AS

DECLARE @c_status CHAR(1)
DECLARE @c_biotipo CHAR(1)
DECLARE @c_icard CHAR(12)

DECLARE @xc_status CHAR(1)
DECLARE @xc_icard CHAR(12)
DECLARE @xc_endip CHAR(15)
DECLARE @xc_tipobio CHAR(1)
DECLARE @ret CHAR(1)

DECLARE @z_endip CHAR(15)
DECLARE @nCont SMALLINT
DECLARE @nAchouGrupo SMALLINT
DECLARE @aux_icard CHAR(12)          


SET DATEFORMAT YMD


	set @ret = 0

	-- cursor para matriculas cujas digitais foram alteradas
	DECLARE cur_stdigital CURSOR FOR (select ICARD, STATUS, BIO_TIPO from CONTDIG_OUTROS WHERE STATUS = '1' or STATUS = '3' or STATUS = '8')

	OPEN cur_stdigital
	FETCH NEXT FROM cur_stdigital INTO @c_icard, @c_status, @c_biotipo
	while @@fetch_status != -1
	begin
	
		SET @nAchouGrupo = 0		-- presupoe q nao tem icard x grupo correspondente em tab 
	
		-- *************************************************************************
		-- prepara os ids excluidos (controle.situa = invalido) ou grupos da controle alterados, retirando as digitais de todos os equipamentos 
		IF (@c_status = '3') or (@c_status = '8') BEGIN			-- alterados grupos (3) ou situa invalidos  (8)

			-- MONTA temporaria matricula x equipamentos cadastrados
			INSERT INTO TMP_DIG104 (ICARD, END_IP, STATUS, BIO_TIPO) 		
				SELECT distinct @c_icard, DAT07.END_IP, '0', @c_biotipo 
				FROM DAT07 
				WHERE BIO_TIPO = @c_biotipo and END_IP <> '000.000.000.000';

	
			-- *****************************************************************
			-- COMO ESTA EXCLUINDO O FUNCIONARIO DA EMPRESA (CONTROLE.SITUA = '1' INVALIDO), TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN
			-- COMO ALTEROU O GRUPO, TIRA DA LISTA DE INCLUSAO DE TODOS OS equipamentos PALMVEIN

			DELETE FROM DIG004 WHERE ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1') AND BIO_TIPO = @c_biotipo 
		
		END	

		IF (@c_status = '1') or (@c_status = '3')  BEGIN				-- alteracao na digital ou em grupo

			-- ******************************************************************
			-- para todos icards q alteraram digital, distribui nos equipamentos de acordo com o grupo cadastrado em 
			-- CONTROLE, DAT07,DAT08 
			-- MONTA temporaria matricula com codins com permissao acesso
					
			insert into TMP_DIG004 (ICARD, END_IP, STATUS, BIO_TIPO)
			SELECT distinct A.icard,  A.end_ip, A.st, A.bio_tipo
				FROM 
					-- seleciona os equipamentos que fazem parte dos grupos do usuário
					(SELECT distinct @c_icard as 'icard',  dat07.end_ip, '0' as 'st', dat07.bio_tipo
						from dat07, dat08 
						where 
							dat07.end_ip <> '000.000.000.000' and
							CONVERT(int,dat08.grupo) in (
								select CONVERT(int,grupo) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')  		-- antes era ((SITUA = '1') or (SITUA = '7'))
								  union
								select CONVERT(int,grupo1) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union	
								select CONVERT(int,grupo2) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo3) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_sab) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_dom) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,grupo_fer) from CONTROLE where ICARD = @c_icard AND (SITUA <> '1') AND (VER_DIGIT <> '1')
								  union
								select CONVERT(int,A.grupo) from MATNGRUPOS A, CONTROLE B where A.ICARD = @c_icard  AND B.ICARD = @c_icard AND (B.SITUA <> '1') and (B.VER_DIGIT <> '1')
								  union
								select CONVERT(int,A.grupo) from MATGRUPO A, CONTROLE B where A.ICARD = @c_icard  AND B.ICARD = @c_icard AND (B.SITUA <> '1') and (B.VER_DIGIT <> '1')
								) and
						  CONVERT(int,dat07.laces) = CONVERT(int,dat08.laces) and
						  CONVERT(int,dat07.planta) = CONVERT(int,dat08.planta) and
						  dat07.bio_tipo = @c_biotipo   
				UNION
					SELECT distinct @c_icard as 'icard',  dat07.end_ip, '0' as 'st', dat07.bio_tipo
						from dat07, MATCODIN 
						where 
							matcodin.icard = @c_icard and
							matcodin.end_ip <> '000.000.000.000' and 
							matcodin.end_ip = dat07.end_ip and 
							dat07.bio_tipo = @c_biotipo) as A
							
			IF (@c_status = '3') BEGIN
				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao temporaria os equipamentos que fazem parte do novo grupo

				DELETE FROM TMP_DIG104
					WHERE EXISTS
						(SELECT TMP_DIG004.icard 
							FROM 
								TMP_DIG004
							WHERE 
								TMP_DIG004.icard = TMP_DIG104.icard and
								TMP_DIG004.END_IP = TMP_DIG104.END_IP and
							  	TMP_DIG004.icard = @c_icard
						);

				-- ******************************************************************
				-- deve-se excluir da tabela de exclusao final os equipamentos do ID em questão, para REFAZER a tabela
				DELETE from DIG104 where ICARD = @c_icard AND (STATUS = '0' OR STATUS = '1') AND BIO_TIPO = @c_biotipo
			END
							
		END

		-- ******************************************************************
		-- PREPARA TABELA TEMPORARIA DE INCLUSAO COM OS ENDEREÇOS IP 
		SET @nCont = (SELECT COUNT(*) FROM TMP_DIG004)

		-- verifica se a matricula esta cadastrada em controle e se pertence a alguma codin. 
		-- Caso negativo, seu status ainda continua setado até que seja cadastrada e pertença a algum local de acesso
		IF (@nCont != 0) BEGIN

			-- insere icard-codin em tab. DIG004, se não existir em tab.
			DECLARE cur_tmpdigital CURSOR FOR (select ICARD, END_IP, STATUS, BIO_TIPO from TMP_DIG004)
			OPEN cur_tmpdigital
			FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio

			while @@fetch_status != -1
			begin
				UPDATE DIG004 SET STATUS = '1' 
					WHERE  ICARD = @xc_icard AND
						   END_IP = @xc_endip
				if @@rowcount = 0
				begin		
					INSERT INTO DIG004 (ICARD, END_IP, STATUS, BIO_TIPO) 
						values (@xc_icard, @xc_endip, '1', @xc_tipobio);
				end

				FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio
			end
			
			SET @nAchouGrupo = 1;
			
			-- coloca o codin na tab. DIG002 (CARGA LISTA) o codin não existir
			insert into DIG002 (END_IP, DATA_LOAD, STATUS, BIO_TIPO)
				select distinct end_ip, getdate(), '0', bio_tipo  
				from
					DIG004
				where
					end_ip not in ( select end_ip from DIG002 );
			
			CLOSE cur_tmpdigital
			DEALLOCATE cur_tmpdigital
		END

		-- ******************************************************************
		-- PREPARA TABELA TEMPORARIA DE EXCLUSAO COM OS ENDEREÇOS IP DOS EQUIPAMENTOS
		SET @nCont = (SELECT COUNT(*) FROM TMP_DIG104)
		IF (@nCont != 0) BEGIN

			-- insere na tabela final DIG104  os ID COM STATUS de carga (0 / 1= a excluir)
			DECLARE cur_tmpdigital CURSOR FOR (select ICARD, END_IP, STATUS, BIO_TIPO from TMP_DIG104)
			OPEN cur_tmpdigital
			FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio

			WHILE @@fetch_status != -1 BEGIN
				UPDATE DIG104 SET STATUS = '1' 
					WHERE  ICARD = @xc_icard AND
						   END_IP = @xc_endip AND 
						   BIO_TIPO = @xc_tipobio
				if @@rowcount = 0
				begin		
					INSERT INTO DIG104 (ICARD, END_IP, STATUS, BIO_TIPO) 
						values (@xc_icard, @xc_endip, '1', @xc_tipobio);
				end

				FETCH NEXT FROM cur_tmpdigital into @xc_icard, @xc_endip, @xc_status, @xc_tipobio
			end
			
			SET @nAchouGrupo = 1;

			-- coloca o equipamento na tab. DIG102 (CARGA LISTA) o equipamento q não existir
			insert into DIG102 (END_IP, DATA_LOAD, STATUS, BIO_TIPO)
				select distinct END_IP, GETDATE(), '0', BIO_TIPO
				from
					DIG104
				where
					END_IP not in ( select END_IP from DIG102 );
							
			CLOSE cur_tmpdigital
			DEALLOCATE cur_tmpdigital
		END	


		-- atualiza status da matricula, como tratado
		IF (@nAchouGrupo = 1) 	
			update CONTDIG_OUTROS SET STATUS = '0' 
				where ICARD = @c_icard  AND 
					  BIO_TIPO = @c_biotipo;
			
		DELETE TMP_DIG004
		DELETE TMP_DIG104

		FETCH NEXT FROM cur_stdigital INTO @c_icard, @c_status, @c_biotipo
	end
	CLOSE cur_stdigital
	deallocate cur_stdigital

GO

if object_id('TELESSVR.G3G5_P_GERDIGITAL5', 'p') is null
    exec ('create procedure TELESSVR.G3G5_P_GERDIGITAL5 as select 1')
go

ALTER PROCEDURE TELESSVR.G3G5_P_GERDIGITAL5 AS

DECLARE @ret CHAR(1)


	SET DATEFORMAT YMD


	set @ret = 0
	
	exec TELESSVR.G3G5_PREP3_SAGEM	-- prepara automatico digitais sagem
	
	exec TELESSVR.G3G5_PREP3_TSI1	-- prepara automatico digitais tsi1

	exec TELESSVR.G3G5_prep3_Palmv	-- prepara PALMV014/PALMV004 (INCLUSAO)  e PALMV015/PALMV005 (EXCLUSAO)

	exec TELESSVR.PREP2_OUTROSBIOS	-- prepara automatico Outras biometrias


	exec TELESSVR.trata4_sagem		-- trata biometria sagem

	exec TELESSVR.trata4_tsi1		-- trata biometria tsi1
	
	exec TELESSVR.trata3_palmv		-- trata PALMVEIN

	exec TELESSVR.trata_OutrosBios		-- trata Outras Biometrias
	
	select @ret
	GO



SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

-----------------------------------------------------------------------------------------
-- 2.10.11.10 || 2.10.11.10 || 2.10.11.10 || 2.10.11.10 || 2.10.11.10 || 2.10.11.10 || --
-----------------------------------------------------------------------------------------

-- SEM ALTERAÇÃO DE SCRIPT NESTA RELEASE


-----------------------------------------------------------------------------------------
-- 2.10.11.11 || 2.10.11.11 || 2.10.11.11 || 2.10.11.11 || 2.10.11.11 || 2.10.11.11 || --
-----------------------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Inclusion date:  30/06/2021 - 16:49
-- Change date:     28/07/2021 - 12:52
-- Sequence:        0435
-- Redmine:         @11538, @12010
-----------------------------------------------------------------------------

/*
{ 
  "database"    : "MSSSQL",
  "owner"       : "TELESSVR",
  "type"        : "TRIGGER",
  "name"        : "DAM00_EI",
  "description" : "DAM00_EI",
  "version"     : "1.0.8.0",
  "log"         : {
                   "1.0.8.0" : { "author" : "Nathan Gabriel", "created" : "28/07/2021", "issue" : "@12010", "description" : "Correção do erro na conversão quando o equipamento é de beneficio"},
                   "1.0.7.0" : { "author" : "Alex Siqueira",  "created" : "21/05/2021", "issue" : "@11538", "description" : "Implementar a compatibilidade de 5 dígitos no Suricato para Planta, Codin, Grupo de Acesso, Grupo de REP e Filial"},
                   "1.0.6.0" : { "author" : "Alex Siqueira",  "created" : "21/05/2021", "issue" : "@",      "description" : "Removido condição no histórico de provisório que conflita com a data 19001231"},
                   "1.0.5.0" : { "author" : "Alex Siqueira",  "created" : "21/05/2021", "issue" : "@",      "description" : "Removido customização POC Senado que conflita com a funcionalidade de crachá veículo"},
                   "1.0.4.0" : { "author" : "Nathan Gabriel", "created" : "12/05/2021", "issue" : "@11548", "description" : "Correção na valiável ICARDREAL não estar zerada antes de realizar as consultas"}
                  }
}
*/
IF EXISTS (SELECT 1 FROM SYS.OBJECTS WHERE LOWER(NAME) = LOWER('DAM00_EI'))
    DROP TRIGGER TELESSVR.DAM00_EI;
GO

CREATE TRIGGER TELESSVR.DAM00_EI ON TELESSVR.DAM00 FOR UPDATE, INSERT 
AS

BEGIN
--VERSION_CONTROL 1.0.8.0 VERSION_CONTROL

    DECLARE @ICARD CHAR(12)
    DECLARE @DIAM CHAR(2)
    DECLARE @MESM CHAR(2)
    DECLARE @ANOM CHAR(2)
    DECLARE @HORAM CHAR(4)
    DECLARE @SEGUNDO CHAR(2)
    DECLARE @CODAC CHAR(2)
    DECLARE @POSIC CHAR(1)
    DECLARE @BLUEB CHAR(2)
    DECLARE @CODTT CHAR(2)
    DECLARE @END_IP CHAR(15)
    DECLARE @CODIFUNC CHAR(2)
    DECLARE @ONOFF CHAR(1)
    DECLARE @VEICULO VARCHAR(15)
    DECLARE @ERRO INT
    DECLARE @CODIPLAN NUMERIC(5)
    DECLARE @CODICOLE NUMERIC(5)
    DECLARE @CODIBENE NUMERIC(2)
    DECLARE @USOMARC  NUMERIC(2)
    DECLARE @DESLOG VARCHAR(254)
    DECLARE @DATAACES DATETIME
    DECLARE @HORAACES INT
    DECLARE @SEQUCOLEALAR INT
    DECLARE @IDVEIC INT
    DECLARE @CODIESTA SMALLINT
    DECLARE @IDESVISIT INT
    DECLARE @TIPOVISI INT
    DECLARE @BLOQACESSAID VARCHAR(1)
    DECLARE @BAIXAUTOCRAC VARCHAR(1)
    DECLARE @ICARDREAL CHAR(12)
    DECLARE @ACHOUICARD SMALLINT
    DECLARE @ICARDVEICULO NUMERIC(12)
    DECLARE @VIDCOLAB NUMERIC(9)
    DECLARE @VIDVISI NUMERIC(9)
    DECLARE @VDATACP DATE
    DECLARE @VHORAENTRCP DATETIME
    DECLARE @VHORASAIDCP DATETIME
    DECLARE @VHORACP DATETIME
    DECLARE @VTIPTERM CHAR(1)

    SELECT @SEQUCOLEALAR = 0

    DECLARE CUR_DAM00_INS_NEW CURSOR FOR
    SELECT ICARD, DIAM, MESM, ANOM, HORAM, SEGUNDO, CODAC, POSIC, BLUEB, CODTT, END_IP, CODFNC, ONOFF, VEICULO FROM INSERTED FOR READ ONLY

    OPEN CUR_DAM00_INS_NEW 

    FETCH NEXT FROM CUR_DAM00_INS_NEW INTO @ICARD, @DIAM, @MESM, @ANOM, @HORAM, @SEGUNDO, @CODAC, @POSIC, @BLUEB, @CODTT, @END_IP, @CODIFUNC, @ONOFF, @VEICULO

    WHILE ( @@FETCH_STATUS = 0 )
    BEGIN
    
	SELECT @DESLOG = ''
    
	SELECT @SEQUCOLEALAR = @SEQUCOLEALAR + 1 ;

    IF (  @SEGUNDO = '99' )
        SELECT @SEGUNDO = '00'
            
    IF NOT ( @DIAM LIKE '[0-9][0-9]' AND @DIAM BETWEEN '01' AND '31' )
    BEGIN     
        SELECT @DESLOG = 'DAM00: FORMATO DE DATA INVALIDO: [TELESSVR][DAM00][DIAM] = ' + @DIAM  
        GOTO FIM
    END
	
    IF NOT ( @MESM LIKE '[0-9][0-9]' AND @MESM  BETWEEN '01' AND '12' )
    BEGIN
        SELECT @DESLOG = 'DAM00: FORMATO DE DATA INVALIDO: [TELESSVR][DAM00][MESM] = ' + @MESM
        GOTO FIM          
    END
	  
    IF NOT ( @ANOM  LIKE '[0-9][0-9]'  AND @ANOM  BETWEEN '00' AND '99' )
    BEGIN
        SELECT @DESLOG = 'DAM00: FORMATO DE DATA INVALIDO: [TELESSVR][DAM00][ANOM] = ' + @ANOM
        GOTO FIM
    END

    IF NOT ( @HORAM LIKE '[0-9][0-9][0-9][0-9]'  AND @HORAM BETWEEN '0000' AND '2400' )
    BEGIN          
        SELECT @DESLOG = 'DAM00: FORMATO DE DATA INVÁLIDO: [TELESSVR][DAM00]HORAM] = ' + @HORAM
        GOTO FIM
    END
		  
    IF NOT ( @SEGUNDO LIKE '[0-9][0-9]' AND @SEGUNDO BETWEEN '00' AND '60' )
    BEGIN
        SELECT @DESLOG = 'DAM00: FORMATO DE DATA INVÁLIDO: [TELESSVR][DAM00]SEGUNDO] = ' + @SEGUNDO
        GOTO FIM
    END
    
    IF ( SURICATO.ISREALLYNUMERIC( @ICARD ) = 0 )
    BEGIN               
        SELECT @DESLOG = 'DAM00: FORMATO DE ICARD INVÁLIDO. ICARD = ' + @ICARD
        GOTO FIM               
    END
  
    SELECT @CODIPLAN = CODIPLAN, @CODICOLE = CODICOLE FROM SURICATO.TBCODIN WHERE NUMEENDECOLE = @END_IP 

    IF ( @CODIPLAN IS NULL OR @CODICOLE IS NULL )
    BEGIN
        SELECT @ERRO = 1
        SELECT @DESLOG = 'DAM00: CODIN NÃO ENCONTRADO' + @END_IP 
        GOTO FIM
    END

    SELECT @CODIBENE = CODIBENE FROM SURICATO.TBCODINBENEF WHERE CODIPLAN = @CODIPLAN AND CODICOLE = @CODICOLE

    SELECT @USOMARC = USOMARC FROM SURICATO.TBMARCAREALI WHERE CODIPLAN = @CODIPLAN AND CODICOLE = @CODICOLE AND CODIFUNC = CONVERT( NUMERIC(2) , CODIFUNC )

    SELECT @DATAACES = CONVERT( DATETIME,  @ANOM + @MESM + @DIAM, 112 )

    SELECT @HORAACES = CONVERT( INT, SUBSTRING( @HORAM, 1, 2 ) ) * 60 + CONVERT( INT, SUBSTRING( @HORAM, 3, 2 ) )

    SET @ICARDREAL = NULL

    SELECT @ICARDREAL = ICARD FROM SURICATO.TBCRACHFISIC WHERE NUMEFISICRAC = CONVERT( DECIMAL, @ICARD )    

    IF @ICARDREAL IS NULL
        SELECT @ICARDREAL = @ICARD
 
    IF EXISTS( SELECT 1 FROM SURICATO.TBMARCAACESS WHERE ICARD = @ICARDREAL AND DATAACES = @DATAACES AND HORAACES = @HORAACES AND SEQUREGI = @SEGUNDO AND CODIPLAN = @CODIPLAN AND CODICOLE = @CODICOLE )
    BEGIN
        SELECT @DESLOG = 'DAM00: DUPLICIDADE DE REGISTRO: ' + @ICARDREAL +
                         ', DATA: '   + CAST( @DATAACES AS VARCHAR ) + 
                         ', HORA: '   + CAST( @HORAACES AS VARCHAR ) + ':' + CAST( @SEGUNDO AS VARCHAR ) +
                         ', PLANTA: ' + CAST( @CODIPLAN AS VARCHAR ) +
                         ', CODIN '   + CAST( @CODICOLE AS VARCHAR )
        GOTO FIM   
    END

    -- >>> VEICULO
    SELECT @VTIPTERM = TIP_TERM FROM DAT07 WHERE END_IP = @END_IP
    SET @ICARDVEICULO = 0
              
    -- QUANDO O TIP_TERM DA DAT07 FOR DIFERENTE DE 5 (CODIN DE CONTROLE DE BENEFÍCIO), REALIZAR A CONVERSAO PARA NUMBERIC
    IF @VTIPTERM <> '5'
    BEGIN
        SELECT @ICARDVEICULO = COALESCE( CASE WHEN RTRIM(LTRIM(@VEICULO)) = '' THEN 0 ELSE CONVERT( NUMERIC, RTRIM(LTRIM(@VEICULO ))) END, 0 )
        IF ( @ICARDVEICULO = 0 AND EXISTS ( SELECT 1 FROM SURICATO.TBCADASCRACH WHERE ICARD = @ICARDREAL AND USOFAIXCRAC = 8 ) )
        BEGIN
            SELECT @ICARDVEICULO = @ICARDREAL
        END
    END
    -- <<< VEICULO

    INSERT INTO SURICATO.TBMARCAACESS ( ICARD, DATAACES, HORAACES, SEQUREGI, TIPOACES, CODIPLAN, CODICOLE, CODIFUNC, DIREACES, QUANACES, ORIGMARC, USOMARC, CODIBENE, FLAGACES, STATATUACOLE, NUMEFISICRAC, ICARDV )
    VALUES ( @ICARDREAL, @DATAACES, @HORAACES, @SEGUNDO, @CODAC, @CODIPLAN, @CODICOLE, CONVERT( NUMERIC(2), @CODIFUNC ), CASE WHEN @POSIC = '0' THEN 'E' WHEN @POSIC = '1' THEN 'S' END, 0, 'E', ISNULL( @USOMARC, 1 ), @CODIBENE, 0, CONVERT( SMALLINT, @ONOFF  ), @ICARD, @ICARDVEICULO )
          
    -- >>> ALARME
    IF ( @CODAC = '15')
    BEGIN
        SELECT 
            @VIDCOLAB = IDCOLAB 
        FROM 
            SURICATO.TBHISTOCRACH 
        WHERE 
            ICARD = @ICARDREAL 
            AND ( DATAFINA < @DATAACES OR ( DATAFINA = @DATAACES AND HORAFINA < ( @HORAACES * 60 ) ) ) 
        ORDER BY 
            DATAFINA DESC, 
            HORAFINA DESC        
    
        INSERT INTO SURICATO.TBALARSTRATA ( DATACOLEALAR, HORACOLEALAR, SEQUCOLEALAR, DATAALAR, HORAALAR, CODIPLAN, CODICOLE, CODISIND, TIPOALAR, STATALAR, DATARECOALAR, HORARECOALAR, USUARECECHAV, DESCRECOUSUA, TIPORECOREAL, ENDEENTRCOLE, ICARD, TIPOACES, IDCOLAB )
            SELECT 
                SURICATO.DATAATUAL(),
                SURICATO.HORAATUAL(),
                DATEPART( SECOND, GETDATE() ) * 1000 + DATEPART( MILLISECOND, GETDATE() ) + @SEQUCOLEALAR,
                @DATAACES, @HORAACES * 60 + @SEGUNDO, @CODIPLAN, @CODICOLE, 2015, 1, 0 , SURICATO.DATA19001231(), 0, NULL, '', NULL, NULL, @ICARDREAL, @CODAC, @VIDCOLAB
            FROM
                SURICATO.TBTIPOACESS
            WHERE 
                TIPOACES = @CODAC 
                AND TIPOACESMONI = 'S'
    END
    ELSE
    BEGIN
        INSERT INTO SURICATO.TBALARSTRATA ( DATACOLEALAR, HORACOLEALAR, SEQUCOLEALAR, DATAALAR, HORAALAR, CODIPLAN, CODICOLE, CODISIND, TIPOALAR, STATALAR, DATARECOALAR, HORARECOALAR, USUARECECHAV, DESCRECOUSUA, TIPORECOREAL, ENDEENTRCOLE, ICARD, TIPOACES )
        SELECT 
            SURICATO.DATAATUAL(),
            SURICATO.HORAATUAL(),
            DATEPART( SECOND, GETDATE() ) * 1000 + DATEPART( MILLISECOND, GETDATE() ) + @SEQUCOLEALAR,
            @DATAACES, @HORAACES * 60 + @SEGUNDO, @CODIPLAN, @CODICOLE, 9999, 0, 0 , SURICATO.DATA19001231(), 0, NULL, '', NULL, NULL, @ICARDREAL, @CODAC
          FROM
            SURICATO.TBTIPOACESS
          WHERE 
            TIPOACES = @CODAC 
			AND TIPOACESMONI = 'S'        
    END
    -- <<< ALARME	
	
    -- >>> BAIXA DE PROVISÓRIO
    IF @POSIC = '1' AND @CODAC = '01'
    BEGIN
        IF EXISTS ( SELECT 1 FROM SURICATO.TBCADASCRACH WHERE ICARD = CAST( REPLICATE( 0, 12 - LEN( CAST( @ICARDREAL AS VARCHAR ) ) ) + CAST( @ICARDREAL AS VARCHAR ) AS NUMERIC) AND USOFAIXCRAC = 6 )
        BEGIN
            IF EXISTS ( SELECT 1 FROM SURICATO.TBCODIN WHERE NUMEENDECOLE = @END_IP AND BAIXAAUTOPROV  = 'S' )
            BEGIN
                UPDATE SURICATO.TBHISTOCRACH
                SET 
                    DATAFINA = @DATAACES, 
                    HORAFINA = @HORAACES - 1,
                    STATHIST = 2,
                    STATATUACONT = 2
                WHERE 
                    ICARD = @ICARDREAL
                    AND ( DATAINIC < @DATAACES OR ( DATAINIC = @DATAACES AND HORAINIC <= @HORAACES ) ) 
                    AND ( DATAFINA > @DATAACES OR ( DATAFINA = @DATAACES AND HORAFINA >= @HORAACES ) OR ( DATAFINA = SURICATO.DATA19001231() ) )
            END
        END
    END
    -- <<< BAIXA DE PROVISÓRIO

    -- >>> BAIXA DE VISITANTE      
    IF @POSIC = '1' AND @CODAC = '01'
    BEGIN
        IF EXISTS ( SELECT 1 FROM TELESSVR.CONTROLE WHERE ICARD = REPLICATE( 0, 12 - LEN( CAST( @ICARDREAL AS VARCHAR ) ) ) + CAST( @ICARDREAL AS VARCHAR ) AND TPFIS = 4 )
        BEGIN
            IF EXISTS ( SELECT 1 FROM SURICATO.TBCODIN WHERE NUMEENDECOLE = @END_IP AND BAIXAUTOCRAC = 'S' )
            BEGIN
                SELECT 
                    @IDESVISIT = IDESVISIT, 
                    @TIPOVISI = SURICATO.TBTIPOVISIT.TIPOVISI, 
                    @BLOQACESSAID = BLOQACESSAID, 
                    @BAIXAUTOCRAC = BAIXAUTOCRAC 
                FROM 
                    SURICATO.TBTIPOVISIT
                    INNER JOIN SURICATO.TBESVISIT
                    ON SURICATO.TBTIPOVISIT.TIPOVISI = SURICATO.TBESVISIT.TIPOVISI
                WHERE 
                    ICARD = @ICARDREAL AND
                    DATASAID = SURICATO.DATA19001231()
		  
                IF UPPER( @BAIXAUTOCRAC ) = 'S'
                BEGIN
                    UPDATE SURICATO.TBESVISIT 
                    SET 
                        DATASAID = @DATAACES, 
                        HORASAID = @HORAACES,
                        DATASAIDLOCA = @DATAACES, 
                        HORASAIDLOCA = @HORAACES
                    WHERE 
                        IDESVISIT = @IDESVISIT
		    
                    UPDATE SURICATO.TBHISTOVISIT
                    SET 
                        DATAFINA = @DATAACES, 
                        HORAFINA = @HORAACES
                    WHERE 
                        ICARD = @ICARDREAL AND 
                        DATAFINA = SURICATO.DATA19001231()
                END		  
                IF UPPER( @BLOQACESSAID ) = 'S'
                UPDATE TELESSVR.CONTROLE SET SITUA = '1' WHERE ICARD = REPLICATE( 0, 12 - LEN( CAST( @ICARDREAL AS VARCHAR ) ) ) + CAST( @ICARDREAL AS VARCHAR ) AND TPFIS = 4
            END
        END
    END 
    -- <<< BAIXA DE VISITANTE

    -- >>> SURICATO RISK AREA CONTROLLER
    IF ( @CODAC = '01' ) AND
    EXISTS ( SELECT 1 FROM SURICATO.TBPARAMSERVI WHERE NOME = 'USE_RISK_AREA_CONTROLLER' AND VALO = 'S' ) AND
    EXISTS ( SELECT 1 FROM SURICATO.TBCODINLOCALACESS WHERE CODIPLAN = @CODIPLAN AND CODICOLE = @CODICOLE )
    BEGIN
        DECLARE @DATAHORA VARCHAR(19)
        SELECT @DATAHORA = '20' + @ANOM + '-' + @MESM + '-' + @DIAM + ' ' + SUBSTRING( @HORAM, 1, 2 ) + ':' + SUBSTRING( @HORAM, 3, 2 )  + ':' + @SEGUNDO

        IF (@POSIC = '0')
        BEGIN
            UPDATE SURICATO.TBCONTRLOCALACESS SET ENTRADA = CONVERT(DATETIME, @DATAHORA, 120) WHERE ICARD = CAST(@ICARDREAL AS NUMERIC) AND NUMEENDECOLE = @END_IP
        END
        ELSE
        BEGIN
            UPDATE SURICATO.TBCONTRLOCALACESS SET STATUS = 0, SAIDA = CONVERT(DATETIME, @DATAHORA, 120) WHERE ICARD = CAST(@ICARDREAL AS NUMERIC) AND NUMEENDECOLE = @END_IP
            DELETE TELESSVR.MATCODIN WHERE ICARD = @ICARDREAL AND END_IP = @END_IP
        END
    END
    -- <<< SURICATO RISK AREA CONTROLLER

    -- >>> SURICATO MESSAGE CONTROLLER
    IF EXISTS ( SELECT 1 FROM SURICATO.TBPARAMSERVI WHERE NOME = 'USE_MESSAGE_CONTROLLER' AND VALO = 'S' )
    BEGIN
        DECLARE @VDATAINIC DATETIME;

        DECLARE @VHORAINIC INTEGER;

        DECLARE CUR_MESSAGECONTROLLER CURSOR FOR SELECT ICARD FROM INSERTED FOR READ ONLY

      OPEN CUR_MESSAGECONTROLLER FETCH NEXT FROM CUR_MESSAGECONTROLLER INTO @ICARD

        WHILE ( @@FETCH_STATUS = 0 )
        BEGIN

        UPDATE 
            SURICATO.TBMENSACOLAB
          SET
            STATATUACONT = 2
          WHERE
            IDCOLAB = ( SELECT IDCOLAB FROM SURICATO.TBCOLAB WHERE IDPESSOA = SURICATO.GETIDPESSOA( @ICARD ) )
            AND ( DATAINIC < SURICATO.DATAATUAL() OR ( DATAINIC = SURICATO.DATAATUAL() AND HORAINIC <= SURICATO.HORAATUAL() ) )
            AND ( DATAFINA > SURICATO.DATAATUAL() OR ( DATAFINA = SURICATO.DATAATUAL() AND HORAFINA >= SURICATO.HORAATUAL() ) OR ( DATAFINA = SURICATO.DATA19001231() ) )
            AND STATATUACONT = 1;  

        SELECT 
            TOP 1 @VIDCOLAB = IDCOLAB, @VDATAINIC = DATAINIC, @VHORAINIC = HORAINIC 
          FROM 
            SURICATO.TBMENSACOLAB
          WHERE
            IDCOLAB = ( SELECT IDCOLAB FROM SURICATO.TBCOLAB WHERE IDPESSOA = SURICATO.GETIDPESSOA( @ICARD ) )
            AND ( DATAINIC < SURICATO.DATAATUAL() OR ( DATAINIC = SURICATO.DATAATUAL() AND HORAINIC <= SURICATO.HORAATUAL() ) )
            AND ( DATAFINA > SURICATO.DATAATUAL() OR ( DATAFINA = SURICATO.DATAATUAL() AND HORAFINA >= SURICATO.HORAATUAL() ) OR ( DATAFINA = SURICATO.DATA19001231() ) )
            AND STATATUACONT = 0
          ORDER BY
            DATAINIC, 
            HORAINIC

        IF @VIDCOLAB <> 0
        BEGIN

          UPDATE SURICATO.TBMENSACOLAB SET STATATUACONT = 1 WHERE IDCOLAB = @VIDCOLAB AND DATAINIC = @VDATAINIC AND HORAINIC = @VHORAINIC;   

        END
        ELSE
        BEGIN

          UPDATE
              SURICATO.TBMENSACOLAB
            SET
              STATATUACONT = 0
            WHERE
              IDCOLAB = ( SELECT IDCOLAB FROM SURICATO.TBCOLAB WHERE IDPESSOA = SURICATO.GETIDPESSOA( @ICARD ) )
              AND ( DATAINIC < SURICATO.DATAATUAL() OR ( DATAINIC = SURICATO.DATAATUAL() AND HORAINIC <= SURICATO.HORAATUAL() ) )
              AND ( DATAFINA > SURICATO.DATAATUAL() OR ( DATAFINA = SURICATO.DATAATUAL() AND HORAFINA >= SURICATO.HORAATUAL() ) OR ( DATAFINA = SURICATO.DATA19001231() ) )
              AND STATATUACONT = 2;

          SELECT 
              TOP 1 @VIDCOLAB = IDCOLAB, @VDATAINIC = DATAINIC, @VHORAINIC = HORAINIC 
            FROM 
              SURICATO.TBMENSACOLAB
            WHERE
              IDCOLAB = ( SELECT IDCOLAB FROM SURICATO.TBCOLAB WHERE IDPESSOA = SURICATO.GETIDPESSOA( @ICARD ) )
              AND ( DATAINIC < SURICATO.DATAATUAL() OR ( DATAINIC = SURICATO.DATAATUAL() AND HORAINIC <= SURICATO.HORAATUAL() ) )
              AND ( DATAFINA > SURICATO.DATAATUAL() OR ( DATAFINA = SURICATO.DATAATUAL() AND HORAFINA >= SURICATO.HORAATUAL() ) OR ( DATAFINA = SURICATO.DATA19001231() ) )
              AND STATATUACONT = 0
            ORDER BY
              DATAINIC, 
              HORAINIC
          
          UPDATE SURICATO.TBMENSACOLAB SET STATATUACONT = 1 WHERE IDCOLAB = @VIDCOLAB AND DATAINIC = @VDATAINIC AND HORAINIC = @VHORAINIC; 

        END

        FETCH NEXT FROM CUR_MESSAGECONTROLLER INTO @ICARD

      END

      CLOSE CUR_MESSAGECONTROLLER

      DEALLOCATE CUR_MESSAGECONTROLLER

    END
    -- <<< SURICATO MESSAGE CONTROLLER


    -- >>> BAIXA DE CRÉDITO DE REFEITÓRIO DE COLABORADOR
    IF  @CODAC = '01' 
    BEGIN

      INSERT INTO SURICATO.TBCREDCCOLAB (IDCOLAB, DATACONS, HORACONS, SEGUCONS, CONTCRED, STATHIST)
        SELECT HC.IDCOLAB, @DATAACES, @HORAACES, @SEGUNDO, AC.CONTCREDREFE, 1
          FROM 
            SURICATO.TBHISTOCRACH HC
          INNER JOIN SURICATO.TBACESSCOLAB AC
            ON HC.IDCOLAB = AC.IDCOLAB
          WHERE
            HC.ICARD = @ICARDREAL 
            AND ( HC.DATAINIC < @DATAACES OR ( HC.DATAINIC = @DATAACES AND HC.HORAINIC <= ( @HORAACES * 60 ) ) ) 
            AND ( HC.DATAFINA > @DATAACES OR ( HC.DATAFINA = @DATAACES AND HC.HORAFINA >= ( @HORAACES * 60 ) ) OR ( HC.DATAFINA = SURICATO.DATA19001231() ) ) 
            AND EXISTS (SELECT 1 FROM SURICATO.TBCODIN WHERE CODIPLAN = @CODIPLAN AND CODICOLE = @CODICOLE AND LOCACOLE = 2 )

    END
    -- <<< BAIXA DE CRÉDITO DE REFEITÓRIO DE COLABORADOR


    -- >>> IDENTIFICAÇÃO DE PESSOA POR AMBIENTE
    IF EXISTS ( SELECT 1 FROM SURICATO.TBPARAMSERVI WHERE NOME = 'PESSOA_AMBIENTE' AND VALO = 'S' ) AND @CODAC = '01' 
    BEGIN

      DECLARE @VIDPESSOA NUMERIC(9)

      DECLARE @VCODIAMBI NUMERIC(8) 

      SELECT @VIDPESSOA = SURICATO.GETIDPESSOA( @ICARD )

      SELECT @VCODIAMBI = CODIAMBI FROM SURICATO.TBAMBIECOLET WHERE CODIPLAN = @CODIPLAN AND CODICOLE = @CODICOLE

      IF (@VIDPESSOA IS NOT NULL) AND (@VCODIAMBI IS NOT NULL)
      BEGIN

      DELETE FROM SURICATO.TBPESSOAAMBIE WHERE IDPESSOA = @VIDPESSOA

      IF (@POSIC = '0')
      BEGIN
        INSERT INTO SURICATO.TBPESSOAAMBIE ( IDPESSOA, CODIAMBI ) VALUES ( @VIDPESSOA, @VCODIAMBI )
      END
      ELSE
      BEGIN
        SELECT @VCODIAMBI = CODIAMBIPAI FROM SURICATO.TBAMBIE WHERE CODIAMBI = @VCODIAMBI
        IF (@VCODIAMBI IS NOT NULL)
        BEGIN
          INSERT INTO SURICATO.TBPESSOAAMBIE ( IDPESSOA, CODIAMBI ) VALUES ( @VIDPESSOA, @VCODIAMBI )
        END
      END

      END

    END
    -- <<< IDENTIFICAÇÃO DE PESSOA POR AMBIENTE

    -- >>> CONTADOR DE PRESENCA POR AMBIENTE
    IF @CODAC = '01' AND EXISTS ( SELECT 1 FROM SURICATO.TBPARAMSERVI WHERE NOME = 'CONTADOR_PRESENCA_AMBIENTE' AND VALO = 'S' )
    BEGIN
	
      SELECT @VCODIAMBI = CODIAMBI FROM SURICATO.TBAMBIECOLET WHERE CODIPLAN = @CODIPLAN AND CODICOLE = @CODICOLE
	  
      IF (@VCODIAMBI IS NOT NULL)
      BEGIN
        EXECUTE SURICATO.SP_CONTADOR_PRESENCA_AMBIENTE @ICARDREAL, @DATAACES, @HORAACES, @SEGUNDO, @VCODIAMBI, @POSIC
      END
	  
    END
    -- <<< CONTADOR DE PRESENCA POR AMBIENTE

    -- >>> CONTADOR DE PRESENCA
    IF @CODAC = '01' AND EXISTS ( SELECT 1 FROM SURICATO.TBPARAMSERVI WHERE NOME = 'CONTADOR_PRESENCA' AND VALO = 'S' AND EXISTS (SELECT 1 FROM SURICATO.TBCODIN WHERE CODIPLAN = @CODIPLAN AND CODICOLE = @CODICOLE AND LOCACOLE = 1 ) ) 
    BEGIN
 
      EXECUTE SURICATO.SP_CONTADOR_PRESENCA @ICARDREAL, @DATAACES, @HORAACES, @SEGUNDO, @CODIPLAN, @POSIC

    END
    -- <<< CONTADOR DE PRESENCA
        
    -- >>> CONTROLAR 1 ENTRADA DE VEÍCULO POR PESSOA
    IF @CODAC = '01' AND EXISTS ( SELECT 1 FROM SURICATO.TBPARAMSERVI WHERE NOME = 'CONTROLADUPLAENTRADAVEICULO' AND VALO = 'S' AND EXISTS (SELECT 1 FROM SURICATO.TBCODIN WHERE CODIPLAN = @CODIPLAN AND CODICOLE = @CODICOLE AND DUPLENTRVEIC = 'S' ) ) 
    BEGIN

      IF (@POSIC = '0')
      BEGIN

        INSERT INTO SURICATO.TBBLOQUCRACH ( ICARD, DATABLOQ, HORABLOQ, CODIMOTI, DATALIBE, HORALIBE, STATATUACONT, NUMEFISICRAC )
          SELECT 
              HV.ICARDV, @DATAACES, @HORAACES, 1004, SURICATO.DATA19001231(), 0, 1, 0
            FROM 
              SURICATO.TBHISTORESPVEICU HRV 
            INNER JOIN SURICATO.TBHISTOVEICU HV
              ON HRV.IDVEIC = HV.IDVEIC
            WHERE
              HRV.IDCOLAB IN (
                SELECT 
                    HRV.IDCOLAB
                  FROM 
                    SURICATO.TBHISTORESPVEICU HRV
                  INNER JOIN SURICATO.TBHISTOVEICU HV
                    ON HRV.IDVEIC = HV.IDVEIC
                  WHERE
                    HV.ICARDV = @ICARDREAL 
                    AND ( HRV.DATAINIC < @DATAACES OR ( HRV.DATAINIC = @DATAACES AND HRV.HORAINIC <= @HORAACES ) ) 
                    AND ( HRV.DATAFIM > @DATAACES OR ( HRV.DATAFIM = @DATAACES AND HRV.HORAFINA >= @HORAACES ) OR ( HRV.DATAFIM = SURICATO.DATA19001231() ) ) 
              )
              AND HV.ICARDV <> @ICARDREAL  
              AND ( HRV.DATAINIC < @DATAACES OR ( HRV.DATAINIC = @DATAACES AND HRV.HORAINIC <= @HORAACES ) ) 
              AND ( HRV.DATAFIM > @DATAACES OR ( HRV.DATAFIM = @DATAACES AND HRV.HORAFINA >= @HORAACES ) OR ( HRV.DATAFIM = SURICATO.DATA19001231() ) )
              AND NOT EXISTS (
                SELECT 1 FROM SURICATO.TBBLOQUCRACH
                  WHERE 
                    ICARD = HV.ICARDV
                    AND ( DATABLOQ < @DATAACES OR ( DATABLOQ = @DATAACES AND HORABLOQ <= @HORAACES ) ) 
                    AND ( DATALIBE > @DATAACES OR ( DATALIBE = @DATAACES AND HORALIBE >= @HORAACES ) OR ( DATALIBE = SURICATO.DATA19001231() ) )                        
                    AND CODIMOTI = 1004
              )

      END
      ELSE
      BEGIN

        UPDATE SURICATO.TBBLOQUCRACH
          SET DATALIBE = @DATAACES, HORALIBE = @HORAACES - 1, STATATUACONT = 2
          WHERE 
            EXISTS
            (
                SELECT 
                      1
                    FROM 
                      SURICATO.TBHISTORESPVEICU HRV
                    INNER JOIN SURICATO.TBHISTOVEICU HV
                      ON HRV.IDVEIC = HV.IDVEIC
                    WHERE
                      HRV.IDCOLAB IN (
                        SELECT 
                            HRV.IDCOLAB
                          FROM 
                            SURICATO.TBHISTORESPVEICU HRV
                          INNER JOIN SURICATO.TBHISTOVEICU HV
                            ON HRV.IDVEIC = HV.IDVEIC
                          WHERE
                            HV.ICARDV = @ICARDREAL 
                            AND ( HRV.DATAINIC < @DATAACES OR ( HRV.DATAINIC = @DATAACES AND HRV.HORAINIC <= @HORAACES ) ) 
                            AND ( HRV.DATAFIM > @DATAACES OR ( HRV.DATAFIM = @DATAACES AND HRV.HORAFINA >= @HORAACES ) OR ( HRV.DATAFIM = SURICATO.DATA19001231() ) )
                      )
                      AND HV.ICARDV <> @ICARDREAL  
                      AND HV.ICARDV = ICARD
                      AND ( HRV.DATAINIC < @DATAACES OR ( HRV.DATAINIC = @DATAACES AND HRV.HORAINIC <= @HORAACES ) ) 
                      AND ( HRV.DATAFIM > @DATAACES OR ( HRV.DATAFIM = @DATAACES AND HRV.HORAFINA >= @HORAACES ) OR ( HRV.DATAFIM = SURICATO.DATA19001231() ) )
            )
            AND ( DATABLOQ < @DATAACES OR ( DATABLOQ = @DATAACES AND HORABLOQ <= @HORAACES ) ) 
            AND ( DATALIBE > @DATAACES OR ( DATALIBE = @DATAACES AND HORALIBE >= @HORAACES ) OR ( DATALIBE = SURICATO.DATA19001231() ) )                            
            AND CODIMOTI = 1004
	 
      END

    END
    -- <<< CONTROLAR 1 ENTRADA DE VEÍCULO POR PESSOA  


    -- >>> CONTROLAR BAIXA DE SAÍDA DE VEÍCULO DE VISITANTE
    IF @CODAC = '01' 
       AND @POSIC = '1'
       AND @ICARDVEICULO > 0
       AND EXISTS ( SELECT 1 FROM SURICATO.TBPARAMSERVI 
              WHERE 
              NOME = 'BAIXAR_VEICULO_VISITANTE' 
              AND VALO = 'S' 
              AND EXISTS (SELECT 1 FROM SURICATO.TBCODIN WHERE CODIPLAN = @CODIPLAN AND CODICOLE = @CODICOLE AND LOCACOLE = 1 AND BAIXAUTOCRAC = 'S') ) 
    BEGIN

      UPDATE SURICATO.TBHISTOVEICU SET DATAFIM = @DATAACES, HORAFINA = @HORAACES - 1 
      WHERE 
        ICARDV = @ICARDVEICULO
        AND ( DATAINIC < @DATAACES OR ( DATAINIC = @DATAACES AND HORAINIC <= @HORAACES ) ) 
              AND ( DATAFIM > @DATAACES OR ( DATAFIM = @DATAACES AND HORAFINA >= @HORAACES ) OR ( DATAFIM = SURICATO.DATA19001231() ) )
              AND TIPOPESS = 'V'

    END
    -- <<< CONTROLAR BAIXA DE SAÍDA DE VEÍCULO DE VISITANTE

   
    FIM:   
    IF @ERRO = 1
    BEGIN
      INSERT INTO SURICATO.TBMARCAREJEI ( DATALOGPROC, ICARD, DIAMARC, MESMARC, ANOMARC, HORAMARC, TIPOACES, DIREACES, BLUEB, CODICOLEALFA, NUMEENDEIP, CODIFUNC, DESCLOG, NOMETABETELE, DATAALAR, ENTRALAR, OCORALAR, NOMELISTBENE, STATDEVEBENE, SEGUMARC, VEIC, PESOREFE, VALOKILOREFE, VALOREFE, QUANSOBR, NIVEACES, FAIXHORAREFE, QUANCRED, SITUCRAC, QUANMENS )
      VALUES ( CONVERT( NUMERIC( 14, 6 ) , GETDATE() ), @ICARD, @DIAM, @MESM, @ANOM, @HORAM, @CODAC, @POSIC, @BLUEB, @CODTT, @END_IP, @CODIFUNC, @DESLOG, 'DAM00', NULL, NULL, NULL, NULL, NULL, @SEGUNDO, @VEICULO, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL )
    END

    FETCH NEXT FROM CUR_DAM00_INS_NEW INTO @ICARD, @DIAM, @MESM, @ANOM, @HORAM, @SEGUNDO, @CODAC, @POSIC, @BLUEB, @CODTT, @END_IP, @CODIFUNC, @ONOFF, @VEICULO

  END

  CLOSE CUR_DAM00_INS_NEW
 
  DEALLOCATE CUR_DAM00_INS_NEW

END

GO


-----------------------------------------------------------------------------------------
-- 2.10.11.12 || 2.10.11.12 || 2.10.11.12 || 2.10.11.12 || 2.10.11.12 || 2.10.11.12 || --
-----------------------------------------------------------------------------------------

-- SEM ALTERAÇÃO DE SCRIPT NESTA RELEASE

-----------------------------------------------------------------------------------------
-- 2.10.11.13 || 2.10.11.13 || 2.10.11.13 || 2.10.11.13 || 2.10.11.13 || 2.10.11.13 || --
-----------------------------------------------------------------------------------------

-- SEM ALTERAÇÃO DE SCRIPT NESTA RELEASE

-----------------------------------------------------------------------------------------
-- 2.10.11.14 || 2.10.11.14 || 2.10.11.14 || 2.10.11.14 || 2.10.11.14 || 2.10.11.14 || --
-----------------------------------------------------------------------------------------

-- SEM ALTERAÇÃO DE SCRIPT NESTA RELEASE

-----------------------------------------------------------------------------------------
-- 2.10.11.15 || 2.10.11.15 || 2.10.11.15 || 2.10.11.15 || 2.10.11.15 || 2.10.11.15 || --
-----------------------------------------------------------------------------------------

-- SEM ALTERAÇÃO DE SCRIPT NESTA RELEASE

-----------------------------------------------------------------------------------------
-- 2.10.11.16 || 2.10.11.16 || 2.10.11.16 || 2.10.11.16 || 2.10.11.16 || 2.10.11.16 || --
-----------------------------------------------------------------------------------------

-- SEM ALTERAÇÃO DE SCRIPT NESTA RELEASE

-----------------------------------------------------------------------------------------
-- 2.10.11.17 || 2.10.11.17 || 2.10.11.17 || 2.10.11.17 || 2.10.11.17 || 2.10.11.17 || --
-----------------------------------------------------------------------------------------

-- SEM ALTERAÇÃO DE SCRIPT NESTA RELEASE

-----------------------------------------------------------------------------------------
-- 2.10.11.18 || 2.10.11.18 || 2.10.11.18 || 2.10.11.18 || 2.10.11.18 || 2.10.11.18 || --
-----------------------------------------------------------------------------------------

-- SEM ALTERAÇÃO DE SCRIPT NESTA RELEASE

-----------------------------------------------------------------------------------------
-- 2.10.11.19 || 2.10.11.19 || 2.10.11.19 || 2.10.11.19 || 2.10.11.19 || 2.10.11.19 || --
-----------------------------------------------------------------------------------------

-- SEM ALTERAÇÕES DE SCRIPT NESTA RELEASE